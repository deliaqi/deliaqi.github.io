<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>懒人做法实践之路</title>
    <url>/2020/03/17/easyfood/</url>
    <content><![CDATA[<p>(〃’▽’〃) 好吃好玩又好做的食物</p>
<ol>
<li>微甜甜品</li>
<li>各种饭饭</li>
<li>好多肉啊</li>
<li>花式素菜</li>
</ol>
<a id="more"></a>
<h1 id="微甜甜品"><a href="#微甜甜品" class="headerlink" title="微甜甜品"></a>微甜甜品</h1><h2 id="牛奶椰蓉小方"><a href="#牛奶椰蓉小方" class="headerlink" title="牛奶椰蓉小方"></a>牛奶椰蓉小方</h2><p><img src="/images/life/%E6%A4%B0%E8%93%89%E5%B0%8F%E6%96%B9.jpg" alt="Op5XehMqQCuGxmCTNr+eLg_thumb_60b3"></p>
<p>[<a href="https://www.zhihu.com/question/34583573/answer/764259693]" target="_blank" rel="noopener">https://www.zhihu.com/question/34583573/answer/764259693]</a>(有哪些不用烤箱就能自制的甜品？ - 琪小姐的回答 - 知乎)</p>
<p>糖的分量减半啦，玉米淀粉用普通淀粉代替了。</p>
<h2 id="香芋派"><a href="#香芋派" class="headerlink" title="香芋派"></a>香芋派</h2><p><img src="/images/life/%E9%A6%99%E8%8A%8B%E6%B4%BE1.jpg" alt="Wzbgr5cBQGSnz1W8zxD18Q_thumb_60aa"></p>
<p><img src="/images/life/%E9%A6%99%E8%8A%8B%E6%B4%BE2.jpg" alt="BwUYA1tJRLSNtMjCpmR8%Q_thumb_60a9"></p>
<p>[<a href="https://www.zhihu.com/question/34583573/answer/790679319]" target="_blank" rel="noopener">https://www.zhihu.com/question/34583573/answer/790679319]</a>(有哪些不用烤箱就能自制的甜品？ - 君君辅食记的回答 - 知乎)</p>
<p>有点丑嗷，但是味道真的不错=。= </p>
<p>同样的糖减半了，白砂糖用蜂蜜代替的。</p>
<h1 id="各种饭饭"><a href="#各种饭饭" class="headerlink" title="各种饭饭"></a>各种饭饭</h1><h2 id="排骨焖饭"><a href="#排骨焖饭" class="headerlink" title="排骨焖饭"></a>排骨焖饭</h2><p><img src="/images/life/%E6%8E%92%E9%AA%A8%E7%84%96%E9%A5%AD1.jpg" alt="UNADJUSTEDNONRAW_thumb_60c3"></p>
<p><img src="/images/life/%E6%8E%92%E9%AA%A8%E7%84%96%E9%A5%AD2.jpg" alt="UNADJUSTEDNONRAW_thumb_60c4"></p>
<p><a href="https://www.xiachufang.com/recipe/1065180/" target="_blank" rel="noopener">https://www.xiachufang.com/recipe/1065180/</a></p>
<p>DIY空间很大～自己加了玉米粒，只蒸了一次米饭，依然超！级！香！</p>
<h2 id="咖喱焗饭"><a href="#咖喱焗饭" class="headerlink" title="咖喱焗饭"></a>咖喱焗饭</h2><p><img src="/images/life/%E5%92%96%E5%96%B1%E7%84%97%E9%A5%AD.jpeg" alt="咖喱焗饭"><br>先蒸好菜饭，加点水拌入咖喱，最后把略微煎了下的培根虾仁和饭混匀，上面撒一层芝士就可以放进烤箱了。<br>发挥空间很大，其实直接咖喱饭或者芝士焗饭就挺好吃吧。</p>
<h1 id="好多肉啊"><a href="#好多肉啊" class="headerlink" title="好多肉啊"></a>好多肉啊</h1><h2 id="椒盐排骨"><a href="#椒盐排骨" class="headerlink" title="椒盐排骨"></a>椒盐排骨</h2><p><img src="/images/life/%E6%A4%92%E7%9B%90%E6%8E%92%E9%AA%A8.jpg" alt="L%QA38JpTP66BfX9Jl6H%g_thumb_5fe5"></p>
<h2 id="蜜汁鸡翅-amp-鸡腿"><a href="#蜜汁鸡翅-amp-鸡腿" class="headerlink" title="蜜汁鸡翅&amp;鸡腿"></a>蜜汁鸡翅&amp;鸡腿</h2><p><img src="/images/life/%E8%9C%9C%E6%B1%81%E9%B8%A1%E7%BF%85.jpg" alt="9wo%YPQ0S7+rHBQ0JglSSQ_thumb_5f17"></p>
<h2 id="肉末豆腐"><a href="#肉末豆腐" class="headerlink" title="肉末豆腐"></a>肉末豆腐</h2><p><img src="/images/life/%E8%82%89%E6%9C%AB%E8%B1%86%E8%85%90.jpg" alt="9yb%6dTXRIyAeSiTBseVjA_thumb_5fcb"></p>
<h2 id="牛肉丸子汤"><a href="#牛肉丸子汤" class="headerlink" title="牛肉丸子汤"></a>牛肉丸子汤</h2><p><img src="/images/life/%E7%89%9B%E8%82%89%E4%B8%B8%E5%AD%90%E6%B1%A4.jpg" alt="UNADJUSTEDNONRAW_thumb_5fcf"></p>
<h2 id="盐焗鸡"><a href="#盐焗鸡" class="headerlink" title="盐焗鸡"></a>盐焗鸡</h2><p><img src="/images/life/%E7%9B%90%E7%84%97%E9%B8%A1.jpeg" alt="盐焗鸡"><br>直接用的盐焗粉，葱姜片垫底，抹好直接放电饭煲蒸半小时就好啦。<br>事先腌一下应该更入味。</p>
<h2 id="椰子鸡"><a href="#椰子鸡" class="headerlink" title="椰子鸡"></a>椰子鸡</h2><p><img src="/images/life/%E6%A4%B0%E5%AD%90%E9%B8%A1.jpeg" alt="椰子鸡"><br>主要参考的曼食慢语的菜谱：<a href="https://www.xiachufang.com/recipe/103465588/" target="_blank" rel="noopener">https://www.xiachufang.com/recipe/103465588/</a><br>跟着广东室友做的。用了一只老椰🥥的椰水，椰肉用了一半。鸡用的是一整只小母鸡，只用煮十分钟，非常嫩！</p>
<h2 id="脆皮烤鸡"><a href="#脆皮烤鸡" class="headerlink" title="脆皮烤鸡"></a>脆皮烤鸡</h2><p><img src="/images/life/%E8%84%86%E7%9A%AE%E7%83%A4%E9%B8%A1.jpeg" alt="脆皮烤鸡"><br>这算是看了那么多菜单过后自己总结出来的。</p>
<ol>
<li>椒盐按摩鸡身，然后用牙签猛插孔（为了腌得更入味），放冰箱里面一晚上。</li>
<li>预热到425度，烤鸡刷少许花椒油放入。</li>
<li>30-40分钟后再刷一层蜂蜜，最后烤5分钟就好啦！</li>
</ol>
<h2 id="蘑菇烧鸡"><a href="#蘑菇烧鸡" class="headerlink" title="蘑菇烧鸡"></a>蘑菇烧鸡</h2><p><img src="/images/life/%E8%98%91%E8%8F%87%E7%83%A7%E9%B8%A1.jpeg" alt="蘑菇烧鸡"><br>最近做了好多鸡诶，这个做法很家常啦。</p>
<h2 id="猪肉丸子汤"><a href="#猪肉丸子汤" class="headerlink" title="猪肉丸子汤"></a>猪肉丸子汤</h2><p><img src="/images/life/%E7%8C%AA%E8%82%89%E4%B8%B8%E5%AD%90%E6%B1%A4.jpeg" alt="猪肉丸子汤"><br>丸子还是猪肉香呀（潮汕牛肉丸除外）</p>
<h1 id="花式素菜"><a href="#花式素菜" class="headerlink" title="花式素菜"></a>花式素菜</h1><h2 id="酱汁杏鲍菇"><a href="#酱汁杏鲍菇" class="headerlink" title="酱汁杏鲍菇"></a>酱汁杏鲍菇</h2><p><img src="/images/life/%E9%85%B1%E6%B1%81%E6%9D%8F%E9%B2%8D%E8%8F%87.jpeg" alt="酱汁杏鲍菇"><br>下厨房链接：<a href="https://www.xiachufang.com/recipe/104527015/" target="_blank" rel="noopener">https://www.xiachufang.com/recipe/104527015/</a><br>先煎后焖，比肉还好吃的杏鲍菇！</p>
<h2 id="酿豆腐"><a href="#酿豆腐" class="headerlink" title="酿豆腐"></a>酿豆腐</h2><p><img src="/images/life/%E9%85%BF%E8%B1%86%E8%85%90.jpeg" alt="酿豆腐"><br>下厨房链接：<a href="https://www.xiachufang.com/recipe/100054342/" target="_blank" rel="noopener">https://www.xiachufang.com/recipe/100054342/</a><br>没有吃过正宗的，感觉自己做的味道还不错，就是焖的时间有点短了。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>food</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1110 - Delete Nodes And Return Forest (DFS)</title>
    <url>/2020/03/27/leetcode-1110/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 98.12% of Java online submissions for Delete Nodes And Return Forest.<br>Memory Usage: 40.5 MB, less than 100.00% of Java online submissions for Delete Nodes And Return Forest.</p>
<a id="more"></a>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>M is the number of deleted elements,  N is the number of nodes.</p>
<p>Space Complexity: O(logN), actually O(min(M, depth))</p>
<ol>
<li>deleteSet - O(M)</li>
<li>Recursion - O(depth of the tree), or O(logN)</li>
</ol>
<p>Time Complexity: O(N).</p>
<ol>
<li>build deleteSet - O(M)</li>
<li>dfs - O(N)</li>
</ol>
<h3 id="Java-Solution"><a href="#Java-Solution" class="headerlink" title="Java Solution"></a>Java Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">delNodes</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] to_delete)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; treeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> treeList;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; deleteSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : to_delete) &#123;</span><br><span class="line">            deleteSet.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, <span class="keyword">null</span>, treeList, deleteSet);</span><br><span class="line">        <span class="keyword">return</span> treeList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode prev, List&lt;TreeNode&gt; treeList, Set&lt;Integer&gt; deleteSet)</span> </span>&#123;</span><br><span class="line">        TreeNode leftNode = root.left;</span><br><span class="line">        TreeNode rightNode = root.right;</span><br><span class="line">        <span class="comment">// check myself</span></span><br><span class="line">        <span class="keyword">if</span> (deleteSet.contains(root.val)) &#123;</span><br><span class="line">            <span class="comment">// delete myself from prev</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev.left == root) &#123;</span><br><span class="line">                    prev.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    prev.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">                treeList.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dfs left child</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(leftNode, prev, treeList, deleteSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs right child</span></span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(rightNode, prev, treeList, deleteSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Google</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1007 - Minimum Domino Rotations For Equal Row (Greedy)</title>
    <url>/2020/03/20/leetcode-1007/</url>
    <content><![CDATA[<p>Space Complexity: O(1), Time Complexity: O(N).</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDominoRotations</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fix A[0] and check A/B</span></span><br><span class="line">    <span class="keyword">int</span> res1 = checkElement(A[<span class="number">0</span>], A, B);</span><br><span class="line">    <span class="comment">// Fix B[0] and check A/B</span></span><br><span class="line">    <span class="keyword">int</span> res2 = checkElement(B[<span class="number">0</span>], A, B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = Math.min(res1, res2);</span><br><span class="line">    <span class="keyword">if</span> (res == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkElement</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rotateA = <span class="number">0</span>, rotateB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != x &amp;&amp; B[i] != x) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != x) &#123;</span><br><span class="line">            rotateA++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B[i] != x) &#123;</span><br><span class="line">            rotateB++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(rotateA, rotateB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1192 - Critical Connections in a Network</title>
    <url>/2020/05/01/leetcode-1192/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network.</p>
<p>A critical connection is a connection that, if removed, will make some server unable to reach some other server.</p>
<p>Return all critical connections in the network in any order.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 178 ms, faster than 20.85% of Java online submissions.<br>Memory Usage: 137.5 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; conn : connections) &#123;</span><br><span class="line">            graph.get(conn.get(<span class="number">0</span>)).add(conn.get(<span class="number">1</span>));</span><br><span class="line">            graph.get(conn.get(<span class="number">1</span>)).add(conn.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] smallestCount = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dfs(graph, -<span class="number">1</span>, <span class="number">0</span>, visited, smallestCount);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Set&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> lastNode, <span class="keyword">int</span> curNode, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] smallestCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curCount = counter;</span><br><span class="line">        smallestCount[curNode] = counter++;</span><br><span class="line">        visited[curNode] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : graph.get(curNode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextNode == lastNode) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[nextNode]) &#123;</span><br><span class="line">                dfs(graph, curNode, nextNode, visited, smallestCount);</span><br><span class="line">            &#125;</span><br><span class="line">            smallestCount[curNode] = Math.min(smallestCount[curNode], smallestCount[nextNode]);</span><br><span class="line">            <span class="keyword">if</span> (curCount &lt; smallestCount[nextNode]) &#123;</span><br><span class="line">                result.add(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;curNode, nextNode&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1048 - Longest String Chain (Graph)</title>
    <url>/2020/03/21/leetcode-1048/</url>
    <content><![CDATA[<h2 id="Approach-1-Graph"><a href="#Approach-1-Graph" class="headerlink" title="Approach 1 - Graph"></a>Approach 1 - Graph</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 38 ms, faster than 41.66% of Java online submissions for Longest String Chain.<br>Memory Usage: 42 MB, less than 100.00% of Java online submissions for Longest String Chain.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N^2), Time Complexity: O(M*N).</p>
<p>M: length of words, N: number of words.</p>
<a id="more"></a>


<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; graphMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; indegreeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// add all string as predecessors: O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">        graphMap.put(s, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        indegreeMap.put(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build graph: O(n*word_length)</span></span><br><span class="line">    <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// traverse predecessors</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                cur = s.substring(<span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = s.substring(<span class="number">0</span>, i) + s.substring(i+<span class="number">1</span>, s.length());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (graphMap.containsKey(cur)) &#123;</span><br><span class="line">                graphMap.get(cur).add(s);</span><br><span class="line">                indegreeMap.put(s, indegreeMap.get(s) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collect "start" words</span></span><br><span class="line">    <span class="keyword">for</span> (String s : indegreeMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegreeMap.get(s) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// BFS: O(depth) -&gt; O(logn)</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">int</span> count = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String s = queue.poll();</span><br><span class="line">            queue.addAll(graphMap.get(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Approach-2-Dynamic-Progrmming"><a href="#Approach-2-Dynamic-Progrmming" class="headerlink" title="Approach 2 - Dynamic Progrmming"></a>Approach 2 - Dynamic Progrmming</h2><p>To be continued.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Dynamic Programming</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1268 - Search Suggestions System</title>
    <url>/2020/05/08/leetcode-1268/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an array of strings products and a string searchWord. We want to design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with the searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.</p>
<p>Return list of lists of the suggested products after each character of searchWord is typed. </p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 40 ms, faster than 30.92% of Java online submissions.<br>Memory Usage: 47.9 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        TreeMap&lt;Character, Node&gt; nexts;</span><br><span class="line">        TreeSet&lt;String&gt; words;</span><br><span class="line">        Node parent;</span><br><span class="line">        <span class="keyword">boolean</span> isEnd;</span><br><span class="line">        Node(<span class="keyword">char</span> newC, Node p) &#123;</span><br><span class="line">            c = newC;</span><br><span class="line">            nexts = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">            words = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">            parent = p;</span><br><span class="line">            isEnd = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(<span class="string">' '</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// build tree</span></span><br><span class="line">        <span class="keyword">for</span> (String word : products) &#123;</span><br><span class="line">            Node tmp = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> curC = word.charAt(i);</span><br><span class="line">                Node curNode = tmp.nexts.getOrDefault(curC, <span class="keyword">new</span> Node(curC, tmp));</span><br><span class="line">                tmp.nexts.put(curC, curNode);</span><br><span class="line">                tmp = curNode;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.isEnd = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// fill in word set</span></span><br><span class="line">            <span class="keyword">while</span> (tmp != root) &#123;</span><br><span class="line">                tmp.words.add(word);</span><br><span class="line">                <span class="keyword">if</span> (tmp.words.size() &gt; <span class="number">3</span>) tmp.words.pollLast();</span><br><span class="line">                tmp = tmp.parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// search tree</span></span><br><span class="line">        <span class="keyword">int</span> length = searchWord.length();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(length);</span><br><span class="line">        Node tmp = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> curC = searchWord.charAt(i);</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tmp = tmp.nexts.getOrDefault(curC, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    list.addAll(tmp.words);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1146 - Snapshot Array</title>
    <url>/2020/04/27/leetcode-1146/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement a SnapshotArray that supports the following interface:</p>
<p>SnapshotArray(int length) initializes an array-like data structure with the given length.  Initially, each element equals 0.<br>void set(index, val) sets the element at the given index to be equal to val.<br>int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.<br>int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 42 ms, faster than 35.60% of Java online submissions.<br>Memory Usage: 61.2 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span> </span>&#123;</span><br><span class="line">    List&lt;TreeMap&lt;Integer, Integer&gt;&gt; snapList;</span><br><span class="line">    <span class="keyword">int</span> snapNum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        snapList = <span class="keyword">new</span> ArrayList&lt;&gt;(length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            snapList.add(<span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        snapList.get(index).put(snapNum, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> snapNum++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> snap_id)</span> </span>&#123;</span><br><span class="line">        Integer id = snapList.get(index).floorKey(snap_id);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> snapList.get(index).get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SnapshotArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SnapshotArray obj = new SnapshotArray(length);</span></span><br><span class="line"><span class="comment"> * obj.set(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.snap();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.get(index,snap_id);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 127 - Word Ladder &amp; Leetcode 126 - Word Ladder II</title>
    <url>/2020/04/18/leetcode-127/</url>
    <content><![CDATA[<h2 id="Leetcode-127-Word-Ladder"><a href="#Leetcode-127-Word-Ladder" class="headerlink" title="Leetcode 127 - Word Ladder"></a>Leetcode 127 - Word Ladder</h2><p><strong>Description</strong><br>Given two words (beginWord and endWord), and a dictionary’s word list, find the <strong>length</strong> of shortest transformation sequence from beginWord to endWord, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list.</li>
</ol>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 61 ms, faster than 53.14% of Java online submissions.<br>Memory Usage: 40.8 MB, less than 72.26% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String w : wordList) &#123;</span><br><span class="line">            dict.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dict.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          String w = queue.poll();</span><br><span class="line">          size--;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] a = w.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++) &#123;</span><br><span class="line">              a[i] = j;</span><br><span class="line">              String newOne = <span class="keyword">new</span> String(a);</span><br><span class="line">              <span class="keyword">if</span> (newOne.equals(endWord))</span><br><span class="line">                <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (dict.contains(newOne)) &#123;</span><br><span class="line">                queue.add(newOne);</span><br><span class="line">                dict.remove(newOne);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            size = queue.size();</span><br><span class="line">            level++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Leetcode-126-Word-Ladder-II"><a href="#Leetcode-126-Word-Ladder-II" class="headerlink" title="Leetcode 126 - Word Ladder II"></a>Leetcode 126 - Word Ladder II</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given two words (beginWord and endWord), and a dictionary’s word list, find <strong>all shortest transformation sequence(s)</strong> from beginWord to endWord, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</li>
</ol>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 84 ms, faster than 70.21% of Java online submissions.<br>Memory Usage: 40.7 MB, less than 86.54% of Java online submissions.</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String w : wordList) &#123;</span><br><span class="line">            dict.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dict.contains(beginWord)) dict.remove(beginWord);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!dict.contains(endWord) || beginWord.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &lt;child, parent&gt;</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; prevMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; neighborMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            Set&lt;String&gt; nexts = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// traverse all neighbors</span></span><br><span class="line">                String cur = queue.poll();</span><br><span class="line">                List&lt;String&gt; neighbors = getNeighbors(cur, dict);</span><br><span class="line">                <span class="keyword">for</span> (String newOne : neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(newOne)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (newOne.equals(endWord)) &#123;</span><br><span class="line">                            found = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        List&lt;String&gt; prevList = prevMap.getOrDefault(newOne, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                        prevList.add(cur);</span><br><span class="line">                        prevMap.put(newOne, prevList);</span><br><span class="line">                        nexts.add(newOne);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if found</span></span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// add to queue</span></span><br><span class="line">            <span class="keyword">for</span> (String s: nexts) &#123;</span><br><span class="line">                queue.add(s);</span><br><span class="line">                visited.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            LinkedList&lt;String&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            path.add(endWord);</span><br><span class="line">            dfs(endWord, path, prevMap, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch =<span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chs[i] == ch) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">                chs[i] = ch;</span><br><span class="line">                <span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                    res.add(String.valueOf(chs));</span><br><span class="line">                &#125;</span><br><span class="line">                chs[i] = old_ch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, LinkedList&lt;String&gt; path, Map&lt;String, List&lt;String&gt;&gt; prevMap, List&lt;List&lt;String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!prevMap.containsKey(s)) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String pre : prevMap.get(s)) &#123;</span><br><span class="line">            path.addFirst(pre);</span><br><span class="line">            dfs(pre, path, prevMap, result);</span><br><span class="line">            path.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1334 - Find the City With the Smallest Number of Neighbors at a Threshold Distance</title>
    <url>/2020/04/30/leetcode-1334/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.</p>
<p>Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.</p>
<p>Notice that the distance of a path connecting cities i and j is equal to the sum of the edges’ weights along that path.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 110 ms, faster than 21.53% of Java online submissions.<br>Memory Usage: 40.1 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheCity</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; edgeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">            edgeMap.putIfAbsent(edge[<span class="number">0</span>], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            edgeMap.get(edge[<span class="number">0</span>]).put(edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">            edgeMap.putIfAbsent(edge[<span class="number">1</span>], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            edgeMap.get(edge[<span class="number">1</span>]).put(edge[<span class="number">0</span>], edge[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a1, a2) -&gt; (a2[<span class="number">1</span>] - a1[<span class="number">1</span>]));</span><br><span class="line">            Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, distanceThreshold&#125;);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] edge = q.poll();</span><br><span class="line">                <span class="keyword">int</span> nextNode = edge[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> limit = edge[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(nextNode)) <span class="keyword">continue</span>;</span><br><span class="line">                visited.add(nextNode);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (edgeMap.containsKey(nextNode)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : edgeMap.get(nextNode).entrySet()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(entry.getKey()) &amp;&amp; entry.getValue() &lt;= limit) &#123;</span><br><span class="line">                            q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;entry.getKey(), limit - entry.getValue()&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count - <span class="number">1</span> &lt;= min) &#123;</span><br><span class="line">                min = count - <span class="number">1</span>;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 138 - Copy List with Random Pointer</title>
    <url>/2020/05/10/leetcode-138/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<p>The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:</p>
<p>val: an integer representing Node.val<br>random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions.<br>Memory Usage: 39.3 MB, less than 5.61% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// &lt;old, new&gt;</span></span><br><span class="line">        Map&lt;Node, Node&gt; copyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node newhead = <span class="keyword">new</span> Node(head.val);</span><br><span class="line">        copyMap.put(head, newhead);</span><br><span class="line">        searchRandom(head, copyMap);</span><br><span class="line">        </span><br><span class="line">        Node cur = head.next, newPrev = newhead, newCur;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!copyMap.containsKey(cur)) &#123;</span><br><span class="line">                copyMap.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// search random list</span></span><br><span class="line">            searchRandom(cur, copyMap);</span><br><span class="line">            </span><br><span class="line">            newCur = copyMap.get(cur);</span><br><span class="line">            newPrev.next = newCur;</span><br><span class="line">            newPrev = newCur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">searchRandom</span><span class="params">(Node oldNode, Map&lt;Node, Node&gt; copyMap)</span> </span>&#123;</span><br><span class="line">        Node newPrev = copyMap.get(oldNode), newCur = <span class="keyword">null</span>;</span><br><span class="line">        Node cur = oldNode.random;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!copyMap.containsKey(cur)) &#123;</span><br><span class="line">                copyMap.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            &#125;</span><br><span class="line">            newCur = copyMap.get(cur);</span><br><span class="line">            newPrev.random = newCur;</span><br><span class="line">            newPrev = newCur;</span><br><span class="line">            cur = cur.random;</span><br><span class="line">            <span class="keyword">if</span> (newCur.random != <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1320 - Minimum Distance to Type a Word Using Two Fingers</title>
    <url>/2020/04/24/leetcode-1320/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You have a keyboard layout as shown above in the XY plane, where each English uppercase letter is located at some coordinate, for example, the letter A is located at coordinate (0,0), the letter B is located at coordinate (0,1), the letter P is located at coordinate (2,3) and the letter Z is located at coordinate (4,1).</p>
<p>Given the string word, return the minimum total distance to type such string using only two fingers. The distance between coordinates (x1,y1) and (x2,y2) is |x1 - x2| + |y1 - y2|. </p>
<p>Note that the initial positions of your two fingers are considered free so don’t count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.<br><a href="https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/</a></p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 25 ms, faster than 53.43% of Java online submissions.<br>Memory Usage: 41.2 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDistance</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = word.length();</span><br><span class="line">        <span class="keyword">int</span>[][][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[][] arr : memo) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] tmp : arr) Arrays.fill(tmp, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record location</span></span><br><span class="line">        Map&lt;Integer, <span class="keyword">int</span>[]&gt; posMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">5</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">6</span>; col++) &#123;</span><br><span class="line">                posMap.put(c, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row, col&#125;);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(posMap, word, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Map&lt;Integer, <span class="keyword">int</span>[]&gt; posMap, String word, <span class="keyword">int</span> index, <span class="keyword">int</span> pos1, <span class="keyword">int</span> pos2, <span class="keyword">int</span>[][][] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> distance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos1 &gt; -<span class="number">1</span> &amp;&amp; pos2 &gt; -<span class="number">1</span> &amp;&amp; memo[index][pos1][pos2] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[index][pos1][pos2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(index);</span><br><span class="line">        <span class="comment">// figure 1</span></span><br><span class="line">        <span class="keyword">int</span> d1 = dfs(posMap, word, index + <span class="number">1</span>, c - <span class="string">'A'</span>, pos2, memo) + getDistance(c - <span class="string">'A'</span>, pos1, posMap);</span><br><span class="line">        <span class="comment">// figure 2</span></span><br><span class="line">        <span class="keyword">int</span> d2 = dfs(posMap, word, index + <span class="number">1</span>, pos1, c - <span class="string">'A'</span>, memo) + getDistance(c - <span class="string">'A'</span>, pos2, posMap);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pos1 != -<span class="number">1</span> &amp;&amp; pos2 != -<span class="number">1</span>) &#123;</span><br><span class="line">            memo[index][pos1][pos2] = distance + Math.min(d1, d2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance + Math.min(d1, d2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">int</span> c1, <span class="keyword">int</span> c2, Map&lt;Integer, <span class="keyword">int</span>[]&gt; posMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c1 == -<span class="number">1</span> || c2 == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] pos1 = posMap.get(c1);</span><br><span class="line">        <span class="keyword">int</span>[] pos2 = posMap.get(c2);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(pos1[<span class="number">0</span>] - pos2[<span class="number">0</span>]) + Math.abs(pos1[<span class="number">1</span>] - pos2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 146 - LRU Cache</title>
    <url>/2020/05/06/leetcode-146/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a positive capacity.</p>
<p>Follow up:<br>Could you do both operations in O(1) time complexity?</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 12 ms, faster than 95.09% of Java online submissions.<br>Memory Usage: 47.9 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LRUMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">        LRUMap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">            cacheSize = capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LRUMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LRUMap&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - Sliding Window</title>
    <url>/2020/04/12/leetcode-3/</url>
    <content><![CDATA[<p>3.Longest Substring Without Repeating Characters<br>76.Minimum Window Substring<br>862.Shortest Subarray with Sum at Least K</p>
<a id="more"></a>

<h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// &lt;char, index&gt;</span></span><br><span class="line">        Map&lt;Character, Integer&gt; recordMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (recordMap.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = recordMap.get(c);</span><br><span class="line">                <span class="keyword">while</span> (i &lt;= next) &#123;</span><br><span class="line">                    recordMap.remove(s.charAt(i++));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            recordMap.put(c, j++);</span><br><span class="line">            result = Math.max(result, j - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sContainsT</span><span class="params">(<span class="keyword">int</span> countS[], <span class="keyword">int</span> countT[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countT.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countT[i] &gt; countS[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;           </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> countS[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> countT[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            countT[t.charAt(i)]++;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>, min = Integer.MAX_VALUE;         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; s.length() &amp;&amp; !sContainsT(countS, countT)) &#123;</span><br><span class="line">                countS[s.charAt(right)]++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sContainsT(countS, countT) &amp;&amp; min &gt; right - i + <span class="number">1</span>) &#123;</span><br><span class="line">                result = s.substring(i, right);</span><br><span class="line">                min = right - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Shrink</span></span><br><span class="line">            countS[s.charAt(i)]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="862-Shortest-Subarray-with-Sum-at-Least-K"><a href="#862-Shortest-Subarray-with-Sum-at-Least-K" class="headerlink" title="862. Shortest Subarray with Sum at Least K"></a>862. Shortest Subarray with Sum at Least K</h2><p>kind of Sliding window</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
        <tag>Sliding Window</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 200 - Number of Islands</title>
    <url>/2020/05/03/leetcode-200/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.96% of Java online submissions.<br>Memory Usage: 41.9 MB, less than 47.44% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    result ++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= grid.length || col &gt;= grid[<span class="number">0</span>].length || grid[row][col] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[row][col] = <span class="string">'0'</span>;</span><br><span class="line">        dfs(grid, row, col + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, row, col - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, row + <span class="number">1</span>, col);</span><br><span class="line">        dfs(grid, row - <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 240 - Search a 2D Matrix II</title>
    <url>/2020/05/07/leetcode-240/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<pre><code>Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.</code></pre><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 7 ms, faster than 31.64% of Java online submissions.<br>Memory Usage: 44.6 MB, less than 94.34% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowNum, colNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rowNum = matrix.length, colNum = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = rowNum - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; colNum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; matrix[i][j]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == matrix[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 297 - Serialize and Deserialize Binary Tree</title>
    <url>/2020/04/08/leetcode-297/</url>
    <content><![CDATA[<p>Two solutions.</p>
<a id="more"></a>

<h3 id="Solution-1-Time-Limit-Exceeded"><a href="#Solution-1-Time-Limit-Exceeded" class="headerlink" title="Solution 1: Time Limit Exceeded"></a>Solution 1: Time Limit Exceeded</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt;  q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> isLeaf = <span class="keyword">false</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isLeaf) &#123;</span><br><span class="line">            isLeaf = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> count = q.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TreeNode n1 = <span class="keyword">null</span>, n2 = <span class="keyword">null</span>;</span><br><span class="line">                    q.offer(n1);</span><br><span class="line">                    q.offer(n2);</span><br><span class="line">                    <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span>) s+= <span class="string">","</span>;</span><br><span class="line">                    s += <span class="string">"null"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    q.offer(node.left);</span><br><span class="line">                    q.offer(node.right);</span><br><span class="line">                    <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span>) s+= <span class="string">","</span>;</span><br><span class="line">                    s += node.val;</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="keyword">null</span> || node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        isLeaf = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] arr = data.split(<span class="string">","</span>);</span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span> || arr[<span class="number">0</span>].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(Integer.parseInt(arr[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; arr.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = q.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    index += <span class="number">2</span>;</span><br><span class="line">                    TreeNode n1 = <span class="keyword">null</span>, n2 = <span class="keyword">null</span>;</span><br><span class="line">                    q.offer(n1);</span><br><span class="line">                    q.offer(n2);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String cur_val = arr[index];</span><br><span class="line">                <span class="keyword">if</span> (cur_val.equals(<span class="string">"null"</span>)) node.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur_val));</span><br><span class="line">                cur_val = arr[++index];</span><br><span class="line">                <span class="keyword">if</span> (cur_val.equals(<span class="string">"null"</span>)) node.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur_val));</span><br><span class="line">                index ++;</span><br><span class="line">                q.offer(node.left);</span><br><span class="line">                q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution-2-Accepted"><a href="#Solution-2-Accepted" class="headerlink" title="Solution 2: Accepted"></a>Solution 2: Accepted</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    preOrderTraverse(root, sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">"null"</span>).append(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(root.val).append(<span class="string">","</span>);</span><br><span class="line">    preOrderTraverse(root.left, sb);</span><br><span class="line">    preOrderTraverse(root.right, sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    Deque&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    nodes.addAll(Arrays.asList(data.split(<span class="string">","</span>)));</span><br><span class="line">    <span class="keyword">return</span> buildTree(nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(Deque&lt;String&gt; nodes)</span> </span>&#123;</span><br><span class="line">    String val = nodes.remove();</span><br><span class="line">    <span class="keyword">if</span> (val.equals(<span class="string">"null"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.valueOf(val));</span><br><span class="line">        node.left = buildTree(nodes);</span><br><span class="line">        node.right = buildTree(nodes);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 221 - Maximal Square (Dynamic Programming)</title>
    <url>/2020/03/22/leetcode-221/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 84.73% of Java online submissions for Maximal Square.</p>
<p>Memory Usage: 43.4 MB, less than 91.18% of Java online submissions for Maximal Square.</p>
<a id="more"></a>


<h3 id="Approach-1-Dynamic-Programming"><a href="#Approach-1-Dynamic-Programming" class="headerlink" title="Approach 1 - Dynamic Programming"></a>Approach 1 - Dynamic Programming</h3><p>Space Complexity: O(MN), Time Complexity: O(MN).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result * result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Approach-2-Better-Dynamic-Progrmming"><a href="#Approach-2-Better-Dynamic-Progrmming" class="headerlink" title="Approach 2 - Better Dynamic Progrmming"></a>Approach 2 - Better Dynamic Progrmming</h3><p>To be continued.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 315 - Count of Smaller Numbers After Self</title>
    <url>/2020/04/14/leetcode-315/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 92.22% of Java online submissions.<br>Memory Usage: 41.7 MB, less than 8.33% of Java online submissions.</p>
<a id="more"></a>

<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node left; </span><br><span class="line">        Node right;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">		Node root = <span class="keyword">new</span> Node(nums[nums.length - <span class="number">1</span>]);</span><br><span class="line">		res.add(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">int</span> count = insertNode(root, nums[i]);</span><br><span class="line">			res.addFirst(count);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertNode</span><span class="params">(Node root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> thisCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(val &lt;= root.val) &#123;</span><br><span class="line">				root.count++;</span><br><span class="line">				<span class="keyword">if</span>(root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">					root.left = <span class="keyword">new</span> Node(val); <span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					root = root.left;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				thisCount += root.count;</span><br><span class="line">				<span class="keyword">if</span>(root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">					root.right = <span class="keyword">new</span> Node(val); <span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					root = root.right;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> thisCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 222 - Count Complete Tree Nodes (Binary Search)</title>
    <url>/2020/03/28/leetcode-222/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Count Complete Tree Nodes.</p>
<p>Memory Usage: 42.5 MB, less than 9.76% of Java online submissions for Count Complete Tree Nodes.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(depth), either for dfs when computing depth or Stack.</p>
<p>Time Complexity: O(depth^2), and each checkExist costs  O(depth);</p>
<a id="more"></a>


<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = checkDepth(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Binary Search</span></span><br><span class="line">        <span class="keyword">int</span> left = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, depth - <span class="number">1</span>), right = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, depth) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (checkExist(root, mid)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> checkDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// can also use binary search for checkExist</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkExist</span><span class="params">(TreeNode root, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find parent</span></span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> tmp = mid;</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            path.add(tmp);</span><br><span class="line">            tmp /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode parent = root;</span><br><span class="line">        <span class="keyword">while</span> (path.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.pop() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                parent = parent.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent = parent.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p> For Saving Space: </p>
<ol>
<li>Use iteration for computing depth</li>
<li>Use binary search for checking existence</li>
</ol>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 341 - Flatten Nested List Iterator</title>
    <url>/2020/04/06/leetcode-341/</url>
    <content><![CDATA[<h2 id="Approach-1-Stack"><a href="#Approach-1-Stack" class="headerlink" title="Approach 1: Stack"></a>Approach 1: Stack</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 9 ms, faster than 6.91% of Java online submissions for Flatten Nested List Iterator.<br>Memory Usage: 43.8 MB, less than 5.00% of Java online submissions for Flatten Nested List Iterator.</p>
<a id="more"></a>


<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * public interface NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     public boolean isInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     public Integer getInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;NestedInteger&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            stack.push(nestedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop().getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateStack();</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; !stack.peek().isInteger()) &#123;</span><br><span class="line">            List&lt;NestedInteger&gt; nestedList = stack.pop().getList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                stack.push(nestedList.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i = new NestedIterator(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) v[f()] = i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="To-do"><a href="#To-do" class="headerlink" title="To do"></a>To do</h3><ol>
<li>Optimize Stack</li>
<li>Complexity analysis</li>
</ol>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>LinkedIn</tag>
        <tag>Stack</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 373 - Find K Pairs with Smallest Sums</title>
    <url>/2020/04/05/leetcode-373/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 12 ms, faster than 40.95% of Java online submissions for Find K Pairs with Smallest Sums.<br>Memory Usage: 44.8 MB, less than 33.33% of Java online submissions for Find K Pairs with Smallest Sums.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(k), both for result list and priority queue.<br>Time Complexity: O(k*logk), with O(logk) for each insertion to heap.</p>
<a id="more"></a>


<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (o1, o2)-&gt;o1[<span class="number">0</span>] + o1[<span class="number">1</span>] - o2[<span class="number">0</span>] - o2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(nums1.length, k); i++) &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[i], nums2[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; k &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// poll current pair</span></span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            List&lt;Integer&gt; curList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            curList.add(cur[<span class="number">0</span>]);</span><br><span class="line">            curList.add(cur[<span class="number">1</span>]);</span><br><span class="line">            result.add(curList);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// add potential pair</span></span><br><span class="line">            <span class="keyword">int</span> index2 = cur[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (index2 &lt; nums2.length - <span class="number">1</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>], nums2[index2 + <span class="number">1</span>], index2 + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>LinkedIn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 450 - Delete Node in a BST</title>
    <url>/2020/05/07/leetcode-450/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.<br>Note: Time complexity should be O(height of tree).</li>
</ol>
<a id="more"></a>

<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// find node</span></span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>, cur = root;</span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.val != key) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur.val &gt; key) &#123; </span><br><span class="line">                cur = cur.left;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cannot find key</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// delete leaf node</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == root) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// if delete root</span></span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> prev.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// has right child</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == root) <span class="keyword">return</span> cur.right; <span class="comment">// if delete root</span></span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = cur.right;</span><br><span class="line">            <span class="keyword">else</span> prev.right = cur.right;</span><br><span class="line">        <span class="comment">// has right child</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == root) <span class="keyword">return</span> cur.left; <span class="comment">// if delete root</span></span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = cur.left;</span><br><span class="line">            <span class="keyword">else</span> prev.right = cur.left;</span><br><span class="line">        <span class="comment">// has left and right child</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode succesor = findSuccesor(cur);</span><br><span class="line">            succesor.left = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (cur == root) <span class="keyword">return</span> succesor;</span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = succesor;</span><br><span class="line">            <span class="keyword">else</span> prev.right = succesor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">findSuccesor</span><span class="params">(TreeNode toDelete)</span> </span>&#123;</span><br><span class="line">        TreeNode cur = toDelete.right, parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cur != toDelete.right) &#123;</span><br><span class="line">            parent.left = cur.right;</span><br><span class="line">            cur.right = toDelete.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 380 - Insert Delete GetRandom O(1)</title>
    <url>/2020/04/03/leetcode-380/</url>
    <content><![CDATA[<p>Using ArrayList + HashMap.</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 75.66% of Java online submissions for Insert Delete GetRandom O(1).</p>
<p>Memory Usage: 44.3 MB, less than 94.00% of Java online submissions for Insert Delete GetRandom O(1).</p>
<a id="more"></a>

<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; dataList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap; <span class="comment">// &lt;val, index&gt;</span></span><br><span class="line">    <span class="keyword">private</span> Random rand;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        rand = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (indexMap.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dataList.add(val);</span><br><span class="line">        indexMap.put(val, dataList.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (indexMap.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = indexMap.get(val);</span><br><span class="line">            <span class="keyword">int</span> last = dataList.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (last &gt; index) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = dataList.get(last);</span><br><span class="line">                dataList.set(index, tmp);</span><br><span class="line">                indexMap.put(tmp, index);</span><br><span class="line">            &#125;</span><br><span class="line">            dataList.remove(last);</span><br><span class="line">            indexMap.remove(val);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand.nextInt(dataList.size());</span><br><span class="line">        <span class="keyword">return</span> dataList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>LinkedIn</tag>
        <tag>HashMap</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 430 - Flatten a Multilevel Doubly Linked List (DFS)</title>
    <url>/2020/03/23/leetcode-430/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Flatten a Multilevel Doubly Linked List.<br>Memory Usage: 37.9 MB, less than 72.50% of Java online submissions for Flatten a Multilevel Doubly Linked List.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(depth of child), because of recursion,<br>Time Complexity: O(number of nodes).</p>
<a id="more"></a>

<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node prev;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node();</span><br><span class="line">        Node tail = dummy;</span><br><span class="line">        dfs(head, tail);</span><br><span class="line">        <span class="keyword">if</span> (dummy.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dummy.next.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">dfs</span><span class="params">(Node head, Node tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> tail;</span><br><span class="line">        <span class="comment">// add itself</span></span><br><span class="line">        Node next = head.next;</span><br><span class="line">        tail.next = head;</span><br><span class="line">        head.prev = tail;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">        <span class="comment">// add child list</span></span><br><span class="line">        tail = dfs(head.child, tail);</span><br><span class="line">        head.child = <span class="keyword">null</span>; <span class="comment">// important!</span></span><br><span class="line">        <span class="comment">// add next node</span></span><br><span class="line">        <span class="keyword">return</span> dfs(next, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 354 - Russian Doll Envelopes</title>
    <url>/2020/04/15/leetcode-354/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.<br>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<a id="more"></a>

<h2 id="Solution-1-Dynamic-Programming"><a href="#Solution-1-Dynamic-Programming" class="headerlink" title="Solution 1: Dynamic Programming"></a>Solution 1: Dynamic Programming</h2><p>dp[i] - length of longest chain until index i</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span></span><br><span class="line">           || envelopes[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> length = envelopes.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[i][<span class="number">0</span>] == envelopes[j][<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-2-Dynamic-Programming-with-Binary-Search"><a href="#Solution-2-Dynamic-Programming-with-Binary-Search" class="headerlink" title="Solution 2: Dynamic Programming with Binary Search"></a>Solution 2: Dynamic Programming with Binary Search</h2><p>dp[i] - height of last envelope in the chain whose length is (i + 1)</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 99.86% of Java online submissions for Russian Doll Envelopes.<br>Memory Usage: 40.2 MB, less than 100.00% of Java online submissions for Russian Doll Envelopes.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(NlogN).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] e1, <span class="keyword">int</span>[] e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (e1[<span class="number">0</span>] == e2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e2[<span class="number">1</span>] - e1[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> e1[<span class="number">0</span>] - e2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> length = envelopes.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] envelope : envelopes) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = Arrays.binarySearch(dp, <span class="number">0</span>, len, envelope[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = - (i + <span class="number">1</span>);</span><br><span class="line">            dp[i] = envelope[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Hard</tag>
        <tag>Dynamic Programming</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 5 - Longest Palindromic Substring</title>
    <url>/2020/05/09/leetcode-5/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 24 ms, faster than 67.08% of Java online submissions.<br>Memory Usage: 39.9 MB, less than 18.15% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength;</span><br><span class="line">    String result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        maxLength = <span class="number">1</span>;</span><br><span class="line">        result = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            update(s, i, i);</span><br><span class="line">            update(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = i, right = j, curLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == j) curLength = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;=<span class="number">0</span> &amp;&amp; right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) <span class="keyword">break</span>;</span><br><span class="line">            curLength += <span class="number">2</span>;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curLength &gt; maxLength) &#123;</span><br><span class="line">            maxLength = curLength;</span><br><span class="line">            result = s.substring(left + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 56 Merge Intervals &amp; 57 Insert Interval</title>
    <url>/2020/04/10/leetcode-56-57/</url>
    <content><![CDATA[<p>Two similar questions about intervals.</p>
<a id="more"></a>

<h2 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56 Merge Intervals"></a>56 Merge Intervals</h2><p>Given a collection of intervals, merge all overlapping intervals.</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 95.56% of Java online submissions for Merge Intervals.<br>Memory Usage: 42.3 MB, less than 48.55% of Java online submissions for Merge Intervals.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(nlogn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>], end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; end) &#123; <span class="comment">// no overlap</span></span><br><span class="line">                ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt;= end) &#123; <span class="comment">// included</span></span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// overlap</span></span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">        <span class="comment">// convert to array</span></span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Related-Questions"><a href="#Related-Questions" class="headerlink" title="Related Questions"></a>Related Questions</h3><p>Meeting Room</p>
<h2 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57 Insert Interval"></a>57 Insert Interval</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = intervals[i];</span><br><span class="line">            <span class="keyword">int</span> left = cur[<span class="number">0</span>], right = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(left) &amp;&amp; right &lt; map.get(left)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> map.put(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] newInterval = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.firstEntry().getKey(), map.firstEntry().getValue()&#125;;</span><br><span class="line">        res.add(newInterval);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">                newInterval[<span class="number">1</span>] = Math.max(newInterval[<span class="number">1</span>], map.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newInterval = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(i)&#125;;</span><br><span class="line">                res.add(newInterval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
        <tag>Facebook</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 659 - Split Array into Consecutive Subsequences</title>
    <url>/2020/05/10/leetcode-659/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array nums sorted in ascending order, return true if and only if you can split it into 1 or more subsequences such that each subsequence consists of consecutive integers and has length at least 3.</p>
<p><strong>Similar Questions</strong><br>LeetCode 846 - Hand of Straights<br>LeetCode 1296 - Divide Array in Sets of K Consecutive Numbers</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 22 ms, faster than 64.77% of Java online submissions.<br>Memory Usage: 41 MB, less than 94.44% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; chainfreq = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) freqMap.put(i, freqMap.getOrDefault(i,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freqMap.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chainfreq.getOrDefault(i,<span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                chainfreq.put(i, chainfreq.get(i) - <span class="number">1</span>);</span><br><span class="line">                chainfreq.put(i+<span class="number">1</span>, chainfreq.getOrDefault(i+<span class="number">1</span>,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freqMap.getOrDefault(i+<span class="number">1</span>,<span class="number">0</span>) &gt; <span class="number">0</span> &amp;&amp; freqMap.getOrDefault(i+<span class="number">2</span>,<span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                freqMap.put(i+<span class="number">1</span>, freqMap.get(i+<span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">                freqMap.put(i+<span class="number">2</span>, freqMap.get(i+<span class="number">2</span>) - <span class="number">1</span>);</span><br><span class="line">                chainfreq.put(i+<span class="number">3</span>, chainfreq.getOrDefault(i+<span class="number">3</span>,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            freqMap.put(i, freqMap.get(i) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 692 - Top K Frequent Words</title>
    <url>/2020/05/05/leetcode-692/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a non-empty list of words, return the k most frequent elements.</p>
<p>Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 88.29% of Java online submissions.<br>Memory Usage: 39.7 MB, less than 41.07% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (freqMap.get(a) == freqMap.get(b)) <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">                <span class="keyword">return</span> freqMap.get(a) - freqMap.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = freqMap.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            freqMap.put(word, count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String word : freqMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &lt; k) &#123;</span><br><span class="line">                queue.add(word);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freqMap.get(word) &gt;= freqMap.get(queue.peek())) &#123;</span><br><span class="line">                queue.add(word);</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            result.addFirst(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 698 - Partition to K Equal Sum Subsets</title>
    <url>/2020/04/05/leetcode-698/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 93.45% of Java online submissions for Partition to K Equal Sum Subsets.<br>Memory Usage: 37.2 MB, less than 9.30% of Java online submissions for Partition to K Equal Sum Subsets.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), because of recursion.<br>Time Complexity: O(N), O(k^(N−k) * k!), N is the length of nums, and k is as given. </p>
<a id="more"></a>

<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> start = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[start] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// skip (num == target)</span></span><br><span class="line">        <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; nums[start] == target) &#123;</span><br><span class="line">            k--;</span><br><span class="line">            start--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fill in k groups from the end of array</span></span><br><span class="line">        <span class="keyword">return</span> search(<span class="keyword">new</span> <span class="keyword">int</span>[k], nums, start, target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] groups, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[start];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; groups.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (groups[i] + cur &lt;= target) &#123;</span><br><span class="line">                groups[i] += cur;</span><br><span class="line">                <span class="keyword">if</span> (search(groups, nums, start - <span class="number">1</span>, target)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                groups[i] -= cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (groups[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Another-Approach-Dynamic-Programming"><a href="#Another-Approach-Dynamic-Programming" class="headerlink" title="Another Approach: Dynamic Programming"></a>Another Approach: Dynamic Programming</h3><p>To be continued.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 75 - Sort Colors</title>
    <url>/2020/05/10/leetcode-75/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.<br>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.<br>Note: You are not suppose to use the library’s sort function for this problem.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions.<br>Memory Usage: 38.3 MB, less than 5.51% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos0 = <span class="number">0</span>, pos2 = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= pos2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, pos0++, i++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums, pos2--, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 743 - Network Delay Time</title>
    <url>/2020/04/29/leetcode-743/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>There are N network nodes, labelled 1 to N.</p>
<p>Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.</p>
<p>Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 31 ms, faster than 31.17% of Java online submissions.<br>Memory Usage: 43 MB, less than 90.48% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; timeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] time : times)&#123;</span><br><span class="line">            timeMap.putIfAbsent(time[<span class="number">0</span>], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            timeMap.get(time[<span class="number">0</span>]).put(time[<span class="number">1</span>], time[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, K&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.remove();</span><br><span class="line">            <span class="keyword">int</span> curNode = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> curDist = cur[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(visited[curNode]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[curNode] = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (timeMap.containsKey(curNode)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : timeMap.get(curNode).keySet()) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;curDist + timeMap.get(curNode).get(nextNode), nextNode&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = curDist;</span><br><span class="line">            N--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span> ? result : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 752 - Open the Lock</title>
    <url>/2020/04/23/leetcode-752/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’. The wheels can rotate freely and wrap around: for example we can turn ‘9’ to be ‘0’, or ‘0’ to be ‘9’. Each move consists of turning one wheel one slot.</p>
<p>The lock initially starts at ‘0000’, a string representing the state of the 4 wheels.</p>
<p>You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.</p>
<p>Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 60 ms, faster than 84.56% of Java online submissions.<br>Memory Usage: 42.9 MB, less than 84.21% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time Complexity: O(N^2 * A^N + D) where A is the number of digits in our alphabet, N is the number of digits in the lock, and D is the size of deadends. We might visit every lock combination, plus we need to instantiate our set dead. When we visit every lock combination, we spend O(N^2) time enumerating through and constructing each node.<br>Space Complexity: O(A^N + D), for the queue and the set dead.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : deadends) &#123;</span><br><span class="line">            endSet.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="string">"0000"</span>);</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(<span class="string">"0000"</span>);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String s = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (endSet.contains(s)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.equals(target)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span>[] curLock = s.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> tmp = curLock[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt;= <span class="number">1</span>; j+=<span class="number">2</span>) &#123;</span><br><span class="line">                        curLock[i] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + ((tmp - <span class="string">'0'</span>) + <span class="number">10</span> + j) % <span class="number">10</span>);</span><br><span class="line">                        String newS = <span class="keyword">new</span> String(curLock);</span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(newS)) &#123;</span><br><span class="line">                            queue.offer(newS);</span><br><span class="line">                            visited.add(newS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curLock[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 846 - Hand of Straights &amp;&amp; LeetCode 1296 - Divide Array in Sets of K Consecutive Numbers</title>
    <url>/2020/04/22/leetcode-846/</url>
    <content><![CDATA[<h2 id="LeetCode-846-Hand-of-Straights"><a href="#LeetCode-846-Hand-of-Straights" class="headerlink" title="LeetCode 846 - Hand of Straights"></a>LeetCode 846 - Hand of Straights</h2><p><strong>Similar Questions</strong><br>659 - Split Array into Consecutive Subsequences<br>1296 - Divide Array in Sets of K Consecutive Numbers</p>
<p><strong>Description</strong><br>Alice has a hand of cards, given as an array of integers.</p>
<p>Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards.</p>
<p>Return true if and only if she can.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 58 ms, faster than 26.43% of Java online submissions.<br>Memory Usage: 41.6 MB.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNStraightHand</span><span class="params">(<span class="keyword">int</span>[] hand, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hand==<span class="keyword">null</span> || hand.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(hand.length%W != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Convert the given hand into a TreeMap of &lt;Hand,Frequency&gt;</span></span><br><span class="line">        TreeMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : hand)</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);    </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Delete groups of size W from TreeMap</span></span><br><span class="line">        <span class="keyword">while</span>(!map.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curr=map.firstKey();</span><br><span class="line">            updateTreeMap(map,curr);</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(count!=W)</span><br><span class="line">            &#123;</span><br><span class="line">                Map.Entry&lt;Integer,Integer&gt; next=map.higherEntry(curr);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(next==<span class="keyword">null</span> || next.getKey()-curr != <span class="number">1</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    updateTreeMap(map,next.getKey());</span><br><span class="line">                    curr=next.getKey();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTreeMap</span><span class="params">(TreeMap&lt;Integer,Integer&gt; map,<span class="keyword">int</span> curr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        map.put(curr,map.get(curr)-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(map.get(curr)==<span class="number">0</span>) </span><br><span class="line">            map.remove(curr);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-1296-Divide-Array-in-Sets-of-K-Consecutive"><a href="#LeetCode-1296-Divide-Array-in-Sets-of-K-Consecutive" class="headerlink" title="LeetCode 1296 - Divide Array in Sets of K Consecutive"></a>LeetCode 1296 - Divide Array in Sets of K Consecutive</h2><p><strong>Description</strong><br>Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into sets of k consecutive numbers<br>Return True if its possible otherwise return False.</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 135 ms, faster than 49.21% of Java online submissions for Divide Array in Sets of K Consecutive Numbers.<br>Memory Usage: 54 MB, less than 100.00% of Java online submissions for Divide Array in Sets of K Consecutive Numbers.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossibleDivide</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || nums.length % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = freqMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            freqMap.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!freqMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            Integer num = freqMap.firstKey();</span><br><span class="line">            <span class="keyword">while</span> (count++ &lt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!freqMap.containsKey(num)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                updateMap(freqMap, num++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateMap</span><span class="params">(TreeMap&lt;Integer, Integer&gt; freqMap, Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldFreq = freqMap.get(num);</span><br><span class="line">        <span class="keyword">if</span> (oldFreq == <span class="number">1</span>) freqMap.remove(num);</span><br><span class="line">        <span class="keyword">else</span> freqMap.put(num, oldFreq - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 862 - Shortest Subarray with Sum at Least K</title>
    <url>/2020/04/12/leetcode-862/</url>
    <content><![CDATA[<h2 id="Sliding-window"><a href="#Sliding-window" class="headerlink" title="Sliding window"></a>Sliding window</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 17 ms, faster than 94.20% of Java online submissions for Shortest Subarray with Sum at Least K .<br>Memory Usage:50 MB, less than 100.00% of Java online submissions for Shortest Subarray with Sum at Least K .</p>
<a id="more"></a>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N).<br>Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sums.length; i++) &#123;</span><br><span class="line">            sums[i] = A[i - <span class="number">1</span>] + sums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ascending linkedlist</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() &gt; <span class="number">0</span> &amp;&amp; sums[i] &lt;= sums[list.peekLast()]) &#123;</span><br><span class="line">                list.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (list.size() &gt; <span class="number">0</span> &amp;&amp; sums[i] - sums[list.peekFirst()] &gt;= K) &#123;</span><br><span class="line">                result = Math.min(result, i - list.removeFirst());</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? -<span class="number">1</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
        <tag>Sliding Window</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 81 - Search in Rotated Sorted Array II (Binary Search)</title>
    <url>/2020/04/13/leetcode-81/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Search in Rotated Sorted Array II.<br>Memory Usage: 39.4 MB, less than 54.93% of Java online submissions for Search in Rotated Sorted Array II.</p>
<a id="more"></a>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1).<br>Time Complexity: O(logN).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// if left part is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[start]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// if right part is sorted</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[start]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt; nums[start]) &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 994 - Rotting Oranges</title>
    <url>/2020/05/02/leetcode-994/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>In a given grid, each cell can have one of three values:<br>    the value 0 representing an empty cell;<br>    the value 1 representing a fresh orange;<br>    the value 2 representing a rotten orange.</p>
<p>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>
<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 97.55% of Java online submissions.<br>Memory Usage: 39 MB, less than 81.25% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;Integer&gt; rottens = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> freshNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) freshNum++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = i * <span class="number">100</span> + j;</span><br><span class="line">                    rottens.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> timer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] direction = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!rottens.isEmpty()) &#123;</span><br><span class="line">            timer++;</span><br><span class="line">            <span class="keyword">int</span> count = rottens.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = rottens.poll();</span><br><span class="line">                <span class="keyword">int</span> row = num / <span class="number">100</span>, col = num % <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmpRow = row + direction[i][<span class="number">0</span>], tmpCol = col + direction[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (tmpRow &lt; <span class="number">0</span> || tmpCol &lt; <span class="number">0</span> || tmpRow &gt;= m || tmpCol &gt;= n)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[tmpRow][tmpCol] == <span class="number">1</span>) &#123;</span><br><span class="line">                        freshNum--;</span><br><span class="line">                        grid[tmpRow][tmpCol] = <span class="number">2</span>;</span><br><span class="line">                        rottens.add(tmpRow * <span class="number">100</span> + tmpCol);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (freshNum == <span class="number">0</span>) <span class="keyword">return</span> timer == <span class="number">0</span> ? <span class="number">0</span> : timer - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 939 - Minimum Area Rectangle</title>
    <url>/2020/05/10/leetcode-939/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.</p>
<p>If there isn’t any rectangle, return 0.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 196 ms, faster than 69.12% of Java online submissions.<br>Memory Usage: 58.6 MB, less than 15.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAreaRect</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, TreeSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</span><br><span class="line">            TreeSet&lt;Integer&gt; set = map.getOrDefault(point[<span class="number">0</span>], <span class="keyword">new</span> TreeSet&lt;&gt;());</span><br><span class="line">            set.add(point[<span class="number">1</span>]);</span><br><span class="line">            map.put(point[<span class="number">0</span>], set);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (Integer x : map.keySet()) &#123;</span><br><span class="line">            Integer curX = x;</span><br><span class="line">            Integer nextX = map.higherKey(curX);</span><br><span class="line">            <span class="keyword">int</span> curArea = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (nextX != <span class="keyword">null</span> &amp;&amp; curArea == Integer.MAX_VALUE) &#123;</span><br><span class="line">                TreeSet&lt;Integer&gt; curYs = map.get(curX);</span><br><span class="line">                TreeSet&lt;Integer&gt; nextYs = map.get(nextX);</span><br><span class="line">                <span class="keyword">for</span> (Integer curY1 : curYs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!nextYs.contains(curY1)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Integer curY2 = curYs.higher(curY1); curY2 != <span class="keyword">null</span>; curY2 = curYs.higher(curY2)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (curArea != Integer.MAX_VALUE) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span> (nextYs.contains(curY2)) &#123;</span><br><span class="line">                            curArea = (nextX - curX) * (curY2 - curY1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nextX = map.higherKey(nextX);</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.min(result, curArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return result == Integer.MAX_VALUE ? 0 : result;</span></span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; rows = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point: points) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            rows.computeIfAbsent(x, z-&gt; <span class="keyword">new</span> ArrayList()).add(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        Map&lt;Integer, Integer&gt; lastx = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: rows.keySet()) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = rows.get(x);</span><br><span class="line">            Collections.sort(row);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.size(); ++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; row.size(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> y1 = row.get(i), y2 = row.get(j);</span><br><span class="line">                    <span class="keyword">int</span> code = <span class="number">40001</span> * y1 + y2;</span><br><span class="line">                    <span class="keyword">if</span> (lastx.containsKey(code))</span><br><span class="line">                        ans = Math.min(ans, (x - lastx.get(code)) * (y2-y1));</span><br><span class="line">                    lastx.put(code, x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Deploy Vue Project to Nginx on Ubuntu 18.04</title>
    <url>/2020/03/16/vue-ubuntu/</url>
    <content><![CDATA[<p>Build and deploy vue.js project to Ubuntu 18.04 (Cloud Instance on Vultr).</p>
<a id="more"></a>

<h2 id="Nginx-on-Ubuntu-18-04"><a href="#Nginx-on-Ubuntu-18-04" class="headerlink" title="Nginx on Ubuntu 18.04"></a>Nginx on Ubuntu 18.04</h2><ol>
<li><p>Install Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>Check status</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;your_server_ip</span><br></pre></td></tr></table></figure>

<p>You should see the default Nginx landing page:</p>
<p><img src="https://assets.digitalocean.com/articles/nginx_1604/default_page.png" alt="Nginx default page"></p>
<p>This page is included with Nginx to show you that the server is running correctly.</p>
</li>
<li><p>mkdir for vue project</p>
<p>mkdir in the default directory of nginx to avoid potential “permission denied” problem.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www&#x2F;</span><br><span class="line">mkdir vue</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Build-and-Deploy-VueJS-Project"><a href="#Build-and-Deploy-VueJS-Project" class="headerlink" title="Build and Deploy VueJS Project"></a>Build and Deploy VueJS Project</h2><ol>
<li><p>Build on local machine (or server)</p>
<p>cd into root directory of your vue project</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>“dist” directory should be generated if successfully.</p>
</li>
<li><p>Push “dist” to server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r &#123;your_local_root_dir&#125;&#x2F;dist root@your_server_ip:&#123;&#x2F;var&#x2F;www&#x2F;vue&#x2F;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Edit configuration file on server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</span><br></pre></td></tr></table></figure>

<p>change root to “/var/www/vue/dist”</p>
<p>You can also create new configuration file.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;vue_project</span><br><span class="line">sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;vue_project &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;vue_project</span><br><span class="line">sudo vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;vue_project</span><br></pre></td></tr></table></figure>
</li>
<li><p>Test and restart nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>

<p>visit <a href="http://your_server_ip" target="_blank" rel="noopener">http://your_server_ip</a> again for confirmation.</p>
<p>​</p>
</li>
</ol>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li>“No firewall” set on vultr, or adjust it with “ufw”.</li>
<li>Set enough RAM for the server, especially if you want to build the project on server instead of local machine.</li>
</ol>
<h3 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h3><p>Design and CI</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[<a href="https://www.cyberciti.biz/faq/install-and-configure-nginx-on-ubuntu-linux-18-04-lts/]" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/install-and-configure-nginx-on-ubuntu-linux-18-04-lts/]</a>(Install and Configure Nginx on Ubuntu Linux 18.04 LTS)</p>
<p>[<a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04]" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04]</a>(How To Install Nginx on Ubuntu 18.04)</p>
<p>[<a href="https://thewebtier.com/web/setup-vuejs-app-on-ubuntu-server/]" target="_blank" rel="noopener">https://thewebtier.com/web/setup-vuejs-app-on-ubuntu-server/]</a>(Setup VueJS app on Ubuntu Server)</p>
<p>[<a href="https://medium.com/@thucnc/deploy-a-vuejs-web-app-with-nginx-on-ubuntu-18-04-f93860219030]" target="_blank" rel="noopener">https://medium.com/@thucnc/deploy-a-vuejs-web-app-with-nginx-on-ubuntu-18-04-f93860219030]</a>(Deploy a VueJS web app with nginx on Ubuntu 18.04)</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Reading</title>
    <url>/2020/05/11/reading/</url>
    <content><![CDATA[<h2 id="In-Progress"><a href="#In-Progress" class="headerlink" title="In Progress"></a>In Progress</h2><p>《历史深处的忧虑》<br>《许三观卖血记》</p>
<a id="more"></a>

<h2 id="Marked"><a href="#Marked" class="headerlink" title="Marked"></a>Marked</h2><p>《人类简史》<br>《树上的男爵》<br>《万历十五年》<br>《夏目友人帐》 村井贞之<br>《清醒思考的艺术》 【德】罗尔夫·多贝里</p>
<h2 id="Completed"><a href="#Completed" class="headerlink" title="Completed"></a>Completed</h2><p>《我们仨》杨绛 - 虽然是一个人怀念我们仨，看到的也大多是快乐<br>《边城》沈从文<br>《Rich Daddy, Poor Daddy》 [US]Robert Kiyosaki, Sharon Lechter<br>《玛格丽特小镇》<br>《岛上书店》 加·泽文<br>《你今天真好看》 【美】利兹·克里莫<br>《解忧杂货店》 东野圭吾<br>《24个比利》 丹尼尔·凯斯<br>《三体》 刘慈欣<br>《黄金时代》 王小波<br>《无声告白》<br>《阿弥陀佛么么哒》 大冰<br>《目送》 龙应台<br>《福尔摩斯探案全集》 Conan Doyle A.</p>
<h2 id="Aborted"><a href="#Aborted" class="headerlink" title="Aborted"></a>Aborted</h2><p>《目标中国.华盛顿的“屠龙”战略》【美】威廉·恩道尔</p>
<p><strong>To Be Continued…</strong></p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1 - Two Sum (Array &amp; HashMap)</title>
    <url>/2020/03/17/leetcode-TwoSum/</url>
    <content><![CDATA[<h3 id="Approach-1-Array"><a href="#Approach-1-Array" class="headerlink" title="Approach 1: Array"></a>Approach 1: Array</h3><p>Space Complexity: O(1), Time Complexity: O(N^2).</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No valid result"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Approach-2-HashMap"><a href="#Approach-2-HashMap" class="headerlink" title="Approach 2: HashMap"></a>Approach 2: HashMap</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(diff)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(diff), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No valid result."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Operations</title>
    <url>/2020/04/05/hexo-basic/</url>
    <content><![CDATA[<h3 id="Basic-workflow-基本操作"><a href="#Basic-workflow-基本操作" class="headerlink" title="Basic workflow 基本操作"></a>Basic workflow 基本操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<h3 id="New-page-post-draft-新建内容"><a href="#New-page-post-draft-新建内容" class="headerlink" title="New page/post/draft 新建内容"></a>New page/post/draft 新建内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page page-name</span><br><span class="line">hexo new draft draft-name</span><br><span class="line">hexo new post post-name</span><br><span class="line">hexo publish draft draft-name.md</span><br></pre></td></tr></table></figure>



<h3 id="Show-abstract-on-Home-page-首页显示摘要"><a href="#Show-abstract-on-Home-page-首页显示摘要" class="headerlink" title="Show abstract on Home page 首页显示摘要"></a>Show abstract on Home page 首页显示摘要</h3><p>use <a id="more"></a> to separate abstract and the context.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Basic Configuration For A New Ubuntu Server</span><br><span class="line">date: 2020-04-03 13:09:10</span><br><span class="line">---</span><br><span class="line">This is abstract.</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">More details.</span><br></pre></td></tr></table></figure>



<h3 id="Sticky-posts-置顶"><a href="#Sticky-posts-置顶" class="headerlink" title="Sticky posts 置顶"></a>Sticky posts 置顶</h3><ol>
<li>Install related repositories</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Add <code>top: true</code> to <code>Front-matter</code>. </p>
<p>Example:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: post</span><br><span class="line">title: 懒人做法实践之路</span><br><span class="line">date: 2020-03-17 17:04:34</span><br><span class="line">tags: food</span><br><span class="line">categories: life</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>



<p>Optional:</p>
<ol start="3">
<li>Show “Sticky”</li>
</ol>
<p>Open <code>post.swig</code> in <code>/blog/themes/next/layout/_macro</code>, add the following code below <code>&lt;div class=&quot;post-meta&quot;&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;Sticky&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>Reference: </p>
<p>Hexo博客彻底解决置顶问题 <a href="http://wangwlj.com/2018/01/09/blog_pin_post/" target="_blank" rel="noopener">http://wangwlj.com/2018/01/09/blog_pin_post/</a></p>
<h3 id="Loacal-Search添加搜索功能"><a href="#Loacal-Search添加搜索功能" class="headerlink" title="Loacal Search添加搜索功能"></a>Loacal Search添加搜索功能</h3><ol>
<li>Install</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Global configuration in  <code>blog/_config.yml</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Next configuration in <code>blog/themes/next/_config.yml</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<p>Redeploy.</p>
<p>Reference: <a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</a></p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - Backtracking</title>
    <url>/2019/10/14/leetcode-backtracking/</url>
    <content><![CDATA[<p><strong>Problem List</strong><br>46.Permutations<br>47.Permutations II<br>39.Combination Sum<br>40.Combination Sum II</p>
<a id="more"></a>

<h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        helper(res, nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; list, <span class="keyword">int</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                helper(res, nums, list, visited.clone());</span><br><span class="line">                visited[i] = <span class="number">0</span>;</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h2><p><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        helper(res, nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; list, <span class="keyword">int</span>[] visited)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; visited[i-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>  (visited[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            helper(res, nums, list, visited.clone());</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h2><p><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) 	&#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        helper(candidates, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            helper(candidates, target - candidates[i], i, list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h2><p><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-ii/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; start &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                helper(res, list, candidates, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 300 - Longest Increasing Subsequence</title>
    <url>/2020/05/11/leetcode-300/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Related question: Leetcode 354 - Russian Doll Envelopes</p>
<a id="more"></a>

<h2 id="Solution-one-Dynamic-Programming"><a href="#Solution-one-Dynamic-Programming" class="headerlink" title="Solution one: Dynamic Programming"></a>Solution one: Dynamic Programming</h2><p>dp[i] - length of LIS until index i</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 12 ms, faster than 37.91% of Java online submissions for Longest Increasing Subsequence.<br>Memory Usage: 37.5 MB, less than 34.00% of Java online submissions for Longest Increasing Subsequence.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(dp[i], result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-Dynamic-Programming-with-Binary-Search"><a href="#Solution-Two-Dynamic-Programming-with-Binary-Search" class="headerlink" title="Solution Two: Dynamic Programming with Binary Search"></a>Solution Two: Dynamic Programming with Binary Search</h2><p>dp[i] - last number of valid chain whose length is (i + 1)<br>Reference: <a href="https://segmentfault.com/a/1190000003819886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003819886</a></p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Longest Increasing Subsequence.<br>Memory Usage: 37.5 MB, less than 34.00% of Java online submissions for Longest Increasing Subsequence.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(NlogN).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp with binary search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// if not found, return (- toIndex - 1)</span></span><br><span class="line">            <span class="keyword">int</span> i = Arrays.binarySearch(dp, <span class="number">0</span>, len, num);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = - (i + <span class="number">1</span>);</span><br><span class="line">            dp[i] = num;</span><br><span class="line">            <span class="keyword">if</span> (i == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 23 - Merge k Sorted Lists</title>
    <url>/2020/05/11/leetcode-23/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<a id="more"></a>

<h2 id="Solution-One-PriorityQueue"><a href="#Solution-One-PriorityQueue" class="headerlink" title="Solution One: PriorityQueue"></a>Solution One: PriorityQueue</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 46.82% of Java online submissions for Merge k Sorted Lists.<br>Memory Usage: 41.4 MB, less than 40.44% of Java online submissions for Merge k Sorted Lists.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(NlogK).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.val - o2.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tmp = dummy;</span><br><span class="line">        <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(head);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            tmp.next = queue.poll();</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-Merge-Sort"><a href="#Solution-Two-Merge-Sort" class="headerlink" title="Solution Two: Merge Sort"></a>Solution Two: Merge Sort</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 763 - Partition Labels</title>
    <url>/2020/05/13/leetcode-763/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p>
<h2 id="Solution-One-Merge-Intervals"><a href="#Solution-One-Merge-Intervals" class="headerlink" title="Solution One - Merge Intervals"></a>Solution One - Merge Intervals</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// get intervals</span></span><br><span class="line">        <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(start, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(end, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = S.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (start[cur - <span class="string">'a'</span>] == -<span class="number">1</span>) start[cur - <span class="string">'a'</span>] = i;</span><br><span class="line">            <span class="keyword">else</span> end[cur - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">                map.put(start[i], end[i] == -<span class="number">1</span> ? start[i] : end[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// merge intervals</span></span><br><span class="line">        <span class="keyword">while</span> (!map.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = map.firstKey();</span><br><span class="line">            <span class="keyword">int</span> right = map.get(left);</span><br><span class="line">            map.remove(left);</span><br><span class="line">            Integer mid = map.lowerKey(right);</span><br><span class="line">            <span class="keyword">while</span> (mid != <span class="keyword">null</span>) &#123;</span><br><span class="line">                right = Math.max(right, map.get(mid));</span><br><span class="line">                map.remove(mid);</span><br><span class="line">                mid = map.lowerKey(right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-Greedy-Good"><a href="#Solution-Two-Greedy-Good" class="headerlink" title="Solution Two - Greedy (Good)"></a>Solution Two - Greedy (Good)</h2><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i)</span><br><span class="line">            last[S.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>, anchor = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i) &#123;</span><br><span class="line">            j = Math.max(j, last[S.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                ans.add(i - anchor + <span class="number">1</span>);</span><br><span class="line">                anchor = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1239 - Maximum Length of a Concatenated String with Unique Characters</title>
    <url>/2020/05/18/leetcode-1239/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of strings arr. String s is a concatenation of a sub-sequence of arr which have unique characters.</p>
<p>Return the maximum possible length of s.</p>
<h2 id="Solution-One-Backtracking"><a href="#Solution-One-Backtracking" class="headerlink" title="Solution One: Backtracking"></a>Solution One: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 78 ms, faster than 20.33% of Java online submissions.<br>Memory Usage: 51.3 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n^3), Time Complexity: O(n^2 * string length).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(List&lt;String&gt; arr)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; path = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Set&lt;Character&gt;&gt; arrList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s: arr) &#123;</span><br><span class="line">            Set&lt;Character&gt; set = isUniqueChars(s);</span><br><span class="line">            <span class="keyword">if</span> (set != <span class="keyword">null</span>) arrList.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, arrList, <span class="keyword">new</span> HashSet&lt;Character&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, List&lt;Set&lt;Character&gt;&gt; arrList, Set&lt;Character&gt; path, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        result = Math.max(result, length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; arrList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// skip or not</span></span><br><span class="line">            Set&lt;Character&gt; set = arrList.get(i);</span><br><span class="line">            <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : set) &#123;</span><br><span class="line">                <span class="keyword">if</span> (path.contains(c)) valid = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                path.addAll(set);</span><br><span class="line">                dfs(i + <span class="number">1</span>, arrList, path, length + set.size());</span><br><span class="line">                path.removeAll(set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;Character&gt; <span class="title">isUniqueChars</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 140 - Word Break II</title>
    <url>/2020/05/22/leetcode-140/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>Note:<br>1.The same word in the dictionary may be reused multiple times in the segmentation.<br>2.You may assume the dictionary does not contain duplicate words.</p>
<a id="more"></a>
<h2 id="Solution-Recursion-with-memorization"><a href="#Solution-Recursion-with-memorization" class="headerlink" title="Solution: Recursion with memorization"></a>Solution: Recursion with memorization</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n^3). The depth of the recursion tree can go up to n and each activation record can contains a string list of size n.<br>Time Complexity: O(n^3). Size of recursion tree can go up to n^2. The creation of list takes n time.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word: wordDict) set.add(word);</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, set, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(start)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(start);</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            res.add(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end))) &#123;</span><br><span class="line">                List&lt;String&gt; list = word_Break(s, wordDict, end);</span><br><span class="line">                <span class="keyword">for</span> (String l : list) &#123;</span><br><span class="line">                    res.add(s.substring(start, end) + (l.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(start, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>Reduce runtime complexity in the tradeoff of saving middle result in a map.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 212 - Word Search II</title>
    <url>/2020/05/09/leetcode-212/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<h2 id="Solution-One-Backtracking"><a href="#Solution-One-Backtracking" class="headerlink" title="Solution One: Backtracking"></a>Solution One: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 646 ms, faster than 11.27% of Java online submissions.<br>Memory Usage: 41.8 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(rowNum * colNum), Time Complexity: O(rowNum * colNum).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowNum, colNum;</span><br><span class="line">    Set&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rowNum = board.length;</span><br><span class="line">        colNum = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// record position of each character</span></span><br><span class="line">        Map&lt;Character, List&lt;<span class="keyword">int</span>[]&gt;&gt; posMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">                List&lt;<span class="keyword">int</span>[]&gt; list = posMap.getOrDefault(board[i][j], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                posMap.put(board[i][j], list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find word</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] pos: posMap.getOrDefault(word.charAt(<span class="number">0</span>), <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;())) &#123;</span><br><span class="line">                search(board, word, <span class="number">0</span>, pos[<span class="number">0</span>], pos[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ans.addAll(result);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> start, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length()) &#123;</span><br><span class="line">            result.add(word);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= rowNum || col &gt;= colNum) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span> old = board[row][col];</span><br><span class="line">        <span class="keyword">if</span> (old != word.charAt(start)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[row][col] = <span class="string">'1'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="keyword">if</span>(search(board, word, start + <span class="number">1</span>, row + direction[<span class="number">0</span>], col + direction[<span class="number">1</span>])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[row][col] = old;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Backtracking-with-Trie"><a href="#Solution-Two-Backtracking-with-Trie" class="headerlink" title="Solution Two: Backtracking with Trie"></a>Solution Two: Backtracking with Trie</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 25 - Reverse Nodes in k-Group</title>
    <url>/2020/05/21/leetcode-25/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>Example:</p>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5<br>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>Note:</p>
<ol>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ol>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 26.41% of Java online submissions.<br>Memory Usage: 42.8 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode lastTail = dummy, curTail = dummy;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count++ &lt; k) &#123;</span><br><span class="line">            curTail = curTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode curHead = lastTail.next;</span><br><span class="line">            reverse(lastTail, curHead, k);</span><br><span class="line">            lastTail = curHead;</span><br><span class="line">            curTail = lastTail;</span><br><span class="line">            </span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (curTail != <span class="keyword">null</span> &amp;&amp; count++ &lt; k) &#123;</span><br><span class="line">                curTail = curTail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode lastTail, ListNode head, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head.next, pre = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; count++ &lt; length) &#123;</span><br><span class="line">            ListNode curHead = lastTail.next;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            lastTail.next = cur;</span><br><span class="line">            cur.next = curHead;</span><br><span class="line">            pre.next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 42 - Trapping Rain Water</title>
    <url>/2020/05/14/leetcode-42/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 91.88% of Java online submissions.<br>Memory Usage: 39 MB, less than 37.67% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] max1 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> max = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            max = Math.max(max, height[i]);</span><br><span class="line">            max1[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        max = height[length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            max = Math.max(max, height[i]);</span><br><span class="line">            result += (Math.min(max1[i], max) - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 809 - Expressive Words</title>
    <url>/2020/05/21/leetcode-809/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Sometimes people repeat letters to represent extra feeling, such as “hello” -&gt; “heeellooo”, “hi” -&gt; “hiiii”.  In these strings like “heeellooo”, we have groups of adjacent letters that are all the same:  “h”, “eee”, “ll”, “ooo”.</p>
<p>For some given string S, a query word is stretchy if it can be made to be equal to S by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is 3 or more.</p>
<p>For example, starting with “hello”, we could do an extension on the group “o” to get “hellooo”, but we cannot get “helloo” since the group “oo” has size less than 3.  Also, we could do another extension like “ll” -&gt; “lllll” to get “helllllooo”.  If S = “helllllooo”, then the query word “hello” would be stretchy because of these two extension operations: query = “hello” -&gt; “hellooo” -&gt; “helllllooo” = S.</p>
<p>Given a list of query words, return the number of words that are stretchy. </p>
<h2 id="Solution-Run-Length-Encoding"><a href="#Solution-Run-Length-Encoding" class="headerlink" title="Solution: Run Length Encoding"></a>Solution: Run Length Encoding</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 26.37% of Java online submissions.<br>Memory Usage: 39.8 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N * Length).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line">        String key;</span><br><span class="line">        List&lt;Integer&gt; counts;</span><br><span class="line">        Word(String w) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            counts = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] ca = w.toCharArray();</span><br><span class="line">            <span class="keyword">int</span> N = ca.length;</span><br><span class="line">            <span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == N-<span class="number">1</span> || ca[i] != ca[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                    sb.append(ca[i]);</span><br><span class="line">                    counts.add(i - prev);</span><br><span class="line">                    prev = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expressiveWords</span><span class="params">(String S, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Word target = <span class="keyword">new</span> Word(S);</span><br><span class="line">        <span class="keyword">for</span> (String w: words) &#123;</span><br><span class="line">            Word word = <span class="keyword">new</span> Word(w);</span><br><span class="line">            <span class="keyword">if</span> (!word.key.equals(target.key)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">boolean</span> matched = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.counts.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = word.counts.get(i);</span><br><span class="line">                <span class="keyword">int</span> tar = target.counts.get(i);</span><br><span class="line">                <span class="keyword">if</span> ((tar &lt; <span class="number">3</span> &amp;&amp; cur != tar) || tar &lt; cur) &#123;</span><br><span class="line">                    matched = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matched) result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 99 - Recover Binary Search Tree</title>
    <url>/2020/05/10/leetcode-99/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<h2 id="Solution-One-Iterative-Inorder-Traversal"><a href="#Solution-One-Iterative-Inorder-Traversal" class="headerlink" title="Solution One: Iterative Inorder Traversal"></a>Solution One: Iterative Inorder Traversal</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 37.60% of Java online submissions.<br>Memory Usage: 39.8 MB, less than 80.77% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time complexity : O(1) in the best case, and O(N) in the worst case when one of the swapped nodes is a rightmost leaf.<br>Space complexity : up to O(H) to keep the stack where H is a tree height. </p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode tmp = root;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.addLast(tmp);</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node1 = <span class="keyword">null</span>, node2 = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = stack.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; prev != <span class="keyword">null</span> &amp;&amp; prev.val &gt; cur.val) </span><br><span class="line">                node1 = prev;</span><br><span class="line">            <span class="keyword">if</span> (node1 != <span class="keyword">null</span> &amp;&amp; cur.val &lt; node1.val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node2 == <span class="keyword">null</span> || cur.val &lt; node2.val) node2 = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.addLast(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// swap</span></span><br><span class="line">        <span class="keyword">int</span> num = node1.val;</span><br><span class="line">        node1.val = node2.val;</span><br><span class="line">        node2.val = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Morris-Inorder-Traversal"><a href="#Solution-Two-Morris-Inorder-Traversal" class="headerlink" title="Solution Two: Morris Inorder Traversal"></a>Solution Two: Morris Inorder Traversal</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 946 - Validate Stack Sequences</title>
    <url>/2020/05/13/leetcode-946/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 74.67% of Java online submissions.<br>Memory Usage: 39.6 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushed.length == <span class="number">0</span> &amp;&amp; popped.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pushed.length != popped.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(pushed[i++]);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; popped.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek().equals(popped[j])) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == pushed.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                stack.push(pushed[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty() &amp;&amp; i == pushed.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1044 - Longest Duplicate Substring</title>
    <url>/2020/05/20/leetcode-1044/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.  (The occurrences may overlap.)</p>
<p>Return any duplicated substring that has the longest possible length.  (If S does not have a duplicated substring, the answer is “”.)</p>
<h2 id="Solution-Binary-Search-Rabin-Karp"><a href="#Solution-Binary-Search-Rabin-Karp" class="headerlink" title="Solution: Binary Search + Rabin-Karp"></a>Solution: Binary Search + Rabin-Karp</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Time Limit Exceeded</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N).<br>Time Complexity: O(N * logN), O(logN) for the binary search and O(N) for Rabin-Karp algorithm.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestDupSubstring</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) <span class="keyword">return</span> S;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = S.length() - <span class="number">1</span>;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            String dup = checkDup(S, mid);</span><br><span class="line">            <span class="keyword">if</span> (dup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = dup;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">checkDup</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index, count = S.length() - length + <span class="number">1</span>;</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;(count);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">            sb.append(S.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        visited.add(sb.toString());</span><br><span class="line">        <span class="keyword">while</span> (index &lt; S.length()) &#123;</span><br><span class="line">            sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">            sb.append(S.charAt(index++));</span><br><span class="line">            String cur = sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(cur)) <span class="keyword">return</span> cur;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 116 &amp; 117 - Populating Next Right Pointers in Each Node</title>
    <url>/2020/05/21/leetcode-116-117/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Follow up:</p>
<p>You may only use constant extra space.<br>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</p>
<h2 id="Solution-One-BFS"><a href="#Solution-One-BFS" class="headerlink" title="Solution One: BFS"></a>Solution One: BFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        ArrayDeque&lt;Node&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = q.size();</span><br><span class="line">            Node pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) q.addLast(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) q.addLast(cur.left);</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Using-previously-established-next-pointers"><a href="#Solution-Two-Using-previously-established-next-pointers" class="headerlink" title="Solution Two: Using previously established next pointers"></a>Solution Two: Using previously established next pointers</h2><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(N).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node leftmost, prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        leftmost = root;</span><br><span class="line">        <span class="keyword">while</span> (leftmost != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node cur = leftmost;</span><br><span class="line">            leftmost = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNode(cur.left);</span><br><span class="line">                checkNode(cur.right);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftmost == <span class="keyword">null</span>) &#123; <span class="comment">// prev != null</span></span><br><span class="line">                leftmost = node;</span><br><span class="line">                prev = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = node;</span><br><span class="line">                prev = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>BST</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 124 - Binary Tree Maximum Path Sum</title>
    <url>/2020/05/22/leetcode-124/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a non-empty binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p>
<h2 id="Solution-DFS"><a href="#Solution-DFS" class="headerlink" title="Solution: DFS"></a>Solution: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 26.76% of Java online submissions for Binary Tree Maximum Path Sum.<br>Memory Usage: 41.4 MB, less than 8.33% of Java online submissions for Binary Tree Maximum Path Sum.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        maxSum(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// case 1: child chain</span></span><br><span class="line">        <span class="keyword">int</span> left = maxSum(root.left), right = maxSum(root.right);</span><br><span class="line">        <span class="keyword">int</span> maxChild = Math.max(left, right);</span><br><span class="line">        result = Math.max(result, maxChild);</span><br><span class="line">        <span class="comment">// case 2: two children connected to root</span></span><br><span class="line">        <span class="keyword">if</span> (left != Integer.MIN_VALUE &amp;&amp; right != Integer.MIN_VALUE) &#123;</span><br><span class="line">            result = Math.max(result, left + right + root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 3: one child connected to root / only root</span></span><br><span class="line">        <span class="keyword">int</span> cur = root.val;</span><br><span class="line">        <span class="keyword">if</span> (maxChild &gt; <span class="number">0</span>) cur += maxChild;</span><br><span class="line">        result = Math.max(result, cur);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1277 - Count Square Submatrices with All Ones</title>
    <url>/2020/05/25/leetcode-1277/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.</p>
<h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 97.09% of Java online submissions for Count Square Submatrices with All Ones.<br>Memory Usage: 48.5 MB, less than 100.00% of Java online submissions for Count Square Submatrices with All Ones.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(m*n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                matrix[i][j] = Math.min(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(matrix[i-<span class="number">1</span>][j], matrix[i][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                ans += matrix[i][j] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 134 - Gas Station</title>
    <url>/2020/05/23/leetcode-134/</url>
    <content><![CDATA[<p><strong>Description</strong><br>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<h2 id="Solution-One-Two-pass"><a href="#Solution-One-Two-pass" class="headerlink" title="Solution One: Two pass"></a>Solution One: Two pass</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 54 ms, faster than 16.35% of Java online submissions.<br>Memory Usage: 39.6 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(N^2)</span></span><br><span class="line">        <span class="keyword">int</span> num = gas.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            cost[i] = gas[i] - cost[i];</span><br><span class="line">            sum += cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cost[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">                sum += cost[(i + j) % num] ;</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    found = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-One-One-pass"><a href="#Solution-One-One-pass" class="headerlink" title="Solution One: One pass"></a>Solution One: One pass</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions.<br>Memory Usage: 39.9 MB.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = gas.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            cost[i] = gas[i] - cost[i];</span><br><span class="line">            sum += cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            cur += cost[i];</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = i + <span class="number">1</span>;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1376 - Time Needed to Inform All Employees</title>
    <url>/2020/05/25/leetcode-1376/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company has is the one with headID.</p>
<p>Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also it’s guaranteed that the subordination relationships have a tree structure.</p>
<p>The head of the company wants to inform all the employees of the company of an urgent piece of news. He will inform his direct subordinates and they will inform their subordinates and so on until all employees know about the urgent news.</p>
<p>The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e After informTime[i] minutes, all his direct subordinates can start spreading the news).</p>
<p>Return the number of minutes needed to inform all the employees about the urgent news.</p>
<h2 id="Solution-DFS-up-to-bottom"><a href="#Solution-DFS-up-to-bottom" class="headerlink" title="Solution: DFS, up to bottom"></a>Solution: DFS, up to bottom</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 112 ms, faster than 55.22% of Java online submissions for Time Needed to Inform All Employees.<br>Memory Usage: 58 MB, less than 100.00% of Java online submissions for Time Needed to Inform All Employees.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N + H), for subMap and recursion.<br>Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numOfMinutes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> headID, <span class="keyword">int</span>[] manager, <span class="keyword">int</span>[] informTime)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; subMap = <span class="keyword">new</span> HashMap&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; subList = subMap.getOrDefault(manager[i], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            subList.add(i);</span><br><span class="line">            subMap.put(manager[i], subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> informSub(headID, subMap, informTime);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">informSub</span><span class="params">(<span class="keyword">int</span> i, Map&lt;Integer, List&lt;Integer&gt;&gt; subMap, <span class="keyword">int</span>[] informTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sub : subMap.getOrDefault(i, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">            ans = Math.max(ans, informSub(sub, subMap, informTime));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + informTime[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 139 - Word Break</title>
    <url>/2020/05/29/leetcode-139/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<h2 id="Solution-One-Recursive-with-memorization"><a href="#Solution-One-Recursive-with-memorization" class="headerlink" title="Solution One: Recursive with memorization"></a>Solution One: Recursive with memorization</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 81.64% of Java online submissions for Word Break.<br>Memory Usage: 39.6 MB, less than 5.08% of Java online submissions for Word Break.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Boolean[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> Boolean[s.length()];</span><br><span class="line">        <span class="keyword">return</span> splitWord(s, <span class="number">0</span>, <span class="keyword">new</span> HashSet&lt;&gt;(wordDict));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">splitWord</span><span class="params">(String s, <span class="keyword">int</span> start, Set&lt;String&gt; wordSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[start] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            String cur = s.substring(start, i);</span><br><span class="line">            <span class="keyword">if</span> (wordSet.contains(cur) &amp;&amp; splitWord(s, i, wordSet)) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[start] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-BFS"><a href="#Solution-Two-BFS" class="headerlink" title="Solution Two: BFS"></a>Solution Two: BFS</h2><h2 id="Solution-Three-Dynamic-Programming"><a href="#Solution-Three-Dynamic-Programming" class="headerlink" title="Solution Three: Dynamic Programming"></a>Solution Three: Dynamic Programming</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 17 - Letter Combinations of a Phone Number</title>
    <url>/2020/05/30/leetcode-17/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<h2 id="Solution-Backtracking"><a href="#Solution-Backtracking" class="headerlink" title="Solution: Backtracking"></a>Solution: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Letter Combinations of a Phone Number.<br>Memory Usage: 38.2 MB, less than 6.16% of Java online submissions for Letter Combinations of a Phone Number.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(3^N * 4^M), Time Complexity: O(3^N * 4^M).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        build(digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(String digits, <span class="keyword">int</span> start, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == digits.length()) &#123;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curNum = digits.charAt(start) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">char</span> firstC = (<span class="keyword">char</span>)(<span class="string">'a'</span> + (curNum - <span class="number">2</span>) * <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (curNum == <span class="number">7</span>) &#123;</span><br><span class="line">            count = <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curNum == <span class="number">8</span>) &#123;</span><br><span class="line">            firstC = (<span class="keyword">char</span>)(firstC + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curNum == <span class="number">9</span>) &#123;</span><br><span class="line">            firstC = (<span class="keyword">char</span>)(firstC + <span class="number">1</span>);</span><br><span class="line">            count = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(firstC + i));</span><br><span class="line">            build(digits, start + <span class="number">1</span>, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 199 - Binary Tree Right Side View</title>
    <url>/2020/05/30/leetcode-199/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<h2 id="Solution-One-BFS"><a href="#Solution-One-BFS" class="headerlink" title="Solution One: BFS"></a>Solution One: BFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 78.26% of Java online submissions for Binary Tree Right Side View.<br>Memory Usage: 37.9 MB, less than 5.88% of Java online submissions for Binary Tree Right Side View.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(Diameter), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            ans.add(queue.peek().val);</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dfs - less space for arrayDeque but more for recursion, O(H)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-DFS"><a href="#Solution-Two-DFS" class="headerlink" title="Solution Two: DFS"></a>Solution Two: DFS</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 207 - Course Schedule</title>
    <url>/2020/05/27/leetcode-207/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 215 - Kth Largest Element in an Array</title>
    <url>/2020/05/30/leetcode-215/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<h2 id="Solution-Quick-Select"><a href="#Solution-Quick-Select" class="headerlink" title="Solution: Quick Select"></a>Solution: Quick Select</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 97.79% of Java online submissions for Kth Largest Element in an Array.<br>Memory Usage: 42.4 MB, less than 5.18% of Java online submissions for Kth Largest Element in an Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// twist from quick sort</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tar = k, start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, nums.length - k, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partitionSort(nums, start, end);</span><br><span class="line">        <span class="keyword">if</span> (pivotIndex == k) <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivotIndex) <span class="keyword">return</span> quickSelect(nums, k, start, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(nums, k, pivotIndex + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return position of pivot </span></span><br><span class="line">    <span class="comment">// (left part &lt; pivotVal, right part &gt;= pivotVal)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partitionSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">int</span> pivotIndex = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pivotVal = nums[pivotIndex];</span><br><span class="line">        swap(nums, pivotIndex, end);</span><br><span class="line">        <span class="keyword">int</span> left = start - <span class="number">1</span>, right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[++left] &lt; pivotVal) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; <span class="number">0</span> &amp;&amp; nums[--right] &gt; pivotVal) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, end);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 238 - Product of Array Except Self</title>
    <url>/2020/05/26/leetcode-238/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Example:</p>
<p>Input:  [1,2,3,4]<br>Output: [24,12,8,6]<br>Constraint: It’s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.</p>
<p>Note: Please solve it without division and in O(n).</p>
<p>Follow up:<br>Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<h2 id="Solution-One-with-extra-array"><a href="#Solution-One-with-extra-array" class="headerlink" title="Solution One: with extra array"></a>Solution One: with extra array</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.<br>Memory Usage: 47.6 MB, less than 5.51% of Java online submissions for Product of Array Except Self.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span>[] record1 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] record2 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        </span><br><span class="line">        record1[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            record1[i] = record1[i-<span class="number">1</span>] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        record2[length - <span class="number">1</span>] = nums[length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            record2[i] = record2[i+<span class="number">1</span>] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans[i] = record1[i-<span class="number">1</span>] * record2[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = record2[<span class="number">1</span>];</span><br><span class="line">        ans[length - <span class="number">1</span>] = record1[length - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-O-1-space-approach"><a href="#Solution-Two-O-1-space-approach" class="headerlink" title="Solution Two: O(1) space approach"></a>Solution Two: O(1) space approach</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 31 - Next Permutation</title>
    <url>/2020/05/27/leetcode-31/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h2 id="Solution-One-One-pass-with-sorting"><a href="#Solution-One-One-pass-with-sorting" class="headerlink" title="Solution One: One pass with sorting"></a>Solution One: One pass with sorting</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 41.73% of Java online submissions for Next Permutation.<br>Memory Usage: 39.7 MB, less than 49.00% of Java online submissions for Next Permutation.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(nlogn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// find pivot from right</span></span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span> pivotIndex = -<span class="number">1</span>, pivotValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex = -<span class="number">1</span>, minVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                pivotIndex = i;</span><br><span class="line">                pivotValue = nums[i];</span><br><span class="line">                minIndex = i + <span class="number">1</span>;</span><br><span class="line">                minVal = nums[i + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; pivotValue</span><br><span class="line">                       &amp;&amp; nums[i] &lt; minVal) &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">                minVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// swap if pivot found</span></span><br><span class="line">        <span class="keyword">if</span> (pivotIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[pivotIndex];</span><br><span class="line">            nums[pivotIndex] = nums[minIndex];</span><br><span class="line">            nums[minIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort from pivot</span></span><br><span class="line">        sortFromPivot(nums, pivotIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// insertion sort</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortFromPivot</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = nums[i], j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j - <span class="number">1</span>] &lt;= cur) <span class="keyword">break</span>;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-One-pass-with-reversing"><a href="#Solution-Two-One-pass-with-reversing" class="headerlink" title="Solution Two: One pass with reversing"></a>Solution Two: One pass with reversing</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 235 - Lowest Common Ancestor of a Binary Search Tree</title>
    <url>/2020/05/26/leetcode-235/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<h2 id="Solution-One-Recursive"><a href="#Solution-One-Recursive" class="headerlink" title="Solution One: Recursive"></a>Solution One: Recursive</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 68.21% of Java online submissions for Lowest Common Ancestor of a Binary Search Tree.<br>Memory Usage: 40.6 MB, less than 5.10% of Java online submissions for Lowest Common Ancestor of a Binary Search Tree.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Iterative"><a href="#Solution-Two-Iterative" class="headerlink" title="Solution Two: Iterative"></a>Solution Two: Iterative</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 399 - Evaluate Division</title>
    <url>/2020/05/23/leetcode-399/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.</p>
<h2 id="Solution-DFS"><a href="#Solution-DFS" class="headerlink" title="Solution: DFS"></a>Solution: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 62.84% of Java online submissions.<br>Memory Usage: 39.8 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="comment">// build map</span></span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">            String A = equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String B = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">            Map&lt;String, Double&gt; subMap = map.getOrDefault(A, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            subMap.put(B, values[i]);</span><br><span class="line">            map.put(A, subMap);</span><br><span class="line">            subMap = map.getOrDefault(B, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            subMap.put(A, <span class="number">1</span> / values[i]);</span><br><span class="line">            map.put(B, subMap);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            result[i] = getPathWeight(queries.get(i).get(<span class="number">0</span>), queries.get(i).get(<span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;&gt;(), map);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getPathWeight</span><span class="params">(String start, String end, Set&lt;String&gt; visited, Map&lt;String, Map&lt;String, Double&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Rejection case. */</span></span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(start)) </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Accepting case. */</span></span><br><span class="line">        <span class="keyword">if</span> (graph.get(start).containsKey(end))</span><br><span class="line">            <span class="keyword">return</span> graph.get(start).get(end);</span><br><span class="line">        </span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; neighbour : graph.get(start).entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(neighbour.getKey())) &#123;</span><br><span class="line">                <span class="keyword">double</span> productWeight = getPathWeight(neighbour.getKey(), end, visited, graph);</span><br><span class="line">                <span class="keyword">if</span> (productWeight != -<span class="number">1.0</span>)</span><br><span class="line">                    <span class="keyword">return</span> neighbour.getValue() * productWeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 419 - Battleships in a Board</title>
    <url>/2020/05/29/leetcode-419/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an 2D board, count how many battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:<br>You receive a valid board, made of only battleships or empty slots.<br>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.<br>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</p>
<h2 id="Solution-transverse-with-memo"><a href="#Solution-transverse-with-memo" class="headerlink" title="Solution: transverse with memo"></a>Solution: transverse with memo</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Battleships in a Board.<br>Memory Usage: 39.3 MB, less than 100.00% of Java online submissions for Battleships in a Board.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowNum = board.length, colNum = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; rowNum) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>, lastX = -<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; colNum) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123; <span class="comment">// 'X' or 'Y'</span></span><br><span class="line">                    <span class="comment">// set next row</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; rowNum - <span class="number">1</span> &amp;&amp; board[i + <span class="number">1</span>][j] == <span class="string">'X'</span>) </span><br><span class="line">                        board[i + <span class="number">1</span>][j] = <span class="string">'Y'</span>;</span><br><span class="line">                    <span class="comment">// recover if counted</span></span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] == <span class="string">'Y'</span>) board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                    <span class="comment">// count</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (lastX != j - <span class="number">1</span>) ans++;</span><br><span class="line">                    lastX = j;</span><br><span class="line">                &#125;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 415 - Add Strings &amp;&amp; Leetcode 67 - Add Binary</title>
    <url>/2020/05/30/leetcode-415/</url>
    <content><![CDATA[<h1 id="Leetcode-415-Add-Strings"><a href="#Leetcode-415-Add-Strings" class="headerlink" title="Leetcode 415 - Add Strings"></a>Leetcode 415 - Add Strings</h1><p><strong>Description</strong><br>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p>
<p>Note:</p>
<p>The length of both num1 and num2 is &lt; 5100.<br>Both num1 and num2 contains only digits 0-9.<br>Both num1 and num2 does not contain any leading zero.<br>You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>
<h2 id="Solution-from-right-to-left-with-StringBuilder"><a href="#Solution-from-right-to-left-with-StringBuilder" class="headerlink" title="Solution: from right to left with StringBuilder"></a>Solution: from right to left with StringBuilder</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 96.05% of Java online submissions for Add Strings.<br>Memory Usage: 39.6 MB, less than 6.25% of Java online submissions for Add Strings.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(max(M,N)), Time Complexity: O(max(M,N)).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i &gt;= <span class="number">0</span>) ? (num1.charAt(i--) - <span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = (j &gt;= <span class="number">0</span>) ? (num2.charAt(j--) - <span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = m + n + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur = cur % <span class="number">10</span>;</span><br><span class="line">            sb.append(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) sb.append(<span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-67-Add-Binary"><a href="#Leetcode-67-Add-Binary" class="headerlink" title="Leetcode 67 - Add Binary"></a>Leetcode 67 - Add Binary</h1><p><strong>Description</strong><br>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both non-empty and contains only characters 1 or 0.</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Add Binary.<br>Memory Usage: 38.2 MB, less than 5.62% of Java online submissions for Add Binary.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = i &gt;= <span class="number">0</span> ? a.charAt(i--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = j &gt;= <span class="number">0</span> ? b.charAt(j--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = m + n + carry;</span><br><span class="line">            carry = cur &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            cur = cur &amp; <span class="number">1</span>;</span><br><span class="line">            sb.append(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) sb.append(carry);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 560 - Subarray Sum Equals K</title>
    <url>/2020/05/27/leetcode-560/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p>
<p>Example 1:</p>
<p>Input:nums = [1,1,1], k = 2<br>Output: 2</p>
<h2 id="Solution-One-Using-Cumulative-Sum-without-extra-space"><a href="#Solution-One-Using-Cumulative-Sum-without-extra-space" class="headerlink" title="Solution One: Using Cumulative Sum without extra space"></a>Solution One: Using Cumulative Sum without extra space</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 446 ms, faster than 5.00% of Java online submissions for Subarray Sum Equals K.<br>Memory Usage: 40.4 MB, less than 33.69% of Java online submissions for Subarray Sum Equals K.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == k) ans++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] - nums[j] == k) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-using-HashMap"><a href="#Solution-Two-using-HashMap" class="headerlink" title="Solution Two: using HashMap"></a>Solution Two: using HashMap</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 14 ms, faster than 42.58% of Java online submissions for Subarray Sum Equals K.<br>Memory Usage: 40.4 MB, less than 34.78% of Java online submissions for Subarray Sum Equals K.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; sumMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        sumMap.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            ans += sumMap.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> count = sumMap.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            sumMap.put(sum, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Related-Questions"><a href="#Related-Questions" class="headerlink" title="Related Questions"></a>Related Questions</h3><p>523 - Continuous Subarray Sum</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 88 - Merge Sorted Array</title>
    <url>/2020/05/30/leetcode-88/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:</p>
<p>The number of elements initialized in nums1 and nums2 are m and n respectively.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.<br>Example:</p>
<p>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>Output: [1,2,2,3,5,6]</p>
<h2 id="Solution-One-Two-pointer-start-from-left"><a href="#Solution-One-Two-pointer-start-from-left" class="headerlink" title="Solution One: Two pointer, start from left"></a>Solution One: Two pointer, start from left</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Sorted Array.<br>Memory Usage: 39.8 MB, less than 5.94% of Java online submissions for Merge Sorted Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(nums1, <span class="number">0</span>, nums1, n, m);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m || j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = i &lt; m ? nums1[n + i] : Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> n2 = j &lt; n ? nums2[j] : Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (n1 &lt;= n2) &#123;</span><br><span class="line">                nums1[count++] = n1;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[count++] = n2;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Two-pointer-start-from-right"><a href="#Solution-Two-Two-pointer-start-from-right" class="headerlink" title="Solution Two: Two pointer, start from right"></a>Solution Two: Two pointer, start from right</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 54 - Spiral Matrix</title>
    <url>/2020/05/24/leetcode-54/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Spiral Matrix.<br>Memory Usage: 37.6 MB, less than 5.21% of Java online submissions for Spiral Matrix.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowNum, colNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rowNum = matrix.length;</span><br><span class="line">        colNum = matrix[<span class="number">0</span>].length;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(rowNum * colNum);</span><br><span class="line">        <span class="keyword">int</span> maxRow = (matrix.length + <span class="number">1</span>) / <span class="number">2</span>, maxCol = (matrix[<span class="number">0</span>].length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; maxRow &amp;&amp; i &lt; maxCol) &#123;</span><br><span class="line">            getCircle(i++, result, matrix);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCircle</span><span class="params">(<span class="keyword">int</span> i, List&lt;Integer&gt; result, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = i, col = i;</span><br><span class="line">        <span class="comment">// left to right</span></span><br><span class="line">        <span class="keyword">while</span> (col &lt; colNum - i) result.add(matrix[row][col++]);</span><br><span class="line">        col--;</span><br><span class="line">        row++;</span><br><span class="line">        <span class="keyword">if</span> (row == rowNum - i) <span class="keyword">return</span>; <span class="comment">// only one row</span></span><br><span class="line">        <span class="comment">// up to down</span></span><br><span class="line">        <span class="keyword">while</span> (row &lt; rowNum - i) result.add(matrix[row++][col]);</span><br><span class="line">        row--;</span><br><span class="line">        col--;</span><br><span class="line">        <span class="keyword">if</span> (col &lt; i) <span class="keyword">return</span>; <span class="comment">// only one col</span></span><br><span class="line">        <span class="comment">// right to left</span></span><br><span class="line">        <span class="keyword">while</span> (col &gt;= i) result.add(matrix[row][col--]);</span><br><span class="line">        col++;</span><br><span class="line">        row--;</span><br><span class="line">        <span class="comment">// down to up</span></span><br><span class="line">        <span class="keyword">while</span> (row &gt; i) result.add(matrix[row--][col]);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 85 - Maximal Rectangle</title>
    <url>/2020/05/26/leetcode-85/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<h2 id="Solution-One-Dynamic-Programming-Better-Brute-Force-on-Histograms"><a href="#Solution-One-Dynamic-Programming-Better-Brute-Force-on-Histograms" class="headerlink" title="Solution One: Dynamic Programming - Better Brute Force on Histograms"></a>Solution One: Dynamic Programming - Better Brute Force on Histograms</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 82.47% of Java online submissions for Maximal Rectangle.<br>Memory Usage: 42.9 MB, less than 86.96% of Java online submissions for Maximal Rectangle.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(m<em>n), Time Complexity: O(m</em>n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowNum = matrix.length, colNum = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] record = <span class="keyword">new</span> <span class="keyword">int</span>[rowNum][colNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowNum; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    record[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) record[i][j] += record[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowNum; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> minHeight = record[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (record[i][k] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    minHeight = Math.min(minHeight, record[i][k]);</span><br><span class="line">                    ans = Math.max(minHeight * (j - k + <span class="number">1</span>), ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Solution-Two-Using-Histograms-Stack"><a href="#Solution-Two-Using-Histograms-Stack" class="headerlink" title="Solution Two: Using Histograms - Stack"></a>Solution Two: Using Histograms - Stack</h3><p>Related question:<br>Leetcode 84 - Largest Rectangle in Histogram</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 93 - Restore IP Addresses</title>
    <url>/2020/05/25/leetcode-93/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>A valid IP address consists of exactly four integers (each integer is between 0 and 255) separated by single points.</p>
<p>Example:</p>
<p>Input: “25525511135”<br>Output: [“255.255.11.135”, “255.255.111.35”]</p>
<h2 id="Solution-One-Backtracking-DFS"><a href="#Solution-One-Backtracking-DFS" class="headerlink" title="Solution One: Backtracking (DFS)"></a>Solution One: Backtracking (DFS)</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.70% of Java online submissions for Restore IP Addresses.<br>Memory Usage: 39.1 MB, less than 9.30% of Java online submissions for Restore IP Addresses.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">https://leetcode.com/problems/restore-ip-addresses/</a><br>Time complexity : as discussed above, there is not more than 27 combinations to check.<br>Space complexity : constant space to keep the solutions, not more than 19 valid IP addresses.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        length = s.length();</span><br><span class="line">        helper(s, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> start, StringBuilder pre, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= length || num &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == length &amp;&amp; num == <span class="number">4</span>) </span><br><span class="line">                result.add(pre.substring(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + j;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; length) <span class="keyword">break</span>;</span><br><span class="line">            String cur = s.substring(start, end);</span><br><span class="line">            <span class="keyword">if</span> ((j == <span class="number">3</span> &amp;&amp; Integer.parseInt(cur) &gt; <span class="number">255</span>)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!String.valueOf(Integer.parseInt(cur)).equals(cur)) <span class="keyword">break</span>;</span><br><span class="line">            pre = pre.append(<span class="string">'.'</span>).append(cur);</span><br><span class="line">            helper(s, end, pre, num + <span class="number">1</span>);</span><br><span class="line">            pre = pre.delete(pre.length() - j - <span class="number">1</span>, pre.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Improved-Solution"><a href="#Improved-Solution" class="headerlink" title="Improved Solution"></a>Improved Solution</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 973 - K Closest Points to Origin</title>
    <url>/2020/05/28/leetcode-973/</url>
    <content><![CDATA[<p><strong>Description</strong><br>We have a list of points on the plane.  Find the K closest points to the origin (0, 0).</p>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
<p>You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)</p>
<h2 id="Solution-One-max-heap"><a href="#Solution-One-max-heap" class="headerlink" title="Solution One: max heap"></a>Solution One: max heap</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 132 ms, faster than 5.03% of Java online submissions for K Closest Points to Origin.<br>Memory Usage: 46.8 MB, less than 100.00% of Java online submissions for K Closest Points to Origin.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(K), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) <span class="keyword">return</span> points;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            Map&lt;<span class="keyword">int</span>[], Integer&gt; distances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] p1, <span class="keyword">int</span>[] p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!distances.containsKey(p1)) &#123;</span><br><span class="line">                    distances.put(p1, p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!distances.containsKey(p2)) &#123;</span><br><span class="line">                    distances.put(p2, p2[<span class="number">0</span>] * p2[<span class="number">0</span>] + p2[<span class="number">1</span>] * p2[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> distances.get(p2) - distances.get(p1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point: points) &#123;</span><br><span class="line">            queue.add(point);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; K) queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[queue.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-kind-of-quick-sort"><a href="#Solution-Two-kind-of-quick-sort" class="headerlink" title="Solution Two: kind of quick sort"></a>Solution Two: kind of quick sort</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 951 - Flip Equivalent Binary Trees</title>
    <url>/2020/05/24/leetcode-951/</url>
    <content><![CDATA[<p><strong>Description</strong><br>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>
<p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>
<p>Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.</p>
<h2 id="Solution-One-Recursive"><a href="#Solution-One-Recursive" class="headerlink" title="Solution One: Recursive"></a>Solution One: Recursive</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Flip Equivalent Binary Trees.<br>Memory Usage: 37.2 MB, less than 5.55% of Java online submissions for Flip Equivalent Binary Trees.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time Complexity: O(min(N_1, N_2)), where N_1, N_2 are the lengths of root1 and root2.</p>
<p>Space Complexity: O(min(H_1, H_2)), where H_1, H_2 are the heights of the trees of root1 and root2.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flipEquiv</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (flipEquiv(root1.left, root2.left)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flipEquiv(root1.right, root2.right)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flipEquiv(root1.left, root2.right)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flipEquiv(root1.right, root2.left)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// return (flipEquiv(root1.left, root2.left) </span></span><br><span class="line">        <span class="comment">//     &amp;&amp; flipEquiv(root1.right, root2.right))</span></span><br><span class="line">        <span class="comment">//     || (flipEquiv(root1.left, root2.right) </span></span><br><span class="line">        <span class="comment">//     &amp;&amp; flipEquiv(root1.right, root2.left));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="solution-two-Canonical-Traversal"><a href="#solution-two-Canonical-Traversal" class="headerlink" title="solution two: Canonical Traversal"></a>solution two: Canonical Traversal</h2><p>Flip each node so that the left child is smaller than the right, and call this the canonical representation. All equivalent trees have exactly one canonical representation.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time Complexity: O(N_1 + N_2), where N_1, N_2 are the lengths of root1 and root2.</p>
<p>Space Complexity: O(N_1 + N_2).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 833 - Find And Replace in String</title>
    <url>/2020/05/25/leetcode-833/</url>
    <content><![CDATA[<p><strong>Description</strong><br>To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p>
<p>Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing.</p>
<p>For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”.</p>
<p>Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’.</p>
<p>All these operations occur simultaneously.  It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case.</p>
<h2 id="Solution-One-For-left-to-right-recording-length-change"><a href="#Solution-One-For-left-to-right-recording-length-change" class="headerlink" title="Solution One: For left to right, recording length change"></a>Solution One: For left to right, recording length change</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 35.60% of Java online submissions for Find And Replace in String.<br>Memory Usage: 39.5 MB, less than 8.70% of Java online submissions for Find And Replace in String.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), for indexMap that stores sorted indexes.<br>Time Complexity: O(N), for one pass.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findReplaceString</span><span class="params">(String S, <span class="keyword">int</span>[] indexes, String[] sources, String[] targets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) <span class="keyword">return</span> S;</span><br><span class="line">        <span class="comment">// build index map</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indexes.length; i++) &#123;</span><br><span class="line">            indexMap.put(indexes[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find and replace</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(S);</span><br><span class="line">        <span class="keyword">int</span> length = S.length();</span><br><span class="line">        <span class="keyword">int</span> change = <span class="number">0</span>, curPos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index : indexMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = indexMap.get(index);</span><br><span class="line">            curPos = indexes[i] + change;</span><br><span class="line">            <span class="keyword">if</span> (curPos &gt;= sb.length()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// found</span></span><br><span class="line">            <span class="keyword">if</span> (sb.indexOf(sources[i], curPos) == curPos) &#123;</span><br><span class="line">                change += targets[i].length() - sources[i].length();</span><br><span class="line">                sb = sb.replace(curPos, curPos + sources[i].length(), targets[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-For-right-to-left-without-recording-length-change"><a href="#Solution-Two-For-right-to-left-without-recording-length-change" class="headerlink" title="Solution Two: For right to left, without recording length change"></a>Solution Two: For right to left, without recording length change</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 105 - Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/2020/05/29/leetcode-105/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<h2 id="Solution-Recursive"><a href="#Solution-Recursive" class="headerlink" title="Solution: Recursive"></a>Solution: Recursive</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span> || preorder.length != inorder.length) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, inorder, <span class="number">0</span>, preorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// recursive case</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> leftLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftLength &lt; length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[inStart + leftLength] == rootVal) <span class="keyword">break</span>;</span><br><span class="line">            leftLength++;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, inorder, inStart, leftLength);</span><br><span class="line">        root.right = build(preorder, preStart + leftLength + <span class="number">1</span>, inorder, inStart + leftLength + <span class="number">1</span>, length - <span class="number">1</span> - leftLength);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips: Time complexity can be reduced by using HashMap to store &lt;val, index&gt; of inorder array.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1249 - Minimum Remove to Make Valid Parentheses</title>
    <url>/2020/05/28/leetcode-1249/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string s of ‘(‘ , ‘)’ and lowercase English characters. </p>
<p>Your task is to remove the minimum number of parentheses ( ‘(‘ or ‘)’, in any positions ) so that the resulting parentheses string is valid and return any valid string.</p>
<p>Formally, a parentheses string is valid if and only if:</p>
<p>It is the empty string, contains only lowercase characters, or<br>It can be written as AB (A concatenated with B), where A and B are valid strings, or<br>It can be written as (A), where A is a valid string.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 13 ms, faster than 87.07% of Java online submissions for Minimum Remove to Make Valid Parentheses.<br>Memory Usage: 40.1 MB, less than 100.00% of Java online submissions for Minimum Remove to Make Valid Parentheses.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ArrayDeque&lt;Integer&gt; leftPs = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="string">'('</span>) &#123;</span><br><span class="line">                leftPs.addLast(sb.length());</span><br><span class="line">                sb.append(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">')'</span> &amp;&amp; !leftPs.isEmpty()) &#123;</span><br><span class="line">                leftPs.removeLast();</span><br><span class="line">                sb.append(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt;= <span class="string">'a'</span> &amp;&amp; cur &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">                sb.append(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove '('</span></span><br><span class="line">        <span class="keyword">while</span> (!leftPs.isEmpty()) &#123;</span><br><span class="line">            sb.deleteCharAt(leftPs.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 41 - First Missing Positive</title>
    <url>/2020/05/31/leetcode-41/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p>Example 1:</p>
<p>Input: [1,2,0]<br>Output: 3<br>Example 2:</p>
<p>Input: [3,4,-1,1]<br>Output: 2<br>Example 3:</p>
<p>Input: [7,8,9,11,12]<br>Output: 1<br>Note:</p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for First Missing Positive.<br>Memory Usage: 37.2 MB, less than 6.85% of Java online submissions for First Missing Positive.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// whether one exists</span></span><br><span class="line">        <span class="keyword">boolean</span> foundOne = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                foundOne = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] == <span class="number">0</span> || nums[i] &gt; n)</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!foundOne) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// clean data</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.abs(nums[i]);</span><br><span class="line">            nums[cur - <span class="number">1</span>] = Math.abs(nums[cur - <span class="number">1</span>]) * (-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check existence</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 543 - Diameter of Binary Tree</title>
    <url>/2020/05/31/leetcode-543/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<h2 id="Solution-DFS-with-depth"><a href="#Solution-DFS-with-depth" class="headerlink" title="Solution: DFS with depth"></a>Solution: DFS with depth</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(H).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        getDepth(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        ans = Math.max(ans, left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 680 - Valid Palindrome II</title>
    <url>/2020/05/31/leetcode-680/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.</p>
<h2 id="Solution-One-StringBuilder"><a href="#Solution-One-StringBuilder" class="headerlink" title="Solution One: StringBuilder"></a>Solution One: StringBuilder</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 9 ms, faster than 30.82% of Java online submissions for Valid Palindrome II.<br>Memory Usage: 40.4 MB, less than 5.55% of Java online submissions for Valid Palindrome II.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(sb)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tar = size - <span class="number">1</span> - i;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(tar)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(<span class="keyword">new</span> StringBuilder(sb).deleteCharAt(i))</span><br><span class="line">                   || isPalindrome(<span class="keyword">new</span> StringBuilder(sb).deleteCharAt(tar)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().equals(sb.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-two-pointer"><a href="#Solution-Two-two-pointer" class="headerlink" title="Solution Two: two pointer"></a>Solution Two: two pointer</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 39.88% of Java online submissions for Valid Palindrome II.<br>Memory Usage: 40 MB, less than 25.00% of Java online submissions for Valid Palindrome II.</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromeRange</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= i + (j - i) / <span class="number">2</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(k) != s.charAt(j - k + i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(s.length() - <span class="number">1</span> - i)) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = s.length() - <span class="number">1</span> - i;</span><br><span class="line">                <span class="keyword">return</span> (isPalindromeRange(s, i+<span class="number">1</span>, j) ||</span><br><span class="line">                        isPalindromeRange(s, i, j-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>String</tag>
      </tags>
  </entry>
</search>
