<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>懒人做法实践之路</title>
    <url>/2020/03/17/easyfood/</url>
    <content><![CDATA[<p>(〃’▽’〃) 好吃好玩又好做的食物</p>
<ol>
<li>微甜甜品</li>
<li>各种饭饭</li>
<li>好多肉啊</li>
<li>花式素菜</li>
</ol>
<a id="more"></a>
<h1 id="微甜甜品"><a href="#微甜甜品" class="headerlink" title="微甜甜品"></a>微甜甜品</h1><h2 id="牛奶椰蓉小方"><a href="#牛奶椰蓉小方" class="headerlink" title="牛奶椰蓉小方"></a>牛奶椰蓉小方</h2><p><img src="/images/life/%E6%A4%B0%E8%93%89%E5%B0%8F%E6%96%B9.jpg" alt="Op5XehMqQCuGxmCTNr+eLg_thumb_60b3"></p>
<p>[<a href="https://www.zhihu.com/question/34583573/answer/764259693]" target="_blank" rel="noopener">https://www.zhihu.com/question/34583573/answer/764259693]</a>(有哪些不用烤箱就能自制的甜品？ - 琪小姐的回答 - 知乎)</p>
<p>糖的分量减半啦，玉米淀粉用普通淀粉代替了。</p>
<h2 id="香芋派"><a href="#香芋派" class="headerlink" title="香芋派"></a>香芋派</h2><p><img src="/images/life/%E9%A6%99%E8%8A%8B%E6%B4%BE1.jpg" alt="Wzbgr5cBQGSnz1W8zxD18Q_thumb_60aa"></p>
<p><img src="/images/life/%E9%A6%99%E8%8A%8B%E6%B4%BE2.jpg" alt="BwUYA1tJRLSNtMjCpmR8%Q_thumb_60a9"></p>
<p>[<a href="https://www.zhihu.com/question/34583573/answer/790679319]" target="_blank" rel="noopener">https://www.zhihu.com/question/34583573/answer/790679319]</a>(有哪些不用烤箱就能自制的甜品？ - 君君辅食记的回答 - 知乎)</p>
<p>有点丑嗷，但是味道真的不错=。= </p>
<p>同样的糖减半了，白砂糖用蜂蜜代替的。</p>
<h1 id="各种饭饭"><a href="#各种饭饭" class="headerlink" title="各种饭饭"></a>各种饭饭</h1><h2 id="排骨焖饭"><a href="#排骨焖饭" class="headerlink" title="排骨焖饭"></a>排骨焖饭</h2><p><img src="/images/life/%E6%8E%92%E9%AA%A8%E7%84%96%E9%A5%AD1.jpg" alt="UNADJUSTEDNONRAW_thumb_60c3"></p>
<p><img src="/images/life/%E6%8E%92%E9%AA%A8%E7%84%96%E9%A5%AD2.jpg" alt="UNADJUSTEDNONRAW_thumb_60c4"></p>
<p><a href="https://www.xiachufang.com/recipe/1065180/" target="_blank" rel="noopener">https://www.xiachufang.com/recipe/1065180/</a></p>
<p>DIY空间很大～自己加了玉米粒，只蒸了一次米饭，依然超！级！香！</p>
<h2 id="咖喱焗饭"><a href="#咖喱焗饭" class="headerlink" title="咖喱焗饭"></a>咖喱焗饭</h2><p><img src="/images/life/%E5%92%96%E5%96%B1%E7%84%97%E9%A5%AD.jpeg" alt="咖喱焗饭"><br>先蒸好菜饭，加点水拌入咖喱，最后把略微煎了下的培根虾仁和饭混匀，上面撒一层芝士就可以放进烤箱了。<br>发挥空间很大，其实直接咖喱饭或者芝士焗饭就挺好吃吧。</p>
<h1 id="好多肉啊"><a href="#好多肉啊" class="headerlink" title="好多肉啊"></a>好多肉啊</h1><h2 id="椒盐排骨"><a href="#椒盐排骨" class="headerlink" title="椒盐排骨"></a>椒盐排骨</h2><p><img src="/images/life/%E6%A4%92%E7%9B%90%E6%8E%92%E9%AA%A8.jpg" alt="L%QA38JpTP66BfX9Jl6H%g_thumb_5fe5"></p>
<h2 id="蜜汁鸡翅-amp-鸡腿"><a href="#蜜汁鸡翅-amp-鸡腿" class="headerlink" title="蜜汁鸡翅&amp;鸡腿"></a>蜜汁鸡翅&amp;鸡腿</h2><p><img src="/images/life/%E8%9C%9C%E6%B1%81%E9%B8%A1%E7%BF%85.jpg" alt="9wo%YPQ0S7+rHBQ0JglSSQ_thumb_5f17"></p>
<h2 id="肉末豆腐"><a href="#肉末豆腐" class="headerlink" title="肉末豆腐"></a>肉末豆腐</h2><p><img src="/images/life/%E8%82%89%E6%9C%AB%E8%B1%86%E8%85%90.jpg" alt="9yb%6dTXRIyAeSiTBseVjA_thumb_5fcb"></p>
<h2 id="牛肉丸子汤"><a href="#牛肉丸子汤" class="headerlink" title="牛肉丸子汤"></a>牛肉丸子汤</h2><p><img src="/images/life/%E7%89%9B%E8%82%89%E4%B8%B8%E5%AD%90%E6%B1%A4.jpg" alt="UNADJUSTEDNONRAW_thumb_5fcf"></p>
<h2 id="盐焗鸡"><a href="#盐焗鸡" class="headerlink" title="盐焗鸡"></a>盐焗鸡</h2><p><img src="/images/life/%E7%9B%90%E7%84%97%E9%B8%A1.jpeg" alt="盐焗鸡"><br>直接用的盐焗粉，葱姜片垫底，抹好直接放电饭煲蒸半小时就好啦。<br>事先腌一下应该更入味。</p>
<h2 id="椰子鸡"><a href="#椰子鸡" class="headerlink" title="椰子鸡"></a>椰子鸡</h2><p><img src="/images/life/%E6%A4%B0%E5%AD%90%E9%B8%A1.jpeg" alt="椰子鸡"><br>主要参考的曼食慢语的菜谱：<a href="https://www.xiachufang.com/recipe/103465588/" target="_blank" rel="noopener">https://www.xiachufang.com/recipe/103465588/</a><br>跟着广东室友做的。用了一只老椰🥥的椰水，椰肉用了一半。鸡用的是一整只小母鸡，只用煮十分钟，非常嫩！</p>
<h2 id="脆皮烤鸡"><a href="#脆皮烤鸡" class="headerlink" title="脆皮烤鸡"></a>脆皮烤鸡</h2><p><img src="/images/life/%E8%84%86%E7%9A%AE%E7%83%A4%E9%B8%A1.jpeg" alt="脆皮烤鸡"><br>这算是看了那么多菜单过后自己总结出来的。</p>
<ol>
<li>椒盐按摩鸡身，然后用牙签猛插孔（为了腌得更入味），放冰箱里面一晚上。</li>
<li>预热到425度，烤鸡刷少许花椒油放入。</li>
<li>30-40分钟后再刷一层蜂蜜，最后烤5分钟就好啦！</li>
</ol>
<h2 id="蘑菇烧鸡"><a href="#蘑菇烧鸡" class="headerlink" title="蘑菇烧鸡"></a>蘑菇烧鸡</h2><p><img src="/images/life/%E8%98%91%E8%8F%87%E7%83%A7%E9%B8%A1.jpeg" alt="蘑菇烧鸡"><br>最近做了好多鸡诶，这个做法很家常啦。</p>
<h2 id="猪肉丸子汤"><a href="#猪肉丸子汤" class="headerlink" title="猪肉丸子汤"></a>猪肉丸子汤</h2><p><img src="/images/life/%E7%8C%AA%E8%82%89%E4%B8%B8%E5%AD%90%E6%B1%A4.jpeg" alt="猪肉丸子汤"><br>丸子还是猪肉香呀（潮汕牛肉丸除外）</p>
<h1 id="花式素菜"><a href="#花式素菜" class="headerlink" title="花式素菜"></a>花式素菜</h1><h2 id="酱汁杏鲍菇"><a href="#酱汁杏鲍菇" class="headerlink" title="酱汁杏鲍菇"></a>酱汁杏鲍菇</h2><p><img src="/images/life/%E9%85%B1%E6%B1%81%E6%9D%8F%E9%B2%8D%E8%8F%87.jpeg" alt="酱汁杏鲍菇"><br>下厨房链接：<a href="https://www.xiachufang.com/recipe/104527015/" target="_blank" rel="noopener">https://www.xiachufang.com/recipe/104527015/</a><br>先煎后焖，比肉还好吃的杏鲍菇！</p>
<h2 id="酿豆腐"><a href="#酿豆腐" class="headerlink" title="酿豆腐"></a>酿豆腐</h2><p><img src="/images/life/%E9%85%BF%E8%B1%86%E8%85%90.jpeg" alt="酿豆腐"><br>下厨房链接：<a href="https://www.xiachufang.com/recipe/100054342/" target="_blank" rel="noopener">https://www.xiachufang.com/recipe/100054342/</a><br>没有吃过正宗的，感觉自己做的味道还不错，就是焖的时间有点短了。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>food</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1110 - Delete Nodes And Return Forest (DFS)</title>
    <url>/2020/03/27/leetcode-1110/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 98.12% of Java online submissions for Delete Nodes And Return Forest.<br>Memory Usage: 40.5 MB, less than 100.00% of Java online submissions for Delete Nodes And Return Forest.</p>
<a id="more"></a>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>M is the number of deleted elements,  N is the number of nodes.</p>
<p>Space Complexity: O(logN), actually O(min(M, depth))</p>
<ol>
<li>deleteSet - O(M)</li>
<li>Recursion - O(depth of the tree), or O(logN)</li>
</ol>
<p>Time Complexity: O(N).</p>
<ol>
<li>build deleteSet - O(M)</li>
<li>dfs - O(N)</li>
</ol>
<h3 id="Java-Solution"><a href="#Java-Solution" class="headerlink" title="Java Solution"></a>Java Solution</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">delNodes</span><span class="params">(TreeNode root, <span class="keyword">int</span>[] to_delete)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; treeList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> treeList;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; deleteSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : to_delete) &#123;</span><br><span class="line">            deleteSet.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root, <span class="keyword">null</span>, treeList, deleteSet);</span><br><span class="line">        <span class="keyword">return</span> treeList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, TreeNode prev, List&lt;TreeNode&gt; treeList, Set&lt;Integer&gt; deleteSet)</span> </span>&#123;</span><br><span class="line">        TreeNode leftNode = root.left;</span><br><span class="line">        TreeNode rightNode = root.right;</span><br><span class="line">        <span class="comment">// check myself</span></span><br><span class="line">        <span class="keyword">if</span> (deleteSet.contains(root.val)) &#123;</span><br><span class="line">            <span class="comment">// delete myself from prev</span></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prev.left == root) &#123;</span><br><span class="line">                    prev.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    prev.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">                treeList.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dfs left child</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(leftNode, prev, treeList, deleteSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dfs right child</span></span><br><span class="line">        <span class="keyword">if</span> (rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dfs(rightNode, prev, treeList, deleteSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Google</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1007 - Minimum Domino Rotations For Equal Row (Greedy)</title>
    <url>/2020/03/20/leetcode-1007/</url>
    <content><![CDATA[<p>Space Complexity: O(1), Time Complexity: O(N).</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDominoRotations</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fix A[0] and check A/B</span></span><br><span class="line">    <span class="keyword">int</span> res1 = checkElement(A[<span class="number">0</span>], A, B);</span><br><span class="line">    <span class="comment">// Fix B[0] and check A/B</span></span><br><span class="line">    <span class="keyword">int</span> res2 = checkElement(B[<span class="number">0</span>], A, B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = Math.min(res1, res2);</span><br><span class="line">    <span class="keyword">if</span> (res == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkElement</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rotateA = <span class="number">0</span>, rotateB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != x &amp;&amp; B[i] != x) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (A[i] != x) &#123;</span><br><span class="line">            rotateA++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (B[i] != x) &#123;</span><br><span class="line">            rotateB++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(rotateA, rotateB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1192 - Critical Connections in a Network</title>
    <url>/2020/05/01/leetcode-1192/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network.</p>
<p>A critical connection is a connection that, if removed, will make some server unable to reach some other server.</p>
<p>Return all critical connections in the network in any order.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 178 ms, faster than 20.85% of Java online submissions.<br>Memory Usage: 137.5 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; criticalConnections(<span class="keyword">int</span> n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> result;</span><br><span class="line">        List&lt;Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; conn : connections) &#123;</span><br><span class="line">            graph.get(conn.get(<span class="number">0</span>)).add(conn.get(<span class="number">1</span>));</span><br><span class="line">            graph.get(conn.get(<span class="number">1</span>)).add(conn.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] smallestCount = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dfs(graph, -<span class="number">1</span>, <span class="number">0</span>, visited, smallestCount);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Set&lt;Integer&gt;&gt; graph, <span class="keyword">int</span> lastNode, <span class="keyword">int</span> curNode, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] smallestCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curCount = counter;</span><br><span class="line">        smallestCount[curNode] = counter++;</span><br><span class="line">        visited[curNode] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : graph.get(curNode)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextNode == lastNode) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!visited[nextNode]) &#123;</span><br><span class="line">                dfs(graph, curNode, nextNode, visited, smallestCount);</span><br><span class="line">            &#125;</span><br><span class="line">            smallestCount[curNode] = Math.min(smallestCount[curNode], smallestCount[nextNode]);</span><br><span class="line">            <span class="keyword">if</span> (curCount &lt; smallestCount[nextNode]) &#123;</span><br><span class="line">                result.add(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;curNode, nextNode&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1048 - Longest String Chain (Graph)</title>
    <url>/2020/03/21/leetcode-1048/</url>
    <content><![CDATA[<h2 id="Approach-1-Graph"><a href="#Approach-1-Graph" class="headerlink" title="Approach 1 - Graph"></a>Approach 1 - Graph</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 38 ms, faster than 41.66% of Java online submissions for Longest String Chain.<br>Memory Usage: 42 MB, less than 100.00% of Java online submissions for Longest String Chain.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N^2), Time Complexity: O(M*N).</p>
<p>M: length of words, N: number of words.</p>
<a id="more"></a>


<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; graphMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Map&lt;String, Integer&gt; indegreeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// add all string as predecessors: O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">        graphMap.put(s, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        indegreeMap.put(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// build graph: O(n*word_length)</span></span><br><span class="line">    <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// traverse predecessors</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            String cur = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == s.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                cur = s.substring(<span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = s.substring(<span class="number">0</span>, i) + s.substring(i+<span class="number">1</span>, s.length());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (graphMap.containsKey(cur)) &#123;</span><br><span class="line">                graphMap.get(cur).add(s);</span><br><span class="line">                indegreeMap.put(s, indegreeMap.get(s) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collect "start" words</span></span><br><span class="line">    <span class="keyword">for</span> (String s : indegreeMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegreeMap.get(s) == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// BFS: O(depth) -&gt; O(logn)</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">int</span> count = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String s = queue.poll();</span><br><span class="line">            queue.addAll(graphMap.get(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Approach-2-Dynamic-Progrmming"><a href="#Approach-2-Dynamic-Progrmming" class="headerlink" title="Approach 2 - Dynamic Progrmming"></a>Approach 2 - Dynamic Progrmming</h2><p>To be continued.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Dynamic Programming</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1268 - Search Suggestions System</title>
    <url>/2020/05/08/leetcode-1268/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given an array of strings products and a string searchWord. We want to design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with the searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.</p>
<p>Return list of lists of the suggested products after each character of searchWord is typed. </p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 40 ms, faster than 30.92% of Java online submissions.<br>Memory Usage: 47.9 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        TreeMap&lt;Character, Node&gt; nexts;</span><br><span class="line">        TreeSet&lt;String&gt; words;</span><br><span class="line">        Node parent;</span><br><span class="line">        <span class="keyword">boolean</span> isEnd;</span><br><span class="line">        Node(<span class="keyword">char</span> newC, Node p) &#123;</span><br><span class="line">            c = newC;</span><br><span class="line">            nexts = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">            words = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">            parent = p;</span><br><span class="line">            isEnd = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123;</span><br><span class="line">        Node root = <span class="keyword">new</span> Node(<span class="string">' '</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// build tree</span></span><br><span class="line">        <span class="keyword">for</span> (String word : products) &#123;</span><br><span class="line">            Node tmp = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">char</span> curC = word.charAt(i);</span><br><span class="line">                Node curNode = tmp.nexts.getOrDefault(curC, <span class="keyword">new</span> Node(curC, tmp));</span><br><span class="line">                tmp.nexts.put(curC, curNode);</span><br><span class="line">                tmp = curNode;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.isEnd = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// fill in word set</span></span><br><span class="line">            <span class="keyword">while</span> (tmp != root) &#123;</span><br><span class="line">                tmp.words.add(word);</span><br><span class="line">                <span class="keyword">if</span> (tmp.words.size() &gt; <span class="number">3</span>) tmp.words.pollLast();</span><br><span class="line">                tmp = tmp.parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// search tree</span></span><br><span class="line">        <span class="keyword">int</span> length = searchWord.length();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(length);</span><br><span class="line">        Node tmp = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> curC = searchWord.charAt(i);</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                tmp = tmp.nexts.getOrDefault(curC, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    list.addAll(tmp.words);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1146 - Snapshot Array</title>
    <url>/2020/04/27/leetcode-1146/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement a SnapshotArray that supports the following interface:</p>
<p>SnapshotArray(int length) initializes an array-like data structure with the given length.  Initially, each element equals 0.<br>void set(index, val) sets the element at the given index to be equal to val.<br>int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.<br>int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 42 ms, faster than 35.60% of Java online submissions.<br>Memory Usage: 61.2 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotArray</span> </span>&#123;</span><br><span class="line">    List&lt;TreeMap&lt;Integer, Integer&gt;&gt; snapList;</span><br><span class="line">    <span class="keyword">int</span> snapNum = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        snapList = <span class="keyword">new</span> ArrayList&lt;&gt;(length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            snapList.add(<span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        snapList.get(index).put(snapNum, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">snap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> snapNum++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> snap_id)</span> </span>&#123;</span><br><span class="line">        Integer id = snapList.get(index).floorKey(snap_id);</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> snapList.get(index).get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SnapshotArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SnapshotArray obj = new SnapshotArray(length);</span></span><br><span class="line"><span class="comment"> * obj.set(index,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.snap();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.get(index,snap_id);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 127 - Word Ladder &amp; Leetcode 126 - Word Ladder II</title>
    <url>/2020/04/18/leetcode-127/</url>
    <content><![CDATA[<h2 id="Leetcode-127-Word-Ladder"><a href="#Leetcode-127-Word-Ladder" class="headerlink" title="Leetcode 127 - Word Ladder"></a>Leetcode 127 - Word Ladder</h2><p><strong>Description</strong><br>Given two words (beginWord and endWord), and a dictionary’s word list, find the <strong>length</strong> of shortest transformation sequence from beginWord to endWord, such that:</p>
<ol>
<li>Only one letter can be changed at a time.</li>
<li>Each transformed word must exist in the word list.</li>
</ol>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 61 ms, faster than 53.14% of Java online submissions.<br>Memory Usage: 40.8 MB, less than 72.26% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String w : wordList) &#123;</span><br><span class="line">            dict.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!dict.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">          String w = queue.poll();</span><br><span class="line">          size--;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] a = w.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> j = <span class="string">'a'</span>; j &lt;= <span class="string">'z'</span>; j++) &#123;</span><br><span class="line">              a[i] = j;</span><br><span class="line">              String newOne = <span class="keyword">new</span> String(a);</span><br><span class="line">              <span class="keyword">if</span> (newOne.equals(endWord))</span><br><span class="line">                <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (dict.contains(newOne)) &#123;</span><br><span class="line">                queue.add(newOne);</span><br><span class="line">                dict.remove(newOne);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            size = queue.size();</span><br><span class="line">            level++;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Leetcode-126-Word-Ladder-II"><a href="#Leetcode-126-Word-Ladder-II" class="headerlink" title="Leetcode 126 - Word Ladder II"></a>Leetcode 126 - Word Ladder II</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given two words (beginWord and endWord), and a dictionary’s word list, find <strong>all shortest transformation sequence(s)</strong> from beginWord to endWord, such that:</p>
<ol>
<li>Only one letter can be changed at a time</li>
<li>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</li>
</ol>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 84 ms, faster than 70.21% of Java online submissions.<br>Memory Usage: 40.7 MB, less than 86.54% of Java online submissions.</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String w : wordList) &#123;</span><br><span class="line">            dict.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dict.contains(beginWord)) dict.remove(beginWord);</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!dict.contains(endWord) || beginWord.equals(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// &lt;child, parent&gt;</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; prevMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; neighborMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            Set&lt;String&gt; nexts = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// traverse all neighbors</span></span><br><span class="line">                String cur = queue.poll();</span><br><span class="line">                List&lt;String&gt; neighbors = getNeighbors(cur, dict);</span><br><span class="line">                <span class="keyword">for</span> (String newOne : neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(newOne)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (newOne.equals(endWord)) &#123;</span><br><span class="line">                            found = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        List&lt;String&gt; prevList = prevMap.getOrDefault(newOne, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                        prevList.add(cur);</span><br><span class="line">                        prevMap.put(newOne, prevList);</span><br><span class="line">                        nexts.add(newOne);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if found</span></span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// add to queue</span></span><br><span class="line">            <span class="keyword">for</span> (String s: nexts) &#123;</span><br><span class="line">                queue.add(s);</span><br><span class="line">                visited.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            LinkedList&lt;String&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            path.add(endWord);</span><br><span class="line">            dfs(endWord, path, prevMap, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ArrayList&lt;String&gt; <span class="title">getNeighbors</span><span class="params">(String node, Set&lt;String&gt; dict)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">char</span> chs[] = node.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch =<span class="string">'a'</span>; ch &lt;= <span class="string">'z'</span>; ch++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chs[i] == ch) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">char</span> old_ch = chs[i];</span><br><span class="line">                chs[i] = ch;</span><br><span class="line">                <span class="keyword">if</span> (dict.contains(String.valueOf(chs))) &#123;</span><br><span class="line">                    res.add(String.valueOf(chs));</span><br><span class="line">                &#125;</span><br><span class="line">                chs[i] = old_ch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, LinkedList&lt;String&gt; path, Map&lt;String, List&lt;String&gt;&gt; prevMap, List&lt;List&lt;String&gt;&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!prevMap.containsKey(s)) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String pre : prevMap.get(s)) &#123;</span><br><span class="line">            path.addFirst(pre);</span><br><span class="line">            dfs(pre, path, prevMap, result);</span><br><span class="line">            path.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1334 - Find the City With the Smallest Number of Neighbors at a Threshold Distance</title>
    <url>/2020/04/30/leetcode-1334/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi, weighti] represents a bidirectional and weighted edge between cities fromi and toi, and given the integer distanceThreshold.</p>
<p>Return the city with the smallest number of cities that are reachable through some path and whose distance is at most distanceThreshold, If there are multiple such cities, return the city with the greatest number.</p>
<p>Notice that the distance of a path connecting cities i and j is equal to the sum of the edges’ weights along that path.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 110 ms, faster than 21.53% of Java online submissions.<br>Memory Usage: 40.1 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheCity</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; edgeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">            edgeMap.putIfAbsent(edge[<span class="number">0</span>], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            edgeMap.get(edge[<span class="number">0</span>]).put(edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">            edgeMap.putIfAbsent(edge[<span class="number">1</span>], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            edgeMap.get(edge[<span class="number">1</span>]).put(edge[<span class="number">0</span>], edge[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a1, a2) -&gt; (a2[<span class="number">1</span>] - a1[<span class="number">1</span>]));</span><br><span class="line">            Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, distanceThreshold&#125;);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] edge = q.poll();</span><br><span class="line">                <span class="keyword">int</span> nextNode = edge[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> limit = edge[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (visited.contains(nextNode)) <span class="keyword">continue</span>;</span><br><span class="line">                visited.add(nextNode);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (edgeMap.containsKey(nextNode)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : edgeMap.get(nextNode).entrySet()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(entry.getKey()) &amp;&amp; entry.getValue() &lt;= limit) &#123;</span><br><span class="line">                            q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;entry.getKey(), limit - entry.getValue()&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count - <span class="number">1</span> &lt;= min) &#123;</span><br><span class="line">                min = count - <span class="number">1</span>;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 138 - Copy List with Random Pointer</title>
    <url>/2020/05/10/leetcode-138/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>
<p>Return a deep copy of the list.</p>
<p>The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:</p>
<p>val: an integer representing Node.val<br>random_index: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions.<br>Memory Usage: 39.3 MB, less than 5.61% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// &lt;old, new&gt;</span></span><br><span class="line">        Map&lt;Node, Node&gt; copyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Node newhead = <span class="keyword">new</span> Node(head.val);</span><br><span class="line">        copyMap.put(head, newhead);</span><br><span class="line">        searchRandom(head, copyMap);</span><br><span class="line">        </span><br><span class="line">        Node cur = head.next, newPrev = newhead, newCur;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!copyMap.containsKey(cur)) &#123;</span><br><span class="line">                copyMap.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// search random list</span></span><br><span class="line">            searchRandom(cur, copyMap);</span><br><span class="line">            </span><br><span class="line">            newCur = copyMap.get(cur);</span><br><span class="line">            newPrev.next = newCur;</span><br><span class="line">            newPrev = newCur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">searchRandom</span><span class="params">(Node oldNode, Map&lt;Node, Node&gt; copyMap)</span> </span>&#123;</span><br><span class="line">        Node newPrev = copyMap.get(oldNode), newCur = <span class="keyword">null</span>;</span><br><span class="line">        Node cur = oldNode.random;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!copyMap.containsKey(cur)) &#123;</span><br><span class="line">                copyMap.put(cur, <span class="keyword">new</span> Node(cur.val));</span><br><span class="line">            &#125;</span><br><span class="line">            newCur = copyMap.get(cur);</span><br><span class="line">            newPrev.random = newCur;</span><br><span class="line">            newPrev = newCur;</span><br><span class="line">            cur = cur.random;</span><br><span class="line">            <span class="keyword">if</span> (newCur.random != <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1320 - Minimum Distance to Type a Word Using Two Fingers</title>
    <url>/2020/04/24/leetcode-1320/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You have a keyboard layout as shown above in the XY plane, where each English uppercase letter is located at some coordinate, for example, the letter A is located at coordinate (0,0), the letter B is located at coordinate (0,1), the letter P is located at coordinate (2,3) and the letter Z is located at coordinate (4,1).</p>
<p>Given the string word, return the minimum total distance to type such string using only two fingers. The distance between coordinates (x1,y1) and (x2,y2) is |x1 - x2| + |y1 - y2|. </p>
<p>Note that the initial positions of your two fingers are considered free so don’t count towards your total distance, also your two fingers do not have to start at the first letter or the first two letters.<br><a href="https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/</a></p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 25 ms, faster than 53.43% of Java online submissions.<br>Memory Usage: 41.2 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumDistance</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = word.length();</span><br><span class="line">        <span class="keyword">int</span>[][][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">26</span>][<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[][] arr : memo) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] tmp : arr) Arrays.fill(tmp, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// record location</span></span><br><span class="line">        Map&lt;Integer, <span class="keyword">int</span>[]&gt; posMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">5</span>; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">6</span>; col++) &#123;</span><br><span class="line">                posMap.put(c, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;row, col&#125;);</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(posMap, word, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(Map&lt;Integer, <span class="keyword">int</span>[]&gt; posMap, String word, <span class="keyword">int</span> index, <span class="keyword">int</span> pos1, <span class="keyword">int</span> pos2, <span class="keyword">int</span>[][][] memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> distance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos1 &gt; -<span class="number">1</span> &amp;&amp; pos2 &gt; -<span class="number">1</span> &amp;&amp; memo[index][pos1][pos2] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[index][pos1][pos2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(index);</span><br><span class="line">        <span class="comment">// figure 1</span></span><br><span class="line">        <span class="keyword">int</span> d1 = dfs(posMap, word, index + <span class="number">1</span>, c - <span class="string">'A'</span>, pos2, memo) + getDistance(c - <span class="string">'A'</span>, pos1, posMap);</span><br><span class="line">        <span class="comment">// figure 2</span></span><br><span class="line">        <span class="keyword">int</span> d2 = dfs(posMap, word, index + <span class="number">1</span>, pos1, c - <span class="string">'A'</span>, memo) + getDistance(c - <span class="string">'A'</span>, pos2, posMap);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pos1 != -<span class="number">1</span> &amp;&amp; pos2 != -<span class="number">1</span>) &#123;</span><br><span class="line">            memo[index][pos1][pos2] = distance + Math.min(d1, d2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance + Math.min(d1, d2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDistance</span><span class="params">(<span class="keyword">int</span> c1, <span class="keyword">int</span> c2, Map&lt;Integer, <span class="keyword">int</span>[]&gt; posMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c1 == -<span class="number">1</span> || c2 == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] pos1 = posMap.get(c1);</span><br><span class="line">        <span class="keyword">int</span>[] pos2 = posMap.get(c2);</span><br><span class="line">        <span class="keyword">return</span> Math.abs(pos1[<span class="number">0</span>] - pos2[<span class="number">0</span>]) + Math.abs(pos1[<span class="number">1</span>] - pos2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 146 - LRU Cache</title>
    <url>/2020/05/06/leetcode-146/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p>
<p>The cache is initialized with a positive capacity.</p>
<p>Follow up:<br>Could you do both operations in O(1) time complexity?</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 12 ms, faster than 95.09% of Java online submissions.<br>Memory Usage: 47.9 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LRUMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">        LRUMap(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">            cacheSize = capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LRUMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LRUMap&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.getOrDefault(key, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - Sliding Window</title>
    <url>/2020/04/12/leetcode-3/</url>
    <content><![CDATA[<p>3.Longest Substring Without Repeating Characters<br>76.Minimum Window Substring<br>862.Shortest Subarray with Sum at Least K</p>
<a id="more"></a>

<h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// &lt;char, index&gt;</span></span><br><span class="line">        Map&lt;Character, Integer&gt; recordMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (recordMap.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = recordMap.get(c);</span><br><span class="line">                <span class="keyword">while</span> (i &lt;= next) &#123;</span><br><span class="line">                    recordMap.remove(s.charAt(i++));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            recordMap.put(c, j++);</span><br><span class="line">            result = Math.max(result, j - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">sContainsT</span><span class="params">(<span class="keyword">int</span> countS[], <span class="keyword">int</span> countT[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countT.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countT[i] &gt; countS[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;           </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> countS[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> countT[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];   </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            countT[t.charAt(i)]++;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>, min = Integer.MAX_VALUE;         </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; s.length() &amp;&amp; !sContainsT(countS, countT)) &#123;</span><br><span class="line">                countS[s.charAt(right)]++;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sContainsT(countS, countT) &amp;&amp; min &gt; right - i + <span class="number">1</span>) &#123;</span><br><span class="line">                result = s.substring(i, right);</span><br><span class="line">                min = right - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Shrink</span></span><br><span class="line">            countS[s.charAt(i)]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="862-Shortest-Subarray-with-Sum-at-Least-K"><a href="#862-Shortest-Subarray-with-Sum-at-Least-K" class="headerlink" title="862. Shortest Subarray with Sum at Least K"></a>862. Shortest Subarray with Sum at Least K</h2><p>kind of Sliding window</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
        <tag>Sliding Window</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 200 - Number of Islands</title>
    <url>/2020/05/03/leetcode-200/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.96% of Java online submissions.<br>Memory Usage: 41.9 MB, less than 47.44% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    result ++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= grid.length || col &gt;= grid[<span class="number">0</span>].length || grid[row][col] == <span class="string">'0'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[row][col] = <span class="string">'0'</span>;</span><br><span class="line">        dfs(grid, row, col + <span class="number">1</span>);</span><br><span class="line">        dfs(grid, row, col - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, row + <span class="number">1</span>, col);</span><br><span class="line">        dfs(grid, row - <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 240 - Search a 2D Matrix II</title>
    <url>/2020/05/07/leetcode-240/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<pre><code>Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.</code></pre><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 7 ms, faster than 31.64% of Java online submissions.<br>Memory Usage: 44.6 MB, less than 94.34% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowNum, colNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rowNum = matrix.length, colNum = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> i = rowNum - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; colNum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; matrix[i][j]) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == matrix[i][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 297 - Serialize and Deserialize Binary Tree</title>
    <url>/2020/04/08/leetcode-297/</url>
    <content><![CDATA[<p>Two solutions.</p>
<a id="more"></a>

<h3 id="Solution-1-Time-Limit-Exceeded"><a href="#Solution-1-Time-Limit-Exceeded" class="headerlink" title="Solution 1: Time Limit Exceeded"></a>Solution 1: Time Limit Exceeded</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt;  q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> isLeaf = <span class="keyword">false</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isLeaf) &#123;</span><br><span class="line">            isLeaf = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> count = q.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TreeNode n1 = <span class="keyword">null</span>, n2 = <span class="keyword">null</span>;</span><br><span class="line">                    q.offer(n1);</span><br><span class="line">                    q.offer(n2);</span><br><span class="line">                    <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span>) s+= <span class="string">","</span>;</span><br><span class="line">                    s += <span class="string">"null"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    q.offer(node.left);</span><br><span class="line">                    q.offer(node.right);</span><br><span class="line">                    <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span>) s+= <span class="string">","</span>;</span><br><span class="line">                    s += node.val;</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="keyword">null</span> || node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        isLeaf = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        String[] arr = data.split(<span class="string">","</span>);</span><br><span class="line">        TreeNode root = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span> || arr[<span class="number">0</span>].equals(<span class="string">"null"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        root = <span class="keyword">new</span> TreeNode(Integer.parseInt(arr[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; arr.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = q.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    index += <span class="number">2</span>;</span><br><span class="line">                    TreeNode n1 = <span class="keyword">null</span>, n2 = <span class="keyword">null</span>;</span><br><span class="line">                    q.offer(n1);</span><br><span class="line">                    q.offer(n2);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                String cur_val = arr[index];</span><br><span class="line">                <span class="keyword">if</span> (cur_val.equals(<span class="string">"null"</span>)) node.left = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> node.left = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur_val));</span><br><span class="line">                cur_val = arr[++index];</span><br><span class="line">                <span class="keyword">if</span> (cur_val.equals(<span class="string">"null"</span>)) node.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span> node.right = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur_val));</span><br><span class="line">                index ++;</span><br><span class="line">                q.offer(node.left);</span><br><span class="line">                q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<h3 id="Solution-2-Accepted"><a href="#Solution-2-Accepted" class="headerlink" title="Solution 2: Accepted"></a>Solution 2: Accepted</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    preOrderTraverse(root, sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sb.append(<span class="string">"null"</span>).append(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(root.val).append(<span class="string">","</span>);</span><br><span class="line">    preOrderTraverse(root.left, sb);</span><br><span class="line">    preOrderTraverse(root.right, sb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    Deque&lt;String&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    nodes.addAll(Arrays.asList(data.split(<span class="string">","</span>)));</span><br><span class="line">    <span class="keyword">return</span> buildTree(nodes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(Deque&lt;String&gt; nodes)</span> </span>&#123;</span><br><span class="line">    String val = nodes.remove();</span><br><span class="line">    <span class="keyword">if</span> (val.equals(<span class="string">"null"</span>)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(Integer.valueOf(val));</span><br><span class="line">        node.left = buildTree(nodes);</span><br><span class="line">        node.right = buildTree(nodes);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 221 - Maximal Square (Dynamic Programming)</title>
    <url>/2020/03/22/leetcode-221/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 84.73% of Java online submissions for Maximal Square.</p>
<p>Memory Usage: 43.4 MB, less than 91.18% of Java online submissions for Maximal Square.</p>
<a id="more"></a>


<h3 id="Approach-1-Dynamic-Programming"><a href="#Approach-1-Dynamic-Programming" class="headerlink" title="Approach 1 - Dynamic Programming"></a>Approach 1 - Dynamic Programming</h3><p>Space Complexity: O(MN), Time Complexity: O(MN).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result * result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Approach-2-Better-Dynamic-Progrmming"><a href="#Approach-2-Better-Dynamic-Progrmming" class="headerlink" title="Approach 2 - Better Dynamic Progrmming"></a>Approach 2 - Better Dynamic Progrmming</h3><p>To be continued.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 315 - Count of Smaller Numbers After Self</title>
    <url>/2020/04/14/leetcode-315/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 92.22% of Java online submissions.<br>Memory Usage: 41.7 MB, less than 8.33% of Java online submissions.</p>
<a id="more"></a>

<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Node left; </span><br><span class="line">        Node right;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">		Node root = <span class="keyword">new</span> Node(nums[nums.length - <span class="number">1</span>]);</span><br><span class="line">		res.add(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			<span class="keyword">int</span> count = insertNode(root, nums[i]);</span><br><span class="line">			res.addFirst(count);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertNode</span><span class="params">(Node root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> thisCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(val &lt;= root.val) &#123;</span><br><span class="line">				root.count++;</span><br><span class="line">				<span class="keyword">if</span>(root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">					root.left = <span class="keyword">new</span> Node(val); <span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					root = root.left;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				thisCount += root.count;</span><br><span class="line">				<span class="keyword">if</span>(root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">					root.right = <span class="keyword">new</span> Node(val); <span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					root = root.right;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> thisCount;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 222 - Count Complete Tree Nodes (Binary Search)</title>
    <url>/2020/03/28/leetcode-222/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Count Complete Tree Nodes.</p>
<p>Memory Usage: 42.5 MB, less than 9.76% of Java online submissions for Count Complete Tree Nodes.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(depth), either for dfs when computing depth or Stack.</p>
<p>Time Complexity: O(depth^2), and each checkExist costs  O(depth);</p>
<a id="more"></a>


<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = checkDepth(root);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Binary Search</span></span><br><span class="line">        <span class="keyword">int</span> left = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, depth - <span class="number">1</span>), right = (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, depth) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (checkExist(root, mid)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> checkDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// can also use binary search for checkExist</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkExist</span><span class="params">(TreeNode root, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find parent</span></span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> tmp = mid;</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            path.add(tmp);</span><br><span class="line">            tmp /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode parent = root;</span><br><span class="line">        <span class="keyword">while</span> (path.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(path.pop() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                parent = parent.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                parent = parent.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p> For Saving Space: </p>
<ol>
<li>Use iteration for computing depth</li>
<li>Use binary search for checking existence</li>
</ol>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 341 - Flatten Nested List Iterator</title>
    <url>/2020/04/06/leetcode-341/</url>
    <content><![CDATA[<h2 id="Approach-1-Stack"><a href="#Approach-1-Stack" class="headerlink" title="Approach 1: Stack"></a>Approach 1: Stack</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 9 ms, faster than 6.91% of Java online submissions for Flatten Nested List Iterator.<br>Memory Usage: 43.8 MB, less than 5.00% of Java online submissions for Flatten Nested List Iterator.</p>
<a id="more"></a>


<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * public interface NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     public boolean isInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     public Integer getInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Stack&lt;NestedInteger&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            stack.push(nestedList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop().getInteger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateStack();</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; !stack.peek().isInteger()) &#123;</span><br><span class="line">            List&lt;NestedInteger&gt; nestedList = stack.pop().getList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nestedList.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                stack.push(nestedList.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NestedIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NestedIterator i = new NestedIterator(nestedList);</span></span><br><span class="line"><span class="comment"> * while (i.hasNext()) v[f()] = i.next();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h3 id="To-do"><a href="#To-do" class="headerlink" title="To do"></a>To do</h3><ol>
<li>Optimize Stack</li>
<li>Complexity analysis</li>
</ol>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>LinkedIn</tag>
        <tag>Stack</tag>
        <tag>Apple</tag>
        <tag>Nested</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 373 - Find K Pairs with Smallest Sums</title>
    <url>/2020/04/05/leetcode-373/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 12 ms, faster than 40.95% of Java online submissions for Find K Pairs with Smallest Sums.<br>Memory Usage: 44.8 MB, less than 33.33% of Java online submissions for Find K Pairs with Smallest Sums.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(k), both for result list and priority queue.<br>Time Complexity: O(k*logk), with O(logk) for each insertion to heap.</p>
<a id="more"></a>


<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums1 == <span class="keyword">null</span> || nums2 == <span class="keyword">null</span> || nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k, (o1, o2)-&gt;o1[<span class="number">0</span>] + o1[<span class="number">1</span>] - o2[<span class="number">0</span>] - o2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(nums1.length, k); i++) &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums1[i], nums2[<span class="number">0</span>], <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count &lt; k &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// poll current pair</span></span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">            List&lt;Integer&gt; curList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            curList.add(cur[<span class="number">0</span>]);</span><br><span class="line">            curList.add(cur[<span class="number">1</span>]);</span><br><span class="line">            result.add(curList);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// add potential pair</span></span><br><span class="line">            <span class="keyword">int</span> index2 = cur[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (index2 &lt; nums2.length - <span class="number">1</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;cur[<span class="number">0</span>], nums2[index2 + <span class="number">1</span>], index2 + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>LinkedIn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 450 - Delete Node in a BST</title>
    <url>/2020/05/07/leetcode-450/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>
<p>Basically, the deletion can be divided into two stages:</p>
<ol>
<li>Search for a node to remove.</li>
<li>If the node is found, delete the node.<br>Note: Time complexity should be O(height of tree).</li>
</ol>
<a id="more"></a>

<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// find node</span></span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>, cur = root;</span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.val != key) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur.val &gt; key) &#123; </span><br><span class="line">                cur = cur.left;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cannot find key</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// delete leaf node</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="keyword">null</span> &amp;&amp; cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == root) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// if delete root</span></span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> prev.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// has right child</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == root) <span class="keyword">return</span> cur.right; <span class="comment">// if delete root</span></span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = cur.right;</span><br><span class="line">            <span class="keyword">else</span> prev.right = cur.right;</span><br><span class="line">        <span class="comment">// has right child</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == root) <span class="keyword">return</span> cur.left; <span class="comment">// if delete root</span></span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = cur.left;</span><br><span class="line">            <span class="keyword">else</span> prev.right = cur.left;</span><br><span class="line">        <span class="comment">// has left and right child</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode succesor = findSuccesor(cur);</span><br><span class="line">            succesor.left = cur.left;</span><br><span class="line">            <span class="keyword">if</span> (cur == root) <span class="keyword">return</span> succesor;</span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = succesor;</span><br><span class="line">            <span class="keyword">else</span> prev.right = succesor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">findSuccesor</span><span class="params">(TreeNode toDelete)</span> </span>&#123;</span><br><span class="line">        TreeNode cur = toDelete.right, parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parent = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (cur != toDelete.right) &#123;</span><br><span class="line">            parent.left = cur.right;</span><br><span class="line">            cur.right = toDelete.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Delete Node in a BST.<br>Memory Usage: 39.9 MB, less than 49.86% of Java online submissions for Delete Node in a BST.</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// find node</span></span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>, cur = root;</span><br><span class="line">        <span class="keyword">boolean</span> isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.val != key) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur.val &gt; key) &#123; </span><br><span class="line">                cur = cur.left;</span><br><span class="line">                isLeftChild = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">                isLeftChild = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cannot find key</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// remove node</span></span><br><span class="line">        <span class="keyword">if</span> (cur.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span>) <span class="keyword">return</span> cur.left;</span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = cur.left;</span><br><span class="line">            <span class="keyword">else</span> prev.right = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode nextNodePrev = findNext(cur);</span><br><span class="line">            TreeNode nextNode;</span><br><span class="line">            <span class="comment">// remove nextNode</span></span><br><span class="line">            <span class="keyword">if</span> (nextNodePrev == cur) nextNode = cur.right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nextNode = nextNodePrev.left;</span><br><span class="line">                nextNodePrev.left = nextNode.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// connect with left child of target</span></span><br><span class="line">            nextNode.left = cur.left;</span><br><span class="line">            <span class="comment">// connect with right child of target</span></span><br><span class="line">            <span class="keyword">if</span> (nextNodePrev != cur) nextNode.right = cur.right;</span><br><span class="line">            <span class="comment">// connect with parent</span></span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span>) <span class="keyword">return</span> nextNode; <span class="comment">// remove root;</span></span><br><span class="line">            <span class="keyword">if</span> (isLeftChild) prev.left = nextNode;</span><br><span class="line">            <span class="keyword">else</span> prev.right = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">findNext</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        TreeNode prev = node, cur = node.right;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 380 - Insert Delete GetRandom O(1)</title>
    <url>/2020/04/03/leetcode-380/</url>
    <content><![CDATA[<p>Using ArrayList + HashMap.</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 75.66% of Java online submissions for Insert Delete GetRandom O(1).</p>
<p>Memory Usage: 44.3 MB, less than 94.00% of Java online submissions for Insert Delete GetRandom O(1).</p>
<a id="more"></a>

<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; dataList;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; indexMap; <span class="comment">// &lt;val, index&gt;</span></span><br><span class="line">    <span class="keyword">private</span> Random rand;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        rand = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (indexMap.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dataList.add(val);</span><br><span class="line">        indexMap.put(val, dataList.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (indexMap.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = indexMap.get(val);</span><br><span class="line">            <span class="keyword">int</span> last = dataList.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (last &gt; index) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = dataList.get(last);</span><br><span class="line">                dataList.set(index, tmp);</span><br><span class="line">                indexMap.put(tmp, index);</span><br><span class="line">            &#125;</span><br><span class="line">            dataList.remove(last);</span><br><span class="line">            indexMap.remove(val);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = rand.nextInt(dataList.size());</span><br><span class="line">        <span class="keyword">return</span> dataList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RandomizedSet obj = new RandomizedSet();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.insert(val);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.remove(val);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.getRandom();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>LinkedIn</tag>
        <tag>HashMap</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 430 - Flatten a Multilevel Doubly Linked List (DFS)</title>
    <url>/2020/03/23/leetcode-430/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Flatten a Multilevel Doubly Linked List.<br>Memory Usage: 37.9 MB, less than 72.50% of Java online submissions for Flatten a Multilevel Doubly Linked List.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(depth of child), because of recursion,<br>Time Complexity: O(number of nodes).</p>
<a id="more"></a>

<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node prev;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node child;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">flatten</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node dummy = <span class="keyword">new</span> Node();</span><br><span class="line">        Node tail = dummy;</span><br><span class="line">        dfs(head, tail);</span><br><span class="line">        <span class="keyword">if</span> (dummy.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dummy.next.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">dfs</span><span class="params">(Node head, Node tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> tail;</span><br><span class="line">        <span class="comment">// add itself</span></span><br><span class="line">        Node next = head.next;</span><br><span class="line">        tail.next = head;</span><br><span class="line">        head.prev = tail;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">        <span class="comment">// add child list</span></span><br><span class="line">        tail = dfs(head.child, tail);</span><br><span class="line">        head.child = <span class="keyword">null</span>; <span class="comment">// important!</span></span><br><span class="line">        <span class="comment">// add next node</span></span><br><span class="line">        <span class="keyword">return</span> dfs(next, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 354 - Russian Doll Envelopes</title>
    <url>/2020/04/15/leetcode-354/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.<br>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<a id="more"></a>

<h2 id="Solution-1-Dynamic-Programming"><a href="#Solution-1-Dynamic-Programming" class="headerlink" title="Solution 1: Dynamic Programming"></a>Solution 1: Dynamic Programming</h2><p>dp[i] - length of longest chain until index i</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span></span><br><span class="line">           || envelopes[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> length = envelopes.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[i][<span class="number">0</span>] == envelopes[j][<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-2-Dynamic-Programming-with-Binary-Search"><a href="#Solution-2-Dynamic-Programming-with-Binary-Search" class="headerlink" title="Solution 2: Dynamic Programming with Binary Search"></a>Solution 2: Dynamic Programming with Binary Search</h2><p>dp[i] - height of last envelope in the chain whose length is (i + 1)</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 99.86% of Java online submissions for Russian Doll Envelopes.<br>Memory Usage: 40.2 MB, less than 100.00% of Java online submissions for Russian Doll Envelopes.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(NlogN).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] e1, <span class="keyword">int</span>[] e2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (e1[<span class="number">0</span>] == e2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e2[<span class="number">1</span>] - e1[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> e1[<span class="number">0</span>] - e2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> length = envelopes.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] envelope : envelopes) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = Arrays.binarySearch(dp, <span class="number">0</span>, len, envelope[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = - (i + <span class="number">1</span>);</span><br><span class="line">            dp[i] = envelope[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Hard</tag>
        <tag>Dynamic Programming</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 5 - Longest Palindromic Substring</title>
    <url>/2020/05/09/leetcode-5/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 24 ms, faster than 67.08% of Java online submissions.<br>Memory Usage: 39.9 MB, less than 18.15% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxLength;</span><br><span class="line">    String result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        maxLength = <span class="number">1</span>;</span><br><span class="line">        result = s.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            update(s, i, i);</span><br><span class="line">            update(s, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = i, right = j, curLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == j) curLength = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;=<span class="number">0</span> &amp;&amp; right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) <span class="keyword">break</span>;</span><br><span class="line">            curLength += <span class="number">2</span>;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curLength &gt; maxLength) &#123;</span><br><span class="line">            maxLength = curLength;</span><br><span class="line">            result = s.substring(left + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 56 Merge Intervals &amp; 57 Insert Interval</title>
    <url>/2020/04/10/leetcode-56-57/</url>
    <content><![CDATA[<p>Two similar questions about intervals.</p>
<a id="more"></a>

<h2 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56 Merge Intervals"></a>56 Merge Intervals</h2><p>Given a collection of intervals, merge all overlapping intervals.</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 95.56% of Java online submissions for Merge Intervals.<br>Memory Usage: 42.3 MB, less than 48.55% of Java online submissions for Merge Intervals.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(nlogn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> intervals;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = intervals[<span class="number">0</span>][<span class="number">0</span>], end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; end) &#123; <span class="comment">// no overlap</span></span><br><span class="line">                ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt;= end) &#123; <span class="comment">// included</span></span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// overlap</span></span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, end&#125;);</span><br><span class="line">        <span class="comment">// convert to array</span></span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = ansList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Related-Questions"><a href="#Related-Questions" class="headerlink" title="Related Questions"></a>Related Questions</h3><p>Meeting Room</p>
<h2 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57 Insert Interval"></a>57 Insert Interval</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = intervals[i];</span><br><span class="line">            <span class="keyword">int</span> left = cur[<span class="number">0</span>], right = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(left) &amp;&amp; right &lt; map.get(left)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> map.put(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] newInterval = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.firstEntry().getKey(), map.firstEntry().getValue()&#125;;</span><br><span class="line">        res.add(newInterval);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">                newInterval[<span class="number">1</span>] = Math.max(newInterval[<span class="number">1</span>], map.get(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newInterval = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(i)&#125;;</span><br><span class="line">                res.add(newInterval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Code-and-Result-updated"><a href="#Code-and-Result-updated" class="headerlink" title="Code and Result - updated"></a>Code and Result - updated</h3><p>Runtime: 1 ms, faster than 99.05% of Java online submissions for Insert Interval.<br>Memory Usage: 41.9 MB, less than 41.05% of Java online submissions for Insert Interval.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> inserted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inserted || intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>])</span><br><span class="line">                list.add(intervals[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">                list.add(newInterval);</span><br><span class="line">                inserted = <span class="keyword">true</span>;</span><br><span class="line">                list.add(intervals[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newInterval[<span class="number">0</span>] = Math.min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">                newInterval[<span class="number">1</span>] = Math.max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!inserted) list.add(newInterval);</span><br><span class="line">        <span class="keyword">int</span>[][] ans = list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
        <tag>Facebook</tag>
        <tag>Sort</tag>
        <tag>Intervals</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 659 - Split Array into Consecutive Subsequences</title>
    <url>/2020/05/10/leetcode-659/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array nums sorted in ascending order, return true if and only if you can split it into 1 or more subsequences such that each subsequence consists of consecutive integers and has length at least 3.</p>
<p><strong>Similar Questions</strong><br>LeetCode 846 - Hand of Straights<br>LeetCode 1296 - Divide Array in Sets of K Consecutive Numbers</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 22 ms, faster than 64.77% of Java online submissions.<br>Memory Usage: 41 MB, less than 94.44% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossible</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; chainfreq = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) freqMap.put(i, freqMap.getOrDefault(i,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freqMap.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (chainfreq.getOrDefault(i,<span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                chainfreq.put(i, chainfreq.get(i) - <span class="number">1</span>);</span><br><span class="line">                chainfreq.put(i+<span class="number">1</span>, chainfreq.getOrDefault(i+<span class="number">1</span>,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freqMap.getOrDefault(i+<span class="number">1</span>,<span class="number">0</span>) &gt; <span class="number">0</span> &amp;&amp; freqMap.getOrDefault(i+<span class="number">2</span>,<span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                freqMap.put(i+<span class="number">1</span>, freqMap.get(i+<span class="number">1</span>) - <span class="number">1</span>);</span><br><span class="line">                freqMap.put(i+<span class="number">2</span>, freqMap.get(i+<span class="number">2</span>) - <span class="number">1</span>);</span><br><span class="line">                chainfreq.put(i+<span class="number">3</span>, chainfreq.getOrDefault(i+<span class="number">3</span>,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            freqMap.put(i, freqMap.get(i) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 692 - Top K Frequent Words</title>
    <url>/2020/05/05/leetcode-692/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a non-empty list of words, return the k most frequent elements.</p>
<p>Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 88.29% of Java online submissions.<br>Memory Usage: 39.7 MB, less than 41.07% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">topKFrequent</span><span class="params">(String[] words, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (freqMap.get(a) == freqMap.get(b)) <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">                <span class="keyword">return</span> freqMap.get(a) - freqMap.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = freqMap.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            freqMap.put(word, count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String word : freqMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &lt; k) &#123;</span><br><span class="line">                queue.add(word);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freqMap.get(word) &gt;= freqMap.get(queue.peek())) &#123;</span><br><span class="line">                queue.add(word);</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        LinkedList&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            result.addFirst(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>PriorityQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 698 - Partition to K Equal Sum Subsets</title>
    <url>/2020/04/05/leetcode-698/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 93.45% of Java online submissions for Partition to K Equal Sum Subsets.<br>Memory Usage: 37.2 MB, less than 9.30% of Java online submissions for Partition to K Equal Sum Subsets.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), because of recursion.<br>Time Complexity: O(N), O(k^(N−k) * k!), N is the length of nums, and k is as given. </p>
<a id="more"></a>

<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> target = sum / k;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> start = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[start] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// skip (num == target)</span></span><br><span class="line">        <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; nums[start] == target) &#123;</span><br><span class="line">            k--;</span><br><span class="line">            start--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fill in k groups from the end of array</span></span><br><span class="line">        <span class="keyword">return</span> search(<span class="keyword">new</span> <span class="keyword">int</span>[k], nums, start, target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] groups, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cur = nums[start];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; groups.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (groups[i] + cur &lt;= target) &#123;</span><br><span class="line">                groups[i] += cur;</span><br><span class="line">                <span class="keyword">if</span> (search(groups, nums, start - <span class="number">1</span>, target)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                groups[i] -= cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (groups[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Another-Approach-Dynamic-Programming"><a href="#Another-Approach-Dynamic-Programming" class="headerlink" title="Another Approach: Dynamic Programming"></a>Another Approach: Dynamic Programming</h3><p>To be continued.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 75 - Sort Colors</title>
    <url>/2020/05/10/leetcode-75/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.<br>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.<br>Note: You are not suppose to use the library’s sort function for this problem.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions.<br>Memory Usage: 38.3 MB, less than 5.51% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos0 = <span class="number">0</span>, pos2 = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= pos2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, pos0++, i++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums, pos2--, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[x];</span><br><span class="line">        nums[x] = nums[y];</span><br><span class="line">        nums[y] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 743 - Network Delay Time</title>
    <url>/2020/04/29/leetcode-743/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>There are N network nodes, labelled 1 to N.</p>
<p>Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.</p>
<p>Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 31 ms, faster than 31.17% of Java online submissions.<br>Memory Usage: 43 MB, less than 90.48% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; timeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] time : times)&#123;</span><br><span class="line">            timeMap.putIfAbsent(time[<span class="number">0</span>], <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            timeMap.get(time[<span class="number">0</span>]).put(time[<span class="number">1</span>], time[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[N+<span class="number">1</span>];</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, K&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = queue.remove();</span><br><span class="line">            <span class="keyword">int</span> curNode = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> curDist = cur[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(visited[curNode]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[curNode] = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (timeMap.containsKey(curNode)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> nextNode : timeMap.get(curNode).keySet()) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;curDist + timeMap.get(curNode).get(nextNode), nextNode&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = curDist;</span><br><span class="line">            N--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span> ? result : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 752 - Open the Lock</title>
    <url>/2020/04/23/leetcode-752/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’. The wheels can rotate freely and wrap around: for example we can turn ‘9’ to be ‘0’, or ‘0’ to be ‘9’. Each move consists of turning one wheel one slot.</p>
<p>The lock initially starts at ‘0000’, a string representing the state of the 4 wheels.</p>
<p>You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.</p>
<p>Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 60 ms, faster than 84.56% of Java online submissions.<br>Memory Usage: 42.9 MB, less than 84.21% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time Complexity: O(N^2 * A^N + D) where A is the number of digits in our alphabet, N is the number of digits in the lock, and D is the size of deadends. We might visit every lock combination, plus we need to instantiate our set dead. When we visit every lock combination, we spend O(N^2) time enumerating through and constructing each node.<br>Space Complexity: O(A^N + D), for the queue and the set dead.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; endSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : deadends) &#123;</span><br><span class="line">            endSet.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="string">"0000"</span>);</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        visited.add(<span class="string">"0000"</span>);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String s = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (endSet.contains(s)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.equals(target)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span>[] curLock = s.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> tmp = curLock[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = -<span class="number">1</span>; j &lt;= <span class="number">1</span>; j+=<span class="number">2</span>) &#123;</span><br><span class="line">                        curLock[i] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + ((tmp - <span class="string">'0'</span>) + <span class="number">10</span> + j) % <span class="number">10</span>);</span><br><span class="line">                        String newS = <span class="keyword">new</span> String(curLock);</span><br><span class="line">                        <span class="keyword">if</span> (!visited.contains(newS)) &#123;</span><br><span class="line">                            queue.offer(newS);</span><br><span class="line">                            visited.add(newS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curLock[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 846 - Hand of Straights &amp;&amp; LeetCode 1296 - Divide Array in Sets of K Consecutive Numbers</title>
    <url>/2020/04/22/leetcode-846/</url>
    <content><![CDATA[<h2 id="LeetCode-846-Hand-of-Straights"><a href="#LeetCode-846-Hand-of-Straights" class="headerlink" title="LeetCode 846 - Hand of Straights"></a>LeetCode 846 - Hand of Straights</h2><p><strong>Similar Questions</strong><br>659 - Split Array into Consecutive Subsequences<br>1296 - Divide Array in Sets of K Consecutive Numbers</p>
<p><strong>Description</strong><br>Alice has a hand of cards, given as an array of integers.</p>
<p>Now she wants to rearrange the cards into groups so that each group is size W, and consists of W consecutive cards.</p>
<p>Return true if and only if she can.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 58 ms, faster than 26.43% of Java online submissions.<br>Memory Usage: 41.6 MB.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNStraightHand</span><span class="params">(<span class="keyword">int</span>[] hand, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hand==<span class="keyword">null</span> || hand.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(hand.length%W != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Convert the given hand into a TreeMap of &lt;Hand,Frequency&gt;</span></span><br><span class="line">        TreeMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : hand)</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);    </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Delete groups of size W from TreeMap</span></span><br><span class="line">        <span class="keyword">while</span>(!map.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curr=map.firstKey();</span><br><span class="line">            updateTreeMap(map,curr);</span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(count!=W)</span><br><span class="line">            &#123;</span><br><span class="line">                Map.Entry&lt;Integer,Integer&gt; next=map.higherEntry(curr);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(next==<span class="keyword">null</span> || next.getKey()-curr != <span class="number">1</span>) </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    updateTreeMap(map,next.getKey());</span><br><span class="line">                    curr=next.getKey();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTreeMap</span><span class="params">(TreeMap&lt;Integer,Integer&gt; map,<span class="keyword">int</span> curr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        map.put(curr,map.get(curr)-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(map.get(curr)==<span class="number">0</span>) </span><br><span class="line">            map.remove(curr);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode-1296-Divide-Array-in-Sets-of-K-Consecutive"><a href="#LeetCode-1296-Divide-Array-in-Sets-of-K-Consecutive" class="headerlink" title="LeetCode 1296 - Divide Array in Sets of K Consecutive"></a>LeetCode 1296 - Divide Array in Sets of K Consecutive</h2><p><strong>Description</strong><br>Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into sets of k consecutive numbers<br>Return True if its possible otherwise return False.</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 135 ms, faster than 49.21% of Java online submissions for Divide Array in Sets of K Consecutive Numbers.<br>Memory Usage: 54 MB, less than 100.00% of Java online submissions for Divide Array in Sets of K Consecutive Numbers.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPossibleDivide</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k &lt;= <span class="number">0</span> || nums.length % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = freqMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            freqMap.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!freqMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            Integer num = freqMap.firstKey();</span><br><span class="line">            <span class="keyword">while</span> (count++ &lt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!freqMap.containsKey(num)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                updateMap(freqMap, num++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateMap</span><span class="params">(TreeMap&lt;Integer, Integer&gt; freqMap, Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldFreq = freqMap.get(num);</span><br><span class="line">        <span class="keyword">if</span> (oldFreq == <span class="number">1</span>) freqMap.remove(num);</span><br><span class="line">        <span class="keyword">else</span> freqMap.put(num, oldFreq - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 862 - Shortest Subarray with Sum at Least K</title>
    <url>/2020/04/12/leetcode-862/</url>
    <content><![CDATA[<h2 id="Sliding-window"><a href="#Sliding-window" class="headerlink" title="Sliding window"></a>Sliding window</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 17 ms, faster than 94.20% of Java online submissions for Shortest Subarray with Sum at Least K .<br>Memory Usage:50 MB, less than 100.00% of Java online submissions for Shortest Subarray with Sum at Least K .</p>
<a id="more"></a>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N).<br>Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sums.length; i++) &#123;</span><br><span class="line">            sums[i] = A[i - <span class="number">1</span>] + sums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ascending linkedlist</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (list.size() &gt; <span class="number">0</span> &amp;&amp; sums[i] &lt;= sums[list.peekLast()]) &#123;</span><br><span class="line">                list.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (list.size() &gt; <span class="number">0</span> &amp;&amp; sums[i] - sums[list.peekFirst()] &gt;= K) &#123;</span><br><span class="line">                result = Math.min(result, i - list.removeFirst());</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? -<span class="number">1</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>LinkedIn</tag>
        <tag>Sliding Window</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 81 - Search in Rotated Sorted Array II (Binary Search)</title>
    <url>/2020/04/13/leetcode-81/</url>
    <content><![CDATA[<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Search in Rotated Sorted Array II.<br>Memory Usage: 39.4 MB, less than 54.93% of Java online submissions for Search in Rotated Sorted Array II.</p>
<a id="more"></a>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1).<br>Time Complexity: O(logN).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// if left part is sorted</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[start]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// if right part is sorted</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[start]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt; nums[start]) &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 994 - Rotting Oranges</title>
    <url>/2020/05/02/leetcode-994/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>In a given grid, each cell can have one of three values:<br>    the value 0 representing an empty cell;<br>    the value 1 representing a fresh orange;<br>    the value 2 representing a rotten orange.</p>
<p>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>
<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 97.55% of Java online submissions.<br>Memory Usage: 39 MB, less than 81.25% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;Integer&gt; rottens = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> freshNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) freshNum++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = i * <span class="number">100</span> + j;</span><br><span class="line">                    rottens.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> timer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] direction = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!rottens.isEmpty()) &#123;</span><br><span class="line">            timer++;</span><br><span class="line">            <span class="keyword">int</span> count = rottens.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = rottens.poll();</span><br><span class="line">                <span class="keyword">int</span> row = num / <span class="number">100</span>, col = num % <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmpRow = row + direction[i][<span class="number">0</span>], tmpCol = col + direction[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (tmpRow &lt; <span class="number">0</span> || tmpCol &lt; <span class="number">0</span> || tmpRow &gt;= m || tmpCol &gt;= n)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[tmpRow][tmpCol] == <span class="number">1</span>) &#123;</span><br><span class="line">                        freshNum--;</span><br><span class="line">                        grid[tmpRow][tmpCol] = <span class="number">2</span>;</span><br><span class="line">                        rottens.add(tmpRow * <span class="number">100</span> + tmpCol);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (freshNum == <span class="number">0</span>) <span class="keyword">return</span> timer == <span class="number">0</span> ? <span class="number">0</span> : timer - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 939 - Minimum Area Rectangle</title>
    <url>/2020/05/10/leetcode-939/</url>
    <content><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes.</p>
<p>If there isn’t any rectangle, return 0.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 196 ms, faster than 69.12% of Java online submissions.<br>Memory Usage: 58.6 MB, less than 15.00% of Java online submissions.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAreaRect</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, TreeSet&lt;Integer&gt;&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point : points) &#123;</span><br><span class="line">            TreeSet&lt;Integer&gt; set = map.getOrDefault(point[<span class="number">0</span>], <span class="keyword">new</span> TreeSet&lt;&gt;());</span><br><span class="line">            set.add(point[<span class="number">1</span>]);</span><br><span class="line">            map.put(point[<span class="number">0</span>], set);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (Integer x : map.keySet()) &#123;</span><br><span class="line">            Integer curX = x;</span><br><span class="line">            Integer nextX = map.higherKey(curX);</span><br><span class="line">            <span class="keyword">int</span> curArea = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (nextX != <span class="keyword">null</span> &amp;&amp; curArea == Integer.MAX_VALUE) &#123;</span><br><span class="line">                TreeSet&lt;Integer&gt; curYs = map.get(curX);</span><br><span class="line">                TreeSet&lt;Integer&gt; nextYs = map.get(nextX);</span><br><span class="line">                <span class="keyword">for</span> (Integer curY1 : curYs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!nextYs.contains(curY1)) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (Integer curY2 = curYs.higher(curY1); curY2 != <span class="keyword">null</span>; curY2 = curYs.higher(curY2)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (curArea != Integer.MAX_VALUE) <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">if</span> (nextYs.contains(curY2)) &#123;</span><br><span class="line">                            curArea = (nextX - curX) * (curY2 - curY1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                nextX = map.higherKey(nextX);</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.min(result, curArea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return result == Integer.MAX_VALUE ? 0 : result;</span></span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; rows = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point: points) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            rows.computeIfAbsent(x, z-&gt; <span class="keyword">new</span> ArrayList()).add(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line">        Map&lt;Integer, Integer&gt; lastx = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: rows.keySet()) &#123;</span><br><span class="line">            List&lt;Integer&gt; row = rows.get(x);</span><br><span class="line">            Collections.sort(row);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.size(); ++i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; row.size(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> y1 = row.get(i), y2 = row.get(j);</span><br><span class="line">                    <span class="keyword">int</span> code = <span class="number">40001</span> * y1 + y2;</span><br><span class="line">                    <span class="keyword">if</span> (lastx.containsKey(code))</span><br><span class="line">                        ans = Math.min(ans, (x - lastx.get(code)) * (y2-y1));</span><br><span class="line">                    lastx.put(code, x);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &lt; Integer.MAX_VALUE ? ans : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Deploy Vue Project to Nginx on Ubuntu 18.04</title>
    <url>/2020/03/16/vue-ubuntu/</url>
    <content><![CDATA[<p>Build and deploy vue.js project to Ubuntu 18.04 (Cloud Instance on Vultr).</p>
<a id="more"></a>

<h2 id="Nginx-on-Ubuntu-18-04"><a href="#Nginx-on-Ubuntu-18-04" class="headerlink" title="Nginx on Ubuntu 18.04"></a>Nginx on Ubuntu 18.04</h2><ol>
<li><p>Install Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>Check status</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>Test</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;your_server_ip</span><br></pre></td></tr></table></figure>

<p>You should see the default Nginx landing page:</p>
<p><img src="https://assets.digitalocean.com/articles/nginx_1604/default_page.png" alt="Nginx default page"></p>
<p>This page is included with Nginx to show you that the server is running correctly.</p>
</li>
<li><p>mkdir for vue project</p>
<p>mkdir in the default directory of nginx to avoid potential “permission denied” problem.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;www&#x2F;</span><br><span class="line">mkdir vue</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="Build-and-Deploy-VueJS-Project"><a href="#Build-and-Deploy-VueJS-Project" class="headerlink" title="Build and Deploy VueJS Project"></a>Build and Deploy VueJS Project</h2><ol>
<li><p>Build on local machine (or server)</p>
<p>cd into root directory of your vue project</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>“dist” directory should be generated if successfully.</p>
</li>
<li><p>Push “dist” to server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp -r &#123;your_local_root_dir&#125;&#x2F;dist root@your_server_ip:&#123;&#x2F;var&#x2F;www&#x2F;vue&#x2F;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Edit configuration file on server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;default</span><br></pre></td></tr></table></figure>

<p>change root to “/var/www/vue/dist”</p>
<p>You can also create new configuration file.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo touch &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;vue_project</span><br><span class="line">sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;vue_project &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;vue_project</span><br><span class="line">sudo vim &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;vue_project</span><br></pre></td></tr></table></figure>
</li>
<li><p>Test and restart nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>

<p>visit <a href="http://your_server_ip" target="_blank" rel="noopener">http://your_server_ip</a> again for confirmation.</p>
<p>​</p>
</li>
</ol>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol>
<li>“No firewall” set on vultr, or adjust it with “ufw”.</li>
<li>Set enough RAM for the server, especially if you want to build the project on server instead of local machine.</li>
</ol>
<h3 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h3><p>Design and CI</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[<a href="https://www.cyberciti.biz/faq/install-and-configure-nginx-on-ubuntu-linux-18-04-lts/]" target="_blank" rel="noopener">https://www.cyberciti.biz/faq/install-and-configure-nginx-on-ubuntu-linux-18-04-lts/]</a>(Install and Configure Nginx on Ubuntu Linux 18.04 LTS)</p>
<p>[<a href="https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04]" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04]</a>(How To Install Nginx on Ubuntu 18.04)</p>
<p>[<a href="https://thewebtier.com/web/setup-vuejs-app-on-ubuntu-server/]" target="_blank" rel="noopener">https://thewebtier.com/web/setup-vuejs-app-on-ubuntu-server/]</a>(Setup VueJS app on Ubuntu Server)</p>
<p>[<a href="https://medium.com/@thucnc/deploy-a-vuejs-web-app-with-nginx-on-ubuntu-18-04-f93860219030]" target="_blank" rel="noopener">https://medium.com/@thucnc/deploy-a-vuejs-web-app-with-nginx-on-ubuntu-18-04-f93860219030]</a>(Deploy a VueJS web app with nginx on Ubuntu 18.04)</p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Reading</title>
    <url>/2020/05/11/reading/</url>
    <content><![CDATA[<h2 id="In-Progress"><a href="#In-Progress" class="headerlink" title="In Progress"></a>In Progress</h2><p>《历史深处的忧虑》<br>《许三观卖血记》</p>
<a id="more"></a>

<h2 id="Marked"><a href="#Marked" class="headerlink" title="Marked"></a>Marked</h2><p>《人类简史》<br>《树上的男爵》<br>《万历十五年》<br>《夏目友人帐》 村井贞之<br>《清醒思考的艺术》 【德】罗尔夫·多贝里</p>
<h2 id="Completed"><a href="#Completed" class="headerlink" title="Completed"></a>Completed</h2><p>《我们仨》杨绛 - 虽然是一个人怀念我们仨，看到的也大多是快乐<br>《边城》沈从文<br>《Rich Daddy, Poor Daddy》 [US]Robert Kiyosaki, Sharon Lechter<br>《玛格丽特小镇》<br>《岛上书店》 加·泽文<br>《你今天真好看》 【美】利兹·克里莫<br>《解忧杂货店》 东野圭吾<br>《24个比利》 丹尼尔·凯斯<br>《三体》 刘慈欣<br>《黄金时代》 王小波<br>《无声告白》<br>《阿弥陀佛么么哒》 大冰<br>《目送》 龙应台<br>《福尔摩斯探案全集》 Conan Doyle A.</p>
<h2 id="Aborted"><a href="#Aborted" class="headerlink" title="Aborted"></a>Aborted</h2><p>《目标中国.华盛顿的“屠龙”战略》【美】威廉·恩道尔</p>
<p><strong>To Be Continued…</strong></p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1 - Two Sum (Array &amp; HashMap)</title>
    <url>/2020/03/17/leetcode-TwoSum/</url>
    <content><![CDATA[<h3 id="Approach-1-Array"><a href="#Approach-1-Array" class="headerlink" title="Approach 1: Array"></a>Approach 1: Array</h3><p>Space Complexity: O(1), Time Complexity: O(N^2).</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No valid result"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Approach-2-HashMap"><a href="#Approach-2-HashMap" class="headerlink" title="Approach 2: HashMap"></a>Approach 2: HashMap</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(diff)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(diff), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No valid result."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Operations</title>
    <url>/2020/04/05/hexo-basic/</url>
    <content><![CDATA[<h3 id="Basic-workflow-基本操作"><a href="#Basic-workflow-基本操作" class="headerlink" title="Basic workflow 基本操作"></a>Basic workflow 基本操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<h3 id="New-page-post-draft-新建内容"><a href="#New-page-post-draft-新建内容" class="headerlink" title="New page/post/draft 新建内容"></a>New page/post/draft 新建内容</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page page-name</span><br><span class="line">hexo new draft draft-name</span><br><span class="line">hexo new post post-name</span><br><span class="line">hexo publish draft draft-name.md</span><br></pre></td></tr></table></figure>



<h3 id="Show-abstract-on-Home-page-首页显示摘要"><a href="#Show-abstract-on-Home-page-首页显示摘要" class="headerlink" title="Show abstract on Home page 首页显示摘要"></a>Show abstract on Home page 首页显示摘要</h3><p>use <a id="more"></a> to separate abstract and the context.</p>
<p>For example,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Basic Configuration For A New Ubuntu Server</span><br><span class="line">date: 2020-04-03 13:09:10</span><br><span class="line">---</span><br><span class="line">This is abstract.</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">More details.</span><br></pre></td></tr></table></figure>



<h3 id="Sticky-posts-置顶"><a href="#Sticky-posts-置顶" class="headerlink" title="Sticky posts 置顶"></a>Sticky posts 置顶</h3><ol>
<li>Install related repositories</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Add <code>top: true</code> to <code>Front-matter</code>. </p>
<p>Example:</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: post</span><br><span class="line">title: 懒人做法实践之路</span><br><span class="line">date: 2020-03-17 17:04:34</span><br><span class="line">tags: food</span><br><span class="line">categories: life</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>



<p>Optional:</p>
<ol start="3">
<li>Show “Sticky”</li>
</ol>
<p>Open <code>post.swig</code> in <code>/blog/themes/next/layout/_macro</code>, add the following code below <code>&lt;div class=&quot;post-meta&quot;&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;Sticky&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>Reference: </p>
<p>Hexo博客彻底解决置顶问题 <a href="http://wangwlj.com/2018/01/09/blog_pin_post/" target="_blank" rel="noopener">http://wangwlj.com/2018/01/09/blog_pin_post/</a></p>
<h3 id="Loacal-Search添加搜索功能"><a href="#Loacal-Search添加搜索功能" class="headerlink" title="Loacal Search添加搜索功能"></a>Loacal Search添加搜索功能</h3><ol>
<li>Install</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Global configuration in  <code>blog/_config.yml</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Next configuration in <code>blog/themes/next/_config.yml</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>

<p>Redeploy.</p>
<p>Reference: <a href="https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/" target="_blank" rel="noopener">https://yashuning.github.io/2018/06/29/hexo-Next-%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</a></p>
]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode - Backtracking</title>
    <url>/2019/10/14/leetcode-backtracking/</url>
    <content><![CDATA[<p><strong>Problem List</strong><br>46.Permutations<br>47.Permutations II<br>39.Combination Sum<br>40.Combination Sum II</p>
<a id="more"></a>

<h2 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h2><p><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        helper(res, nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; list, <span class="keyword">int</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                helper(res, nums, list, visited.clone());</span><br><span class="line">                visited[i] = <span class="number">0</span>;</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h2><p><a href="https://leetcode.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations-ii/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        helper(res, nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, <span class="keyword">int</span>[] nums, List&lt;Integer&gt; list, <span class="keyword">int</span>[] visited)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; visited[i-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>  (visited[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            visited[i] = <span class="number">1</span>;</span><br><span class="line">            helper(res, nums, list, visited.clone());</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h2><p><a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) 	&#123;</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        helper(candidates, target, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            helper(candidates, target - candidates[i], i, list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h2><p><a href="https://leetcode.com/problems/combination-sum-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/combination-sum-ii/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span> || candidates.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        helper(res, <span class="keyword">new</span> ArrayList&lt;&gt;(), candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; start &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// skip duplicates</span></span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                helper(res, list, candidates, target - candidates[i], i + <span class="number">1</span>);</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 300 - Longest Increasing Subsequence</title>
    <url>/2020/05/11/leetcode-300/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Related question: Leetcode 354 - Russian Doll Envelopes</p>
<a id="more"></a>

<h2 id="Solution-one-Dynamic-Programming"><a href="#Solution-one-Dynamic-Programming" class="headerlink" title="Solution one: Dynamic Programming"></a>Solution one: Dynamic Programming</h2><p>dp[i] - length of LIS until index i</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 12 ms, faster than 37.91% of Java online submissions for Longest Increasing Subsequence.<br>Memory Usage: 37.5 MB, less than 34.00% of Java online submissions for Longest Increasing Subsequence.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(dp[i], result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-Dynamic-Programming-with-Binary-Search"><a href="#Solution-Two-Dynamic-Programming-with-Binary-Search" class="headerlink" title="Solution Two: Dynamic Programming with Binary Search"></a>Solution Two: Dynamic Programming with Binary Search</h2><p>dp[i] - last number of valid chain whose length is (i + 1)<br>Reference: <a href="https://segmentfault.com/a/1190000003819886" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003819886</a></p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Longest Increasing Subsequence.<br>Memory Usage: 37.5 MB, less than 34.00% of Java online submissions for Longest Increasing Subsequence.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(NlogN).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp with binary search</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// if not found, return (- toIndex - 1)</span></span><br><span class="line">            <span class="keyword">int</span> i = Arrays.binarySearch(dp, <span class="number">0</span>, len, num);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) i = - (i + <span class="number">1</span>);</span><br><span class="line">            dp[i] = num;</span><br><span class="line">            <span class="keyword">if</span> (i == len) len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 23 - Merge k Sorted Lists</title>
    <url>/2020/05/11/leetcode-23/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<a id="more"></a>

<h2 id="Solution-One-PriorityQueue"><a href="#Solution-One-PriorityQueue" class="headerlink" title="Solution One: PriorityQueue"></a>Solution One: PriorityQueue</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 46.82% of Java online submissions for Merge k Sorted Lists.<br>Memory Usage: 41.4 MB, less than 40.44% of Java online submissions for Merge k Sorted Lists.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(NlogK).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;ListNode&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.val - o2.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tmp = dummy;</span><br><span class="line">        <span class="keyword">for</span> (ListNode head : lists) &#123;</span><br><span class="line">            <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(head);</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            tmp.next = queue.poll();</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-Merge-Sort"><a href="#Solution-Two-Merge-Sort" class="headerlink" title="Solution Two: Merge Sort"></a>Solution Two: Merge Sort</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 763 - Partition Labels</title>
    <url>/2020/05/13/leetcode-763/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.</p>
<h2 id="Solution-One-Merge-Intervals"><a href="#Solution-One-Merge-Intervals" class="headerlink" title="Solution One - Merge Intervals"></a>Solution One - Merge Intervals</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">// get intervals</span></span><br><span class="line">        <span class="keyword">int</span>[] start = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(start, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span>[] end = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        Arrays.fill(end, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = S.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (start[cur - <span class="string">'a'</span>] == -<span class="number">1</span>) start[cur - <span class="string">'a'</span>] = i;</span><br><span class="line">            <span class="keyword">else</span> end[cur - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">                map.put(start[i], end[i] == -<span class="number">1</span> ? start[i] : end[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// merge intervals</span></span><br><span class="line">        <span class="keyword">while</span> (!map.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = map.firstKey();</span><br><span class="line">            <span class="keyword">int</span> right = map.get(left);</span><br><span class="line">            map.remove(left);</span><br><span class="line">            Integer mid = map.lowerKey(right);</span><br><span class="line">            <span class="keyword">while</span> (mid != <span class="keyword">null</span>) &#123;</span><br><span class="line">                right = Math.max(right, map.get(mid));</span><br><span class="line">                map.remove(mid);</span><br><span class="line">                mid = map.lowerKey(right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-Greedy-Good"><a href="#Solution-Two-Greedy-Good" class="headerlink" title="Solution Two - Greedy (Good)"></a>Solution Two - Greedy (Good)</h2><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i)</span><br><span class="line">            last[S.charAt(i) - <span class="string">'a'</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>, anchor = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i) &#123;</span><br><span class="line">            j = Math.max(j, last[S.charAt(i) - <span class="string">'a'</span>]);</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                ans.add(i - anchor + <span class="number">1</span>);</span><br><span class="line">                anchor = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1239 - Maximum Length of a Concatenated String with Unique Characters</title>
    <url>/2020/05/18/leetcode-1239/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of strings arr. String s is a concatenation of a sub-sequence of arr which have unique characters.</p>
<p>Return the maximum possible length of s.</p>
<h2 id="Solution-One-Backtracking"><a href="#Solution-One-Backtracking" class="headerlink" title="Solution One: Backtracking"></a>Solution One: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 78 ms, faster than 20.33% of Java online submissions.<br>Memory Usage: 51.3 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n^3), Time Complexity: O(n^2 * string length).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxLength</span><span class="params">(List&lt;String&gt; arr)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; path = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;Set&lt;Character&gt;&gt; arrList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s: arr) &#123;</span><br><span class="line">            Set&lt;Character&gt; set = isUniqueChars(s);</span><br><span class="line">            <span class="keyword">if</span> (set != <span class="keyword">null</span>) arrList.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, arrList, <span class="keyword">new</span> HashSet&lt;Character&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, List&lt;Set&lt;Character&gt;&gt; arrList, Set&lt;Character&gt; path, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        result = Math.max(result, length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; arrList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// skip or not</span></span><br><span class="line">            Set&lt;Character&gt; set = arrList.get(i);</span><br><span class="line">            <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : set) &#123;</span><br><span class="line">                <span class="keyword">if</span> (path.contains(c)) valid = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                path.addAll(set);</span><br><span class="line">                dfs(i + <span class="number">1</span>, arrList, path, length + set.size());</span><br><span class="line">                path.removeAll(set);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Set&lt;Character&gt; <span class="title">isUniqueChars</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 140 - Word Break II</title>
    <url>/2020/05/22/leetcode-140/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>Note:<br>1.The same word in the dictionary may be reused multiple times in the segmentation.<br>2.You may assume the dictionary does not contain duplicate words.</p>
<a id="more"></a>
<h2 id="Solution-Recursion-with-memorization"><a href="#Solution-Recursion-with-memorization" class="headerlink" title="Solution: Recursion with memorization"></a>Solution: Recursion with memorization</h2><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n^3). The depth of the recursion tree can go up to n and each activation record can contains a string list of size n.<br>Time Complexity: O(n^3). Size of recursion tree can go up to n^2. The creation of list takes n time.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word: wordDict) set.add(word);</span><br><span class="line">        <span class="keyword">return</span> word_Break(s, set, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">word_Break</span><span class="params">(String s, Set&lt;String&gt; wordDict, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(start)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(start);</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) &#123;</span><br><span class="line">            res.add(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> end = start + <span class="number">1</span>; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wordDict.contains(s.substring(start, end))) &#123;</span><br><span class="line">                List&lt;String&gt; list = word_Break(s, wordDict, end);</span><br><span class="line">                <span class="keyword">for</span> (String l : list) &#123;</span><br><span class="line">                    res.add(s.substring(start, end) + (l.equals(<span class="string">""</span>) ? <span class="string">""</span> : <span class="string">" "</span>) + l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(start, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>Reduce runtime complexity in the tradeoff of saving middle result in a map.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 212 - Word Search II</title>
    <url>/2020/05/09/leetcode-212/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a 2D board and a list of words from the dictionary, find all words in the board.</p>
<p>Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p>
<h2 id="Solution-One-Backtracking"><a href="#Solution-One-Backtracking" class="headerlink" title="Solution One: Backtracking"></a>Solution One: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 646 ms, faster than 11.27% of Java online submissions.<br>Memory Usage: 41.8 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(rowNum * colNum), Time Complexity: O(rowNum * colNum).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowNum, colNum;</span><br><span class="line">    Set&lt;String&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rowNum = board.length;</span><br><span class="line">        colNum = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// record position of each character</span></span><br><span class="line">        Map&lt;Character, List&lt;<span class="keyword">int</span>[]&gt;&gt; posMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">                List&lt;<span class="keyword">int</span>[]&gt; list = posMap.getOrDefault(board[i][j], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                posMap.put(board[i][j], list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find word</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] pos: posMap.getOrDefault(word.charAt(<span class="number">0</span>), <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;())) &#123;</span><br><span class="line">                search(board, word, <span class="number">0</span>, pos[<span class="number">0</span>], pos[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        ans.addAll(result);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] board, String word, <span class="keyword">int</span> start, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length()) &#123;</span><br><span class="line">            result.add(word);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; <span class="number">0</span> || col &lt; <span class="number">0</span> || row &gt;= rowNum || col &gt;= colNum) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span> old = board[row][col];</span><br><span class="line">        <span class="keyword">if</span> (old != word.charAt(start)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[row][col] = <span class="string">'1'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="keyword">if</span>(search(board, word, start + <span class="number">1</span>, row + direction[<span class="number">0</span>], col + direction[<span class="number">1</span>])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[row][col] = old;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Backtracking-with-Trie"><a href="#Solution-Two-Backtracking-with-Trie" class="headerlink" title="Solution Two: Backtracking with Trie"></a>Solution Two: Backtracking with Trie</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 25 - Reverse Nodes in k-Group</title>
    <url>/2020/05/21/leetcode-25/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p>
<p>Example:</p>
<p>Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5<br>For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5<br>For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5</p>
<p>Note:</p>
<ol>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ol>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 26.41% of Java online submissions.<br>Memory Usage: 42.8 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode lastTail = dummy, curTail = dummy;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (count++ &lt; k) &#123;</span><br><span class="line">            curTail = curTail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode curHead = lastTail.next;</span><br><span class="line">            reverse(lastTail, curHead, k);</span><br><span class="line">            lastTail = curHead;</span><br><span class="line">            curTail = lastTail;</span><br><span class="line">            </span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (curTail != <span class="keyword">null</span> &amp;&amp; count++ &lt; k) &#123;</span><br><span class="line">                curTail = curTail.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode lastTail, ListNode head, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head.next, pre = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; count++ &lt; length) &#123;</span><br><span class="line">            ListNode curHead = lastTail.next;</span><br><span class="line">            ListNode next = cur.next;</span><br><span class="line">            lastTail.next = cur;</span><br><span class="line">            cur.next = curHead;</span><br><span class="line">            pre.next = next;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 42 - Trapping Rain Water</title>
    <url>/2020/05/14/leetcode-42/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>
<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 91.88% of Java online submissions.<br>Memory Usage: 39 MB, less than 37.67% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] max1 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span> max = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            max = Math.max(max, height[i]);</span><br><span class="line">            max1[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        max = height[length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            max = Math.max(max, height[i]);</span><br><span class="line">            result += (Math.min(max1[i], max) - height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 809 - Expressive Words</title>
    <url>/2020/05/21/leetcode-809/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Sometimes people repeat letters to represent extra feeling, such as “hello” -&gt; “heeellooo”, “hi” -&gt; “hiiii”.  In these strings like “heeellooo”, we have groups of adjacent letters that are all the same:  “h”, “eee”, “ll”, “ooo”.</p>
<p>For some given string S, a query word is stretchy if it can be made to be equal to S by any number of applications of the following extension operation: choose a group consisting of characters c, and add some number of characters c to the group so that the size of the group is 3 or more.</p>
<p>For example, starting with “hello”, we could do an extension on the group “o” to get “hellooo”, but we cannot get “helloo” since the group “oo” has size less than 3.  Also, we could do another extension like “ll” -&gt; “lllll” to get “helllllooo”.  If S = “helllllooo”, then the query word “hello” would be stretchy because of these two extension operations: query = “hello” -&gt; “hellooo” -&gt; “helllllooo” = S.</p>
<p>Given a list of query words, return the number of words that are stretchy. </p>
<h2 id="Solution-Run-Length-Encoding"><a href="#Solution-Run-Length-Encoding" class="headerlink" title="Solution: Run Length Encoding"></a>Solution: Run Length Encoding</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 26.37% of Java online submissions.<br>Memory Usage: 39.8 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N * Length).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Word</span> </span>&#123;</span><br><span class="line">        String key;</span><br><span class="line">        List&lt;Integer&gt; counts;</span><br><span class="line">        Word(String w) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            counts = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span>[] ca = w.toCharArray();</span><br><span class="line">            <span class="keyword">int</span> N = ca.length;</span><br><span class="line">            <span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == N-<span class="number">1</span> || ca[i] != ca[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                    sb.append(ca[i]);</span><br><span class="line">                    counts.add(i - prev);</span><br><span class="line">                    prev = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            key = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expressiveWords</span><span class="params">(String S, String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Word target = <span class="keyword">new</span> Word(S);</span><br><span class="line">        <span class="keyword">for</span> (String w: words) &#123;</span><br><span class="line">            Word word = <span class="keyword">new</span> Word(w);</span><br><span class="line">            <span class="keyword">if</span> (!word.key.equals(target.key)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">boolean</span> matched = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.counts.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = word.counts.get(i);</span><br><span class="line">                <span class="keyword">int</span> tar = target.counts.get(i);</span><br><span class="line">                <span class="keyword">if</span> ((tar &lt; <span class="number">3</span> &amp;&amp; cur != tar) || tar &lt; cur) &#123;</span><br><span class="line">                    matched = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matched) result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 99 - Recover Binary Search Tree</title>
    <url>/2020/05/10/leetcode-99/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Two elements of a binary search tree (BST) are swapped by mistake.</p>
<p>Recover the tree without changing its structure.</p>
<h2 id="Solution-One-Iterative-Inorder-Traversal"><a href="#Solution-One-Iterative-Inorder-Traversal" class="headerlink" title="Solution One: Iterative Inorder Traversal"></a>Solution One: Iterative Inorder Traversal</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 37.60% of Java online submissions.<br>Memory Usage: 39.8 MB, less than 80.77% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time complexity : O(1) in the best case, and O(N) in the worst case when one of the swapped nodes is a rightmost leaf.<br>Space complexity : up to O(H) to keep the stack where H is a tree height. </p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;TreeNode&gt;();</span><br><span class="line">        TreeNode tmp = root;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.addLast(tmp);</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node1 = <span class="keyword">null</span>, node2 = <span class="keyword">null</span>;</span><br><span class="line">        TreeNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode cur = stack.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; prev != <span class="keyword">null</span> &amp;&amp; prev.val &gt; cur.val) </span><br><span class="line">                node1 = prev;</span><br><span class="line">            <span class="keyword">if</span> (node1 != <span class="keyword">null</span> &amp;&amp; cur.val &lt; node1.val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node2 == <span class="keyword">null</span> || cur.val &lt; node2.val) node2 = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.addLast(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// swap</span></span><br><span class="line">        <span class="keyword">int</span> num = node1.val;</span><br><span class="line">        node1.val = node2.val;</span><br><span class="line">        node2.val = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Morris-Inorder-Traversal"><a href="#Solution-Two-Morris-Inorder-Traversal" class="headerlink" title="Solution Two: Morris Inorder Traversal"></a>Solution Two: Morris Inorder Traversal</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 946 - Validate Stack Sequences</title>
    <url>/2020/05/13/leetcode-946/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 74.67% of Java online submissions.<br>Memory Usage: 39.6 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushed.length == <span class="number">0</span> &amp;&amp; popped.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (pushed.length != popped.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(pushed[i++]);</span><br><span class="line">        <span class="keyword">while</span> (j &lt; popped.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek().equals(popped[j])) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == pushed.length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                stack.push(pushed[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty() &amp;&amp; i == pushed.length) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1044 - Longest Duplicate Substring</title>
    <url>/2020/05/20/leetcode-1044/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string S, consider all duplicated substrings: (contiguous) substrings of S that occur 2 or more times.  (The occurrences may overlap.)</p>
<p>Return any duplicated substring that has the longest possible length.  (If S does not have a duplicated substring, the answer is “”.)</p>
<h2 id="Solution-Binary-Search-Rabin-Karp"><a href="#Solution-Binary-Search-Rabin-Karp" class="headerlink" title="Solution: Binary Search + Rabin-Karp"></a>Solution: Binary Search + Rabin-Karp</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Time Limit Exceeded</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N).<br>Time Complexity: O(N * logN), O(logN) for the binary search and O(N) for Rabin-Karp algorithm.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestDupSubstring</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) <span class="keyword">return</span> S;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>, j = S.length() - <span class="number">1</span>;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            String dup = checkDup(S, mid);</span><br><span class="line">            <span class="keyword">if</span> (dup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = dup;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">checkDup</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index, count = S.length() - length + <span class="number">1</span>;</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;(count);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">            sb.append(S.charAt(index));</span><br><span class="line">        &#125;</span><br><span class="line">        visited.add(sb.toString());</span><br><span class="line">        <span class="keyword">while</span> (index &lt; S.length()) &#123;</span><br><span class="line">            sb.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">            sb.append(S.charAt(index++));</span><br><span class="line">            String cur = sb.toString();</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(cur)) <span class="keyword">return</span> cur;</span><br><span class="line">            visited.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 116 &amp; 117 - Populating Next Right Pointers in Each Node</title>
    <url>/2020/05/21/leetcode-116-117/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<p>Follow up:</p>
<p>You may only use constant extra space.<br>Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.</p>
<h2 id="Solution-One-BFS"><a href="#Solution-One-BFS" class="headerlink" title="Solution One: BFS"></a>Solution One: BFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        ArrayDeque&lt;Node&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q.addLast(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = q.size();</span><br><span class="line">            Node pre = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) q.addLast(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) q.addLast(cur.left);</span><br><span class="line">                cur.next = pre;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Using-previously-established-next-pointers"><a href="#Solution-Two-Using-previously-established-next-pointers" class="headerlink" title="Solution Two: Using previously established next pointers"></a>Solution Two: Using previously established next pointers</h2><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(N).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Node leftmost, prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        leftmost = root;</span><br><span class="line">        <span class="keyword">while</span> (leftmost != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node cur = leftmost;</span><br><span class="line">            leftmost = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNode(cur.left);</span><br><span class="line">                checkNode(cur.right);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftmost == <span class="keyword">null</span>) &#123; <span class="comment">// prev != null</span></span><br><span class="line">                leftmost = node;</span><br><span class="line">                prev = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = node;</span><br><span class="line">                prev = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>BST</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 124 - Binary Tree Maximum Path Sum</title>
    <url>/2020/05/22/leetcode-124/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a non-empty binary tree, find the maximum path sum.</p>
<p>For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.</p>
<h2 id="Solution-DFS"><a href="#Solution-DFS" class="headerlink" title="Solution: DFS"></a>Solution: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 26.76% of Java online submissions for Binary Tree Maximum Path Sum.<br>Memory Usage: 41.4 MB, less than 8.33% of Java online submissions for Binary Tree Maximum Path Sum.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        maxSum(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// case 1: child chain</span></span><br><span class="line">        <span class="keyword">int</span> left = maxSum(root.left), right = maxSum(root.right);</span><br><span class="line">        <span class="keyword">int</span> maxChild = Math.max(left, right);</span><br><span class="line">        result = Math.max(result, maxChild);</span><br><span class="line">        <span class="comment">// case 2: two children connected to root</span></span><br><span class="line">        <span class="keyword">if</span> (left != Integer.MIN_VALUE &amp;&amp; right != Integer.MIN_VALUE) &#123;</span><br><span class="line">            result = Math.max(result, left + right + root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// case 3: one child connected to root / only root</span></span><br><span class="line">        <span class="keyword">int</span> cur = root.val;</span><br><span class="line">        <span class="keyword">if</span> (maxChild &gt; <span class="number">0</span>) cur += maxChild;</span><br><span class="line">        result = Math.max(result, cur);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1277 - Count Square Submatrices with All Ones</title>
    <url>/2020/05/25/leetcode-1277/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a m * n matrix of ones and zeros, return how many square submatrices have all ones.</p>
<h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 97.09% of Java online submissions for Count Square Submatrices with All Ones.<br>Memory Usage: 48.5 MB, less than 100.00% of Java online submissions for Count Square Submatrices with All Ones.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(m*n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSquares</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                matrix[i][j] = Math.min(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>], Math.min(matrix[i-<span class="number">1</span>][j], matrix[i][j-<span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                ans += matrix[i][j] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 134 - Gas Station</title>
    <url>/2020/05/23/leetcode-134/</url>
    <content><![CDATA[<p><strong>Description</strong><br>There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</p>
<p>You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</p>
<p>Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</p>
<h2 id="Solution-One-Two-pass"><a href="#Solution-One-Two-pass" class="headerlink" title="Solution One: Two pass"></a>Solution One: Two pass</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 54 ms, faster than 16.35% of Java online submissions.<br>Memory Usage: 39.6 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// O(N^2)</span></span><br><span class="line">        <span class="keyword">int</span> num = gas.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            cost[i] = gas[i] - cost[i];</span><br><span class="line">            sum += cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cost[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">                sum += cost[(i + j) % num] ;</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    found = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-One-One-pass"><a href="#Solution-One-One-pass" class="headerlink" title="Solution One: One pass"></a>Solution One: One pass</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions.<br>Memory Usage: 39.9 MB.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="keyword">int</span>[] gas, <span class="keyword">int</span>[] cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = gas.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            cost[i] = gas[i] - cost[i];</span><br><span class="line">            sum += cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            cur += cost[i];</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = i + <span class="number">1</span>;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1376 - Time Needed to Inform All Employees</title>
    <url>/2020/05/25/leetcode-1376/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company has is the one with headID.</p>
<p>Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also it’s guaranteed that the subordination relationships have a tree structure.</p>
<p>The head of the company wants to inform all the employees of the company of an urgent piece of news. He will inform his direct subordinates and they will inform their subordinates and so on until all employees know about the urgent news.</p>
<p>The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e After informTime[i] minutes, all his direct subordinates can start spreading the news).</p>
<p>Return the number of minutes needed to inform all the employees about the urgent news.</p>
<h2 id="Solution-DFS-up-to-bottom"><a href="#Solution-DFS-up-to-bottom" class="headerlink" title="Solution: DFS, up to bottom"></a>Solution: DFS, up to bottom</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 112 ms, faster than 55.22% of Java online submissions for Time Needed to Inform All Employees.<br>Memory Usage: 58 MB, less than 100.00% of Java online submissions for Time Needed to Inform All Employees.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N + H), for subMap and recursion.<br>Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numOfMinutes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> headID, <span class="keyword">int</span>[] manager, <span class="keyword">int</span>[] informTime)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; subMap = <span class="keyword">new</span> HashMap&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; subList = subMap.getOrDefault(manager[i], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            subList.add(i);</span><br><span class="line">            subMap.put(manager[i], subList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> informSub(headID, subMap, informTime);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">informSub</span><span class="params">(<span class="keyword">int</span> i, Map&lt;Integer, List&lt;Integer&gt;&gt; subMap, <span class="keyword">int</span>[] informTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> sub : subMap.getOrDefault(i, <span class="keyword">new</span> ArrayList&lt;&gt;())) &#123;</span><br><span class="line">            ans = Math.max(ans, informSub(sub, subMap, informTime));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + informTime[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 139 - Word Break</title>
    <url>/2020/05/29/leetcode-139/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<h2 id="Solution-One-Recursive-with-memorization"><a href="#Solution-One-Recursive-with-memorization" class="headerlink" title="Solution One: Recursive with memorization"></a>Solution One: Recursive with memorization</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 81.64% of Java online submissions for Word Break.<br>Memory Usage: 39.6 MB, less than 5.08% of Java online submissions for Word Break.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Boolean[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> Boolean[s.length()];</span><br><span class="line">        <span class="keyword">return</span> splitWord(s, <span class="number">0</span>, <span class="keyword">new</span> HashSet&lt;&gt;(wordDict));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">splitWord</span><span class="params">(String s, <span class="keyword">int</span> start, Set&lt;String&gt; wordSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[start] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            String cur = s.substring(start, i);</span><br><span class="line">            <span class="keyword">if</span> (wordSet.contains(cur) &amp;&amp; splitWord(s, i, wordSet)) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[start] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-BFS"><a href="#Solution-Two-BFS" class="headerlink" title="Solution Two: BFS"></a>Solution Two: BFS</h2><h2 id="Solution-Three-Dynamic-Programming"><a href="#Solution-Three-Dynamic-Programming" class="headerlink" title="Solution Three: Dynamic Programming"></a>Solution Three: Dynamic Programming</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 17 - Letter Combinations of a Phone Number</title>
    <url>/2020/05/30/leetcode-17/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p>
<p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<h2 id="Solution-Backtracking"><a href="#Solution-Backtracking" class="headerlink" title="Solution: Backtracking"></a>Solution: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Letter Combinations of a Phone Number.<br>Memory Usage: 38.2 MB, less than 6.16% of Java online submissions for Letter Combinations of a Phone Number.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(3^N * 4^M), Time Complexity: O(3^N * 4^M).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        build(digits, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(String digits, <span class="keyword">int</span> start, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == digits.length()) &#123;</span><br><span class="line">            ans.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curNum = digits.charAt(start) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">char</span> firstC = (<span class="keyword">char</span>)(<span class="string">'a'</span> + (curNum - <span class="number">2</span>) * <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (curNum == <span class="number">7</span>) &#123;</span><br><span class="line">            count = <span class="number">4</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curNum == <span class="number">8</span>) &#123;</span><br><span class="line">            firstC = (<span class="keyword">char</span>)(firstC + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curNum == <span class="number">9</span>) &#123;</span><br><span class="line">            firstC = (<span class="keyword">char</span>)(firstC + <span class="number">1</span>);</span><br><span class="line">            count = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(firstC + i));</span><br><span class="line">            build(digits, start + <span class="number">1</span>, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 199 - Binary Tree Right Side View</title>
    <url>/2020/05/30/leetcode-199/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<h2 id="Solution-One-BFS"><a href="#Solution-One-BFS" class="headerlink" title="Solution One: BFS"></a>Solution One: BFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 78.26% of Java online submissions for Binary Tree Right Side View.<br>Memory Usage: 37.9 MB, less than 5.88% of Java online submissions for Binary Tree Right Side View.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(Diameter), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            ans.add(queue.peek().val);</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dfs - less space for arrayDeque but more for recursion, O(H)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-DFS"><a href="#Solution-Two-DFS" class="headerlink" title="Solution Two: DFS"></a>Solution Two: DFS</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 207 - Course Schedule</title>
    <url>/2020/05/27/leetcode-207/</url>
    <content><![CDATA[<p><strong>Description</strong><br>There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>Example 1:</p>
<p>Input: numCourses = 2, prerequisites = [[1,0]]<br>Output: true<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0. So it is possible.<br>Example 2:</p>
<p>Input: numCourses = 2, prerequisites = [[1,0],[0,1]]<br>Output: false<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0, and to take course 0 you should<br>             also have finished course 1. So it is impossible.</p>
<p>Constraints:</p>
<p>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.<br>1 &lt;= numCourses &lt;= 10^5</p>
<h2 id="Solution-One-Backtracking"><a href="#Solution-One-Backtracking" class="headerlink" title="Solution One: Backtracking"></a>Solution One: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 197 ms, faster than 5.00% of Java online submissions for Course Schedule.<br>Memory Usage: 117.7 MB, less than 5.00% of Java online submissions for Course Schedule.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time Complexity:<br>O(∣E∣+∣V∣^2) where ∣E∣ is the number of dependencies, ∣V∣ is the number of courses and d is the maximum length of acyclic paths in the graph. </p>
<p>Space Complexity:<br>O(∣E∣+∣V∣), with the same denotation as in the above time complexity. </p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> ans = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> finished = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prerequisites == <span class="keyword">null</span> || prerequisites.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="comment">// &lt;pre, courseList&gt;</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; nextMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; preNumMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] pre : prerequisites) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[<span class="number">0</span>] == pre[<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// build graph</span></span><br><span class="line">            List&lt;Integer&gt; list = nextMap.getOrDefault(pre[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list.add(pre[<span class="number">0</span>]);</span><br><span class="line">            nextMap.put(pre[<span class="number">1</span>], list);</span><br><span class="line">            <span class="comment">// update indegree</span></span><br><span class="line">            preNumMap.put(pre[<span class="number">0</span>], preNumMap.getOrDefault(pre[<span class="number">0</span>], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCycle(nextMap, i, <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCycle</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; nextMap, <span class="keyword">int</span> course, <span class="keyword">boolean</span>[] path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path[course]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        path[course] = <span class="keyword">true</span>;</span><br><span class="line">        List&lt;Integer&gt; list = nextMap.getOrDefault(course, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = list.get(i);</span><br><span class="line">            <span class="keyword">if</span> (isCycle(nextMap, next, path)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path[course] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-PostOrder-DFS-Backtracking-with-memorization"><a href="#Solution-Two-PostOrder-DFS-Backtracking-with-memorization" class="headerlink" title="Solution Two: PostOrder DFS (Backtracking with memorization)"></a>Solution Two: PostOrder DFS (Backtracking with memorization)</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 11 ms, faster than 37.95% of Java online submissions for Course Schedule.<br>Memory Usage: 46.2 MB, less than 9.66% of Java online submissions for Course Schedule.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time Complexity: O(∣E∣+∣V∣).</p>
<p>Space Complexity: O(∣E∣+∣V∣).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// course -&gt; list of next courses</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; courseDict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build the graph first</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] relation : prerequisites) &#123;</span><br><span class="line">      <span class="comment">// relation[0] depends on relation[1]</span></span><br><span class="line">      <span class="keyword">if</span> (courseDict.containsKey(relation[<span class="number">1</span>])) &#123;</span><br><span class="line">        courseDict.get(relation[<span class="number">1</span>]).add(relation[<span class="number">0</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; nextCourses = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        nextCourses.add(relation[<span class="number">0</span>]);</span><br><span class="line">        courseDict.put(relation[<span class="number">1</span>], nextCourses);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] checked = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line">    <span class="keyword">boolean</span>[] path = <span class="keyword">new</span> <span class="keyword">boolean</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> currCourse = <span class="number">0</span>; currCourse &lt; numCourses; ++currCourse) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.isCyclic(currCourse, courseDict, checked, path))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * postorder DFS check that no cycle would be formed starting from currCourse</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCyclic</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Integer currCourse, HashMap&lt;Integer, List&lt;Integer&gt;&gt; courseDict,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span>[] checked, <span class="keyword">boolean</span>[] path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bottom cases</span></span><br><span class="line">    <span class="keyword">if</span> (checked[currCourse])</span><br><span class="line">      <span class="comment">// this node has been checked, no cycle would be formed with this node.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (path[currCourse])</span><br><span class="line">      <span class="comment">// come across a previously visited node, i.e. detect the cycle</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no following courses, no loop.</span></span><br><span class="line">    <span class="keyword">if</span> (!courseDict.containsKey(currCourse))</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before backtracking, mark the node in the path</span></span><br><span class="line">    path[currCourse] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> ret = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// postorder DFS, to visit all its children first.</span></span><br><span class="line">    <span class="keyword">for</span> (Integer child : courseDict.get(currCourse)) &#123;</span><br><span class="line">      ret = <span class="keyword">this</span>.isCyclic(child, courseDict, checked, path);</span><br><span class="line">      <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// after the visits of children, we come back to process the node itself</span></span><br><span class="line">    <span class="comment">// remove the node from the path</span></span><br><span class="line">    path[currCourse] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that we've visited the nodes in the downstream,</span></span><br><span class="line">    <span class="comment">// we complete the check of this node.</span></span><br><span class="line">    checked[currCourse] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Three-Topological-Sort"><a href="#Solution-Three-Topological-Sort" class="headerlink" title="Solution Three: Topological Sort"></a>Solution Three: Topological Sort</h2><h1 id="Leetcode-210-Course-Schedule-II"><a href="#Leetcode-210-Course-Schedule-II" class="headerlink" title="Leetcode 210 - Course Schedule II"></a>Leetcode 210 - Course Schedule II</h1><p><strong>Description</strong><br>There are a total of n courses you have to take, labeled from 0 to n-1.</p>
<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>
<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>
<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:</p>
<p>Input: 2, [[1,0]]<br>Output: [0,1]<br>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished<br>             course 0. So the correct course order is [0,1] .<br>Example 2:</p>
<p>Input: 4, [[1,0],[2,0],[3,1],[3,2]]<br>Output: [0,1,2,3] or [0,2,1,3]<br>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both<br>             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.<br>             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .<br>Note:</p>
<p>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>
<h2 id="Solution-One-Topological-Sort"><a href="#Solution-One-Topological-Sort" class="headerlink" title="Solution One: Topological Sort"></a>Solution One: Topological Sort</h2><h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 16 ms, faster than 23.98% of Java online submissions for Course Schedule II.<br>Memory Usage: 48.3 MB, less than 5.58% of Java online submissions for Course Schedule II.</p>
<h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(V + E), Time Complexity: O(V + E).</p>
<h3 id="Java-code-2"><a href="#Java-code-2" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">// &lt;pre, course&gt;</span></span><br><span class="line">        Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// &lt;course, indegree&gt;</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; indegrees = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : prerequisites) &#123;</span><br><span class="line">            <span class="comment">// build graph</span></span><br><span class="line">            LinkedList&lt;Integer&gt; list = graph.getOrDefault(edge[<span class="number">1</span>], <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            list.add(edge[<span class="number">0</span>]);</span><br><span class="line">            graph.put(edge[<span class="number">1</span>], list);</span><br><span class="line">            <span class="comment">// update indegree</span></span><br><span class="line">            <span class="keyword">int</span> indegree = indegrees.getOrDefault(edge[<span class="number">0</span>], <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            indegrees.put(edge[<span class="number">0</span>], indegree);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="comment">// boolean[] visited = new boolean[numCourses];</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!indegrees.containsKey(i)) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = queue.poll();</span><br><span class="line">                ans[index++] = cur;</span><br><span class="line">                <span class="keyword">if</span> (!graph.containsKey(cur)) <span class="keyword">continue</span>;</span><br><span class="line">                LinkedList&lt;Integer&gt; list = graph.get(cur);</span><br><span class="line">                <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> next = list.get(<span class="number">0</span>);</span><br><span class="line">                    list.removeFirst();</span><br><span class="line">                    <span class="comment">// reduce indegree</span></span><br><span class="line">                    <span class="keyword">int</span> indegree = indegrees.get(next);</span><br><span class="line">                    <span class="keyword">if</span> (indegree == <span class="number">1</span>) &#123;</span><br><span class="line">                        indegrees.remove(next);</span><br><span class="line">                        queue.offer(next);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        indegrees.put(next, indegree - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-DFS"><a href="#Solution-Two-DFS" class="headerlink" title="Solution Two: DFS"></a>Solution Two: DFS</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
        <tag>Backtracking</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 215 - Kth Largest Element in an Array</title>
    <url>/2020/05/30/leetcode-215/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<h2 id="Solution-Quick-Select"><a href="#Solution-Quick-Select" class="headerlink" title="Solution: Quick Select"></a>Solution: Quick Select</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 97.79% of Java online submissions for Kth Largest Element in an Array.<br>Memory Usage: 42.4 MB, less than 5.18% of Java online submissions for Kth Largest Element in an Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// twist from quick sort</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tar = k, start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, nums.length - k, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partitionSort(nums, start, end);</span><br><span class="line">        <span class="keyword">if</span> (pivotIndex == k) <span class="keyword">return</span> nums[pivotIndex];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; pivotIndex) <span class="keyword">return</span> quickSelect(nums, k, start, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickSelect(nums, k, pivotIndex + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return position of pivot </span></span><br><span class="line">    <span class="comment">// (left part &lt; pivotVal, right part &gt;= pivotVal)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partitionSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> start;</span><br><span class="line">        <span class="keyword">int</span> pivotIndex = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pivotVal = nums[pivotIndex];</span><br><span class="line">        swap(nums, pivotIndex, end);</span><br><span class="line">        <span class="keyword">int</span> left = start - <span class="number">1</span>, right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[++left] &lt; pivotVal) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; <span class="number">0</span> &amp;&amp; nums[--right] &gt; pivotVal) &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, end);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Related-Leetcode-347-Top-K-Frequent-Elements"><a href="#Related-Leetcode-347-Top-K-Frequent-Elements" class="headerlink" title="Related: Leetcode 347 - Top K Frequent Elements"></a>Related: Leetcode 347 - Top K Frequent Elements</h1><p><strong>Description</strong><br>Given a non-empty array of integers, return the k most frequent elements.</p>
<p>Example 1:</p>
<p>Input: nums = [1,1,1,2,2,3], k = 2<br>Output: [1,2]<br>Example 2:</p>
<p>Input: nums = [1], k = 1<br>Output: [1]<br>Note:</p>
<p>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.<br>It’s guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique.<br>You can return the answer in any order.</p>
<h2 id="Solution-One-Heap"><a href="#Solution-One-Heap" class="headerlink" title="Solution One: Heap"></a>Solution One: Heap</h2><h2 id="Solution-Two-QuickSelect"><a href="#Solution-Two-QuickSelect" class="headerlink" title="Solution Two: QuickSelect"></a>Solution Two: QuickSelect</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 93.18% of Java online submissions for Top K Frequent Elements.<br>Memory Usage: 41.7 MB, less than 91.81% of Java online submissions for Top K Frequent Elements.</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k + <span class="number">1</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer n1, Integer n2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> freqMap.get(n1) - freqMap.get(n2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = freqMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            freqMap.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// build array of unique elements</span></span><br><span class="line">        <span class="keyword">int</span>[] uniNums = <span class="keyword">new</span> <span class="keyword">int</span>[freqMap.size()];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : freqMap.keySet()) uniNums[i++] = num;</span><br><span class="line">        <span class="comment">// quickselect</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = uniNums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = -<span class="number">1</span>, target = k;</span><br><span class="line">        <span class="keyword">while</span> (target &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            pivot = quickSort(uniNums, start, end, freqMap);</span><br><span class="line">            <span class="keyword">int</span> leftLength = pivot - start + <span class="number">1</span>; <span class="comment">// include pivot value</span></span><br><span class="line">            <span class="keyword">if</span> (leftLength &lt;= target) &#123;</span><br><span class="line">                target -= leftLength;</span><br><span class="line">                start = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = pivot - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// convert list to array</span></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        System.arraycopy(uniNums, <span class="number">0</span>, ans, <span class="number">0</span>, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// left part is greater than right part</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, Map&lt;Integer, Integer&gt; freqMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotFreq = freqMap.get(nums[end]);</span><br><span class="line">        <span class="keyword">int</span> leftIndex = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freqMap.get(nums[i]) &gt; pivotFreq) &#123;</span><br><span class="line">                swap(nums, leftIndex++, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, leftIndex, end);</span><br><span class="line">        <span class="keyword">return</span> leftIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 238 - Product of Array Except Self</title>
    <url>/2020/05/26/leetcode-238/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Example:</p>
<p>Input:  [1,2,3,4]<br>Output: [24,12,8,6]<br>Constraint: It’s guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.</p>
<p>Note: Please solve it without division and in O(n).</p>
<p>Follow up:<br>Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<h2 id="Solution-One-with-extra-array"><a href="#Solution-One-with-extra-array" class="headerlink" title="Solution One: with extra array"></a>Solution One: with extra array</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.<br>Memory Usage: 47.6 MB, less than 5.51% of Java online submissions for Product of Array Except Self.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span>[] record1 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">int</span>[] record2 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        </span><br><span class="line">        record1[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            record1[i] = record1[i-<span class="number">1</span>] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        record2[length - <span class="number">1</span>] = nums[length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            record2[i] = record2[i+<span class="number">1</span>] * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans[i] = record1[i-<span class="number">1</span>] * record2[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">0</span>] = record2[<span class="number">1</span>];</span><br><span class="line">        ans[length - <span class="number">1</span>] = record1[length - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-O-1-space-approach"><a href="#Solution-Two-O-1-space-approach" class="headerlink" title="Solution Two: O(1) space approach"></a>Solution Two: O(1) space approach</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 31 - Next Permutation</title>
    <url>/2020/05/27/leetcode-31/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<h2 id="Solution-One-One-pass-with-sorting"><a href="#Solution-One-One-pass-with-sorting" class="headerlink" title="Solution One: One pass with sorting"></a>Solution One: One pass with sorting</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 41.73% of Java online submissions for Next Permutation.<br>Memory Usage: 39.7 MB, less than 49.00% of Java online submissions for Next Permutation.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(nlogn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// find pivot from right</span></span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span> pivotIndex = -<span class="number">1</span>, pivotValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex = -<span class="number">1</span>, minVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                pivotIndex = i;</span><br><span class="line">                pivotValue = nums[i];</span><br><span class="line">                minIndex = i + <span class="number">1</span>;</span><br><span class="line">                minVal = nums[i + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pivotIndex &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; pivotValue</span><br><span class="line">                       &amp;&amp; nums[i] &lt; minVal) &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">                minVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// swap if pivot found</span></span><br><span class="line">        <span class="keyword">if</span> (pivotIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[pivotIndex];</span><br><span class="line">            nums[pivotIndex] = nums[minIndex];</span><br><span class="line">            nums[minIndex] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort from pivot</span></span><br><span class="line">        sortFromPivot(nums, pivotIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// insertion sort</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortFromPivot</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p + <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = nums[i], j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j - <span class="number">1</span>] &lt;= cur) <span class="keyword">break</span>;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-One-pass-with-reversing"><a href="#Solution-Two-One-pass-with-reversing" class="headerlink" title="Solution Two: One pass with reversing"></a>Solution Two: One pass with reversing</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 235 - Lowest Common Ancestor of a Binary Search Tree</title>
    <url>/2020/05/26/leetcode-235/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<h2 id="Solution-One-Recursive"><a href="#Solution-One-Recursive" class="headerlink" title="Solution One: Recursive"></a>Solution One: Recursive</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 68.21% of Java online submissions for Lowest Common Ancestor of a Binary Search Tree.<br>Memory Usage: 40.6 MB, less than 5.10% of Java online submissions for Lowest Common Ancestor of a Binary Search Tree.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Iterative"><a href="#Solution-Two-Iterative" class="headerlink" title="Solution Two: Iterative"></a>Solution Two: Iterative</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Frequent</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 399 - Evaluate Division</title>
    <url>/2020/05/23/leetcode-399/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.</p>
<h2 id="Solution-DFS"><a href="#Solution-DFS" class="headerlink" title="Solution: DFS"></a>Solution: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 62.84% of Java online submissions.<br>Memory Usage: 39.8 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="comment">// build map</span></span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">            String A = equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String B = equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">            Map&lt;String, Double&gt; subMap = map.getOrDefault(A, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            subMap.put(B, values[i]);</span><br><span class="line">            map.put(A, subMap);</span><br><span class="line">            subMap = map.getOrDefault(B, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            subMap.put(A, <span class="number">1</span> / values[i]);</span><br><span class="line">            map.put(B, subMap);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            result[i] = getPathWeight(queries.get(i).get(<span class="number">0</span>), queries.get(i).get(<span class="number">1</span>), <span class="keyword">new</span> HashSet&lt;&gt;(), map);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getPathWeight</span><span class="params">(String start, String end, Set&lt;String&gt; visited, Map&lt;String, Map&lt;String, Double&gt;&gt; graph)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Rejection case. */</span></span><br><span class="line">        <span class="keyword">if</span> (!graph.containsKey(start)) </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* Accepting case. */</span></span><br><span class="line">        <span class="keyword">if</span> (graph.get(start).containsKey(end))</span><br><span class="line">            <span class="keyword">return</span> graph.get(start).get(end);</span><br><span class="line">        </span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Double&gt; neighbour : graph.get(start).entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited.contains(neighbour.getKey())) &#123;</span><br><span class="line">                <span class="keyword">double</span> productWeight = getPathWeight(neighbour.getKey(), end, visited, graph);</span><br><span class="line">                <span class="keyword">if</span> (productWeight != -<span class="number">1.0</span>)</span><br><span class="line">                    <span class="keyword">return</span> neighbour.getValue() * productWeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 419 - Battleships in a Board</title>
    <url>/2020/05/29/leetcode-419/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an 2D board, count how many battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules:<br>You receive a valid board, made of only battleships or empty slots.<br>Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size.<br>At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships.</p>
<h2 id="Solution-transverse-with-memo"><a href="#Solution-transverse-with-memo" class="headerlink" title="Solution: transverse with memo"></a>Solution: transverse with memo</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Battleships in a Board.<br>Memory Usage: 39.3 MB, less than 100.00% of Java online submissions for Battleships in a Board.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowNum = board.length, colNum = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; rowNum) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>, lastX = -<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; colNum) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123; <span class="comment">// 'X' or 'Y'</span></span><br><span class="line">                    <span class="comment">// set next row</span></span><br><span class="line">                    <span class="keyword">if</span> (i &lt; rowNum - <span class="number">1</span> &amp;&amp; board[i + <span class="number">1</span>][j] == <span class="string">'X'</span>) </span><br><span class="line">                        board[i + <span class="number">1</span>][j] = <span class="string">'Y'</span>;</span><br><span class="line">                    <span class="comment">// recover if counted</span></span><br><span class="line">                    <span class="keyword">if</span> (board[i][j] == <span class="string">'Y'</span>) board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                    <span class="comment">// count</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (lastX != j - <span class="number">1</span>) ans++;</span><br><span class="line">                    lastX = j;</span><br><span class="line">                &#125;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 415 - Add Strings &amp;&amp; Leetcode 67 - Add Binary</title>
    <url>/2020/05/30/leetcode-415/</url>
    <content><![CDATA[<h1 id="Leetcode-415-Add-Strings"><a href="#Leetcode-415-Add-Strings" class="headerlink" title="Leetcode 415 - Add Strings"></a>Leetcode 415 - Add Strings</h1><p><strong>Description</strong><br>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p>
<p>Note:</p>
<p>The length of both num1 and num2 is &lt; 5100.<br>Both num1 and num2 contains only digits 0-9.<br>Both num1 and num2 does not contain any leading zero.<br>You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>
<h2 id="Solution-from-right-to-left-with-StringBuilder"><a href="#Solution-from-right-to-left-with-StringBuilder" class="headerlink" title="Solution: from right to left with StringBuilder"></a>Solution: from right to left with StringBuilder</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 96.05% of Java online submissions for Add Strings.<br>Memory Usage: 39.6 MB, less than 6.25% of Java online submissions for Add Strings.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(max(M,N)), Time Complexity: O(max(M,N)).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addStrings</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i &gt;= <span class="number">0</span>) ? (num1.charAt(i--) - <span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = (j &gt;= <span class="number">0</span>) ? (num2.charAt(j--) - <span class="string">'0'</span>) : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = m + n + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur = cur % <span class="number">10</span>;</span><br><span class="line">            sb.append(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) sb.append(<span class="string">'1'</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-67-Add-Binary"><a href="#Leetcode-67-Add-Binary" class="headerlink" title="Leetcode 67 - Add Binary"></a>Leetcode 67 - Add Binary</h1><p><strong>Description</strong><br>Given two binary strings, return their sum (also a binary string).</p>
<p>The input strings are both non-empty and contains only characters 1 or 0.</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Add Binary.<br>Memory Usage: 38.2 MB, less than 5.62% of Java online submissions for Add Binary.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> i = a.length() - <span class="number">1</span>, j = b.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = i &gt;= <span class="number">0</span> ? a.charAt(i--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> n = j &gt;= <span class="number">0</span> ? b.charAt(j--) - <span class="string">'0'</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = m + n + carry;</span><br><span class="line">            carry = cur &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            cur = cur &amp; <span class="number">1</span>;</span><br><span class="line">            sb.append(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) sb.append(carry);</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 560 - Subarray Sum Equals K</title>
    <url>/2020/05/27/leetcode-560/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.</p>
<p>Example 1:</p>
<p>Input:nums = [1,1,1], k = 2<br>Output: 2</p>
<h2 id="Solution-One-Using-Cumulative-Sum-without-extra-space"><a href="#Solution-One-Using-Cumulative-Sum-without-extra-space" class="headerlink" title="Solution One: Using Cumulative Sum without extra space"></a>Solution One: Using Cumulative Sum without extra space</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 446 ms, faster than 5.00% of Java online submissions for Subarray Sum Equals K.<br>Memory Usage: 40.4 MB, less than 33.69% of Java online submissions for Subarray Sum Equals K.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) nums[i] += nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == k) ans++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] - nums[j] == k) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-using-HashMap"><a href="#Solution-Two-using-HashMap" class="headerlink" title="Solution Two: using HashMap"></a>Solution Two: using HashMap</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 14 ms, faster than 42.58% of Java online submissions for Subarray Sum Equals K.<br>Memory Usage: 40.4 MB, less than 34.78% of Java online submissions for Subarray Sum Equals K.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; sumMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        sumMap.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            ans += sumMap.getOrDefault(sum - k, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> count = sumMap.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            sumMap.put(sum, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Related-Questions"><a href="#Related-Questions" class="headerlink" title="Related Questions"></a>Related Questions</h3><p>523 - Continuous Subarray Sum</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 88 - Merge Sorted Array</title>
    <url>/2020/05/30/leetcode-88/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</p>
<p>Note:</p>
<p>The number of elements initialized in nums1 and nums2 are m and n respectively.<br>You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.<br>Example:</p>
<p>Input:<br>nums1 = [1,2,3,0,0,0], m = 3<br>nums2 = [2,5,6],       n = 3</p>
<p>Output: [1,2,2,3,5,6]</p>
<h2 id="Solution-One-Two-pointer-start-from-left"><a href="#Solution-One-Two-pointer-start-from-left" class="headerlink" title="Solution One: Two pointer, start from left"></a>Solution One: Two pointer, start from left</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Merge Sorted Array.<br>Memory Usage: 39.8 MB, less than 5.94% of Java online submissions for Merge Sorted Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        System.arraycopy(nums1, <span class="number">0</span>, nums1, n, m);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m || j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = i &lt; m ? nums1[n + i] : Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> n2 = j &lt; n ? nums2[j] : Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">if</span> (n1 &lt;= n2) &#123;</span><br><span class="line">                nums1[count++] = n1;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[count++] = n2;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Two-pointer-start-from-right"><a href="#Solution-Two-Two-pointer-start-from-right" class="headerlink" title="Solution Two: Two pointer, start from right"></a>Solution Two: Two pointer, start from right</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 54 - Spiral Matrix</title>
    <url>/2020/05/24/leetcode-54/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>
<a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Spiral Matrix.<br>Memory Usage: 37.6 MB, less than 5.21% of Java online submissions for Spiral Matrix.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowNum, colNum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rowNum = matrix.length;</span><br><span class="line">        colNum = matrix[<span class="number">0</span>].length;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(rowNum * colNum);</span><br><span class="line">        <span class="keyword">int</span> maxRow = (matrix.length + <span class="number">1</span>) / <span class="number">2</span>, maxCol = (matrix[<span class="number">0</span>].length + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; maxRow &amp;&amp; i &lt; maxCol) &#123;</span><br><span class="line">            getCircle(i++, result, matrix);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getCircle</span><span class="params">(<span class="keyword">int</span> i, List&lt;Integer&gt; result, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = i, col = i;</span><br><span class="line">        <span class="comment">// left to right</span></span><br><span class="line">        <span class="keyword">while</span> (col &lt; colNum - i) result.add(matrix[row][col++]);</span><br><span class="line">        col--;</span><br><span class="line">        row++;</span><br><span class="line">        <span class="keyword">if</span> (row == rowNum - i) <span class="keyword">return</span>; <span class="comment">// only one row</span></span><br><span class="line">        <span class="comment">// up to down</span></span><br><span class="line">        <span class="keyword">while</span> (row &lt; rowNum - i) result.add(matrix[row++][col]);</span><br><span class="line">        row--;</span><br><span class="line">        col--;</span><br><span class="line">        <span class="keyword">if</span> (col &lt; i) <span class="keyword">return</span>; <span class="comment">// only one col</span></span><br><span class="line">        <span class="comment">// right to left</span></span><br><span class="line">        <span class="keyword">while</span> (col &gt;= i) result.add(matrix[row][col--]);</span><br><span class="line">        col++;</span><br><span class="line">        row--;</span><br><span class="line">        <span class="comment">// down to up</span></span><br><span class="line">        <span class="keyword">while</span> (row &gt; i) result.add(matrix[row--][col]);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Related-Questions"><a href="#Related-Questions" class="headerlink" title="Related Questions"></a>Related Questions</h3><p>Leetcode 59 - Spiral Matrix II    </p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 85 - Maximal Rectangle</title>
    <url>/2020/05/26/leetcode-85/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area.</p>
<h2 id="Solution-One-Dynamic-Programming-Better-Brute-Force-on-Histograms"><a href="#Solution-One-Dynamic-Programming-Better-Brute-Force-on-Histograms" class="headerlink" title="Solution One: Dynamic Programming - Better Brute Force on Histograms"></a>Solution One: Dynamic Programming - Better Brute Force on Histograms</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 82.47% of Java online submissions for Maximal Rectangle.<br>Memory Usage: 42.9 MB, less than 86.96% of Java online submissions for Maximal Rectangle.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(m<em>n), Time Complexity: O(m</em>n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowNum = matrix.length, colNum = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] record = <span class="keyword">new</span> <span class="keyword">int</span>[rowNum][colNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowNum; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    record[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) record[i][j] += record[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowNum; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> minHeight = record[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (record[i][k] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                    minHeight = Math.min(minHeight, record[i][k]);</span><br><span class="line">                    ans = Math.max(minHeight * (j - k + <span class="number">1</span>), ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Solution-Two-Using-Histograms-Stack"><a href="#Solution-Two-Using-Histograms-Stack" class="headerlink" title="Solution Two: Using Histograms - Stack"></a>Solution Two: Using Histograms - Stack</h3><p>Related question:<br>Leetcode 84 - Largest Rectangle in Histogram</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
        <tag>Monotonic Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 93 - Restore IP Addresses</title>
    <url>/2020/05/25/leetcode-93/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p>
<p>A valid IP address consists of exactly four integers (each integer is between 0 and 255) separated by single points.</p>
<p>Example:</p>
<p>Input: “25525511135”<br>Output: [“255.255.11.135”, “255.255.111.35”]</p>
<h2 id="Solution-One-Backtracking-DFS"><a href="#Solution-One-Backtracking-DFS" class="headerlink" title="Solution One: Backtracking (DFS)"></a>Solution One: Backtracking (DFS)</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.70% of Java online submissions for Restore IP Addresses.<br>Memory Usage: 39.1 MB, less than 9.30% of Java online submissions for Restore IP Addresses.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">https://leetcode.com/problems/restore-ip-addresses/</a><br>Time complexity : as discussed above, there is not more than 27 combinations to check.<br>Space complexity : constant space to keep the solutions, not more than 19 valid IP addresses.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        length = s.length();</span><br><span class="line">        helper(s, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(String s, <span class="keyword">int</span> start, StringBuilder pre, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= length || num &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == length &amp;&amp; num == <span class="number">4</span>) </span><br><span class="line">                result.add(pre.substring(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> end = start + j;</span><br><span class="line">            <span class="keyword">if</span> (end &gt; length) <span class="keyword">break</span>;</span><br><span class="line">            String cur = s.substring(start, end);</span><br><span class="line">            <span class="keyword">if</span> ((j == <span class="number">3</span> &amp;&amp; Integer.parseInt(cur) &gt; <span class="number">255</span>)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (!String.valueOf(Integer.parseInt(cur)).equals(cur)) <span class="keyword">break</span>;</span><br><span class="line">            pre = pre.append(<span class="string">'.'</span>).append(cur);</span><br><span class="line">            helper(s, end, pre, num + <span class="number">1</span>);</span><br><span class="line">            pre = pre.delete(pre.length() - j - <span class="number">1</span>, pre.length());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Improved-Solution"><a href="#Improved-Solution" class="headerlink" title="Improved Solution"></a>Improved Solution</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 973 - K Closest Points to Origin</title>
    <url>/2020/05/28/leetcode-973/</url>
    <content><![CDATA[<p><strong>Description</strong><br>We have a list of points on the plane.  Find the K closest points to the origin (0, 0).</p>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
<p>You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)</p>
<h2 id="Solution-One-max-heap"><a href="#Solution-One-max-heap" class="headerlink" title="Solution One: max heap"></a>Solution One: max heap</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 132 ms, faster than 5.03% of Java online submissions for K Closest Points to Origin.<br>Memory Usage: 46.8 MB, less than 100.00% of Java online submissions for K Closest Points to Origin.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(K), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) <span class="keyword">return</span> points;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            Map&lt;<span class="keyword">int</span>[], Integer&gt; distances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] p1, <span class="keyword">int</span>[] p2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!distances.containsKey(p1)) &#123;</span><br><span class="line">                    distances.put(p1, p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!distances.containsKey(p2)) &#123;</span><br><span class="line">                    distances.put(p2, p2[<span class="number">0</span>] * p2[<span class="number">0</span>] + p2[<span class="number">1</span>] * p2[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> distances.get(p2) - distances.get(p1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] point: points) &#123;</span><br><span class="line">            queue.add(point);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; K) queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[queue.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-kind-of-quick-sort"><a href="#Solution-Two-kind-of-quick-sort" class="headerlink" title="Solution Two: kind of quick sort"></a>Solution Two: kind of quick sort</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 951 - Flip Equivalent Binary Trees</title>
    <url>/2020/05/24/leetcode-951/</url>
    <content><![CDATA[<p><strong>Description</strong><br>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>
<p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>
<p>Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.</p>
<h2 id="Solution-One-Recursive"><a href="#Solution-One-Recursive" class="headerlink" title="Solution One: Recursive"></a>Solution One: Recursive</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Flip Equivalent Binary Trees.<br>Memory Usage: 37.2 MB, less than 5.55% of Java online submissions for Flip Equivalent Binary Trees.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time Complexity: O(min(N_1, N_2)), where N_1, N_2 are the lengths of root1 and root2.</p>
<p>Space Complexity: O(min(H_1, H_2)), where H_1, H_2 are the heights of the trees of root1 and root2.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">flipEquiv</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (flipEquiv(root1.left, root2.left)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flipEquiv(root1.right, root2.right)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flipEquiv(root1.left, root2.right)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flipEquiv(root1.right, root2.left)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// return (flipEquiv(root1.left, root2.left) </span></span><br><span class="line">        <span class="comment">//     &amp;&amp; flipEquiv(root1.right, root2.right))</span></span><br><span class="line">        <span class="comment">//     || (flipEquiv(root1.left, root2.right) </span></span><br><span class="line">        <span class="comment">//     &amp;&amp; flipEquiv(root1.right, root2.left));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="solution-two-Canonical-Traversal"><a href="#solution-two-Canonical-Traversal" class="headerlink" title="solution two: Canonical Traversal"></a>solution two: Canonical Traversal</h2><p>Flip each node so that the left child is smaller than the right, and call this the canonical representation. All equivalent trees have exactly one canonical representation.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time Complexity: O(N_1 + N_2), where N_1, N_2 are the lengths of root1 and root2.</p>
<p>Space Complexity: O(N_1 + N_2).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 833 - Find And Replace in String</title>
    <url>/2020/05/25/leetcode-833/</url>
    <content><![CDATA[<p><strong>Description</strong><br>To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size).</p>
<p>Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y.  The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y.  If not, we do nothing.</p>
<p>For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”.</p>
<p>Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’.</p>
<p>All these operations occur simultaneously.  It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case.</p>
<h2 id="Solution-One-For-left-to-right-recording-length-change"><a href="#Solution-One-For-left-to-right-recording-length-change" class="headerlink" title="Solution One: For left to right, recording length change"></a>Solution One: For left to right, recording length change</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 35.60% of Java online submissions for Find And Replace in String.<br>Memory Usage: 39.5 MB, less than 8.70% of Java online submissions for Find And Replace in String.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), for indexMap that stores sorted indexes.<br>Time Complexity: O(N), for one pass.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findReplaceString</span><span class="params">(String S, <span class="keyword">int</span>[] indexes, String[] sources, String[] targets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() == <span class="number">0</span>) <span class="keyword">return</span> S;</span><br><span class="line">        <span class="comment">// build index map</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indexes.length; i++) &#123;</span><br><span class="line">            indexMap.put(indexes[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// find and replace</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(S);</span><br><span class="line">        <span class="keyword">int</span> length = S.length();</span><br><span class="line">        <span class="keyword">int</span> change = <span class="number">0</span>, curPos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index : indexMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = indexMap.get(index);</span><br><span class="line">            curPos = indexes[i] + change;</span><br><span class="line">            <span class="keyword">if</span> (curPos &gt;= sb.length()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// found</span></span><br><span class="line">            <span class="keyword">if</span> (sb.indexOf(sources[i], curPos) == curPos) &#123;</span><br><span class="line">                change += targets[i].length() - sources[i].length();</span><br><span class="line">                sb = sb.replace(curPos, curPos + sources[i].length(), targets[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-For-right-to-left-without-recording-length-change"><a href="#Solution-Two-For-right-to-left-without-recording-length-change" class="headerlink" title="Solution Two: For right to left, without recording length change"></a>Solution Two: For right to left, without recording length change</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 105 - Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/2020/05/29/leetcode-105/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<h2 id="Solution-Recursive"><a href="#Solution-Recursive" class="headerlink" title="Solution: Recursive"></a>Solution: Recursive</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder == <span class="keyword">null</span> || inorder == <span class="keyword">null</span> || preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span> || preorder.length != inorder.length) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, inorder, <span class="number">0</span>, preorder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span> preStart, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> inStart, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// recursive case</span></span><br><span class="line">        <span class="keyword">int</span> rootVal = preorder[preStart];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> leftLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftLength &lt; length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[inStart + leftLength] == rootVal) <span class="keyword">break</span>;</span><br><span class="line">            leftLength++;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = build(preorder, preStart + <span class="number">1</span>, inorder, inStart, leftLength);</span><br><span class="line">        root.right = build(preorder, preStart + leftLength + <span class="number">1</span>, inorder, inStart + leftLength + <span class="number">1</span>, length - <span class="number">1</span> - leftLength);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tips: Time complexity can be reduced by using HashMap to store &lt;val, index&gt; of inorder array.</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 1249 - Minimum Remove to Make Valid Parentheses</title>
    <url>/2020/05/28/leetcode-1249/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string s of ‘(‘ , ‘)’ and lowercase English characters. </p>
<p>Your task is to remove the minimum number of parentheses ( ‘(‘ or ‘)’, in any positions ) so that the resulting parentheses string is valid and return any valid string.</p>
<p>Formally, a parentheses string is valid if and only if:</p>
<p>It is the empty string, contains only lowercase characters, or<br>It can be written as AB (A concatenated with B), where A and B are valid strings, or<br>It can be written as (A), where A is a valid string.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 13 ms, faster than 87.07% of Java online submissions for Minimum Remove to Make Valid Parentheses.<br>Memory Usage: 40.1 MB, less than 100.00% of Java online submissions for Minimum Remove to Make Valid Parentheses.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        ArrayDeque&lt;Integer&gt; leftPs = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="string">'('</span>) &#123;</span><br><span class="line">                leftPs.addLast(sb.length());</span><br><span class="line">                sb.append(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">')'</span> &amp;&amp; !leftPs.isEmpty()) &#123;</span><br><span class="line">                leftPs.removeLast();</span><br><span class="line">                sb.append(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt;= <span class="string">'a'</span> &amp;&amp; cur &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">                sb.append(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove '('</span></span><br><span class="line">        <span class="keyword">while</span> (!leftPs.isEmpty()) &#123;</span><br><span class="line">            sb.deleteCharAt(leftPs.removeLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 41 - First Missing Positive</title>
    <url>/2020/05/31/leetcode-41/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an unsorted integer array, find the smallest missing positive integer.</p>
<p>Example 1:</p>
<p>Input: [1,2,0]<br>Output: 3<br>Example 2:</p>
<p>Input: [3,4,-1,1]<br>Output: 2<br>Example 3:</p>
<p>Input: [7,8,9,11,12]<br>Output: 1<br>Note:</p>
<p>Your algorithm should run in O(n) time and uses constant extra space.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for First Missing Positive.<br>Memory Usage: 37.2 MB, less than 6.85% of Java online submissions for First Missing Positive.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// whether one exists</span></span><br><span class="line">        <span class="keyword">boolean</span> foundOne = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                foundOne = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] == <span class="number">0</span> || nums[i] &gt; n)</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!foundOne) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// clean data</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.abs(nums[i]);</span><br><span class="line">            nums[cur - <span class="number">1</span>] = Math.abs(nums[cur - <span class="number">1</span>]) * (-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check existence</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 543 - Diameter of Binary Tree</title>
    <url>/2020/05/31/leetcode-543/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<h2 id="Solution-DFS-with-depth"><a href="#Solution-DFS-with-depth" class="headerlink" title="Solution: DFS with depth"></a>Solution: DFS with depth</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(H).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        getDepth(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = getDepth(root.right);</span><br><span class="line">        ans = Math.max(ans, left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 680 - Valid Palindrome II</title>
    <url>/2020/05/31/leetcode-680/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.</p>
<h2 id="Solution-One-StringBuilder"><a href="#Solution-One-StringBuilder" class="headerlink" title="Solution One: StringBuilder"></a>Solution One: StringBuilder</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 9 ms, faster than 30.82% of Java online submissions for Valid Palindrome II.<br>Memory Usage: 40.4 MB, less than 5.55% of Java online submissions for Valid Palindrome II.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s);</span><br><span class="line">        <span class="keyword">if</span> (isPalindrome(sb)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tar = size - <span class="number">1</span> - i;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(tar)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPalindrome(<span class="keyword">new</span> StringBuilder(sb).deleteCharAt(i))</span><br><span class="line">                   || isPalindrome(<span class="keyword">new</span> StringBuilder(sb).deleteCharAt(tar)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().equals(sb.reverse().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-two-pointer"><a href="#Solution-Two-two-pointer" class="headerlink" title="Solution Two: two pointer"></a>Solution Two: two pointer</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 39.88% of Java online submissions for Valid Palindrome II.<br>Memory Usage: 40 MB, less than 25.00% of Java online submissions for Valid Palindrome II.</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindromeRange</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= i + (j - i) / <span class="number">2</span>; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(k) != s.charAt(j - k + i)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(s.length() - <span class="number">1</span> - i)) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = s.length() - <span class="number">1</span> - i;</span><br><span class="line">                <span class="keyword">return</span> (isPalindromeRange(s, i+<span class="number">1</span>, j) ||</span><br><span class="line">                        isPalindromeRange(s, i, j-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 125 - Valid Palindrome</title>
    <url>/2020/06/01/leetcode-125/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>Note: For the purpose of this problem, we define empty string as valid palindrome.</p>
<p>Example 1:</p>
<p>Input: “A man, a plan, a canal: Panama”<br>Output: true<br>Example 2:</p>
<p>Input: “race a car”<br>Output: false</p>
<h2 id="Solution-One-Two-Pointer"><a href="#Solution-One-Two-Pointer" class="headerlink" title="Solution One: Two Pointer"></a>Solution One: Two Pointer</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 97.94% of Java online submissions for Valid Palindrome.<br>Memory Usage: 39.4 MB, less than 25.00% of Java online submissions for Valid Palindrome.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">char</span> ci = s.charAt(i), cj = s.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (isAlphanumeric(ci)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isAlphanumeric(cj)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ci != cj) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAlphanumeric</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i))) &#123;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j))) &#123;</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &lt; j &amp;&amp; Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 121 - Best Time to Buy and Sell Stock (series)</title>
    <url>/2020/06/05/leetcode-121/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:</p>
<p>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.<br>Example 2:</p>
<p>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.09% of Java online submissions for Best Time to Buy and Sell Stock.<br>Memory Usage: 39.4 MB, less than 63.11% of Java online submissions for Best Time to Buy and Sell Stock.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; minPrice) &#123;</span><br><span class="line">                ans = Math.max(prices[i] - minPrice, ans);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-121-Best-Time-to-Buy-and-Sell-Stock"><a href="#Leetcode-121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Leetcode 121 - Best Time to Buy and Sell Stock"></a>Leetcode 121 - Best Time to Buy and Sell Stock</h1><p><strong>Description</strong><br>Say you have an array prices for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</p>
<p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Best Time to Buy and Sell Stock II.<br>Memory Usage: 39.6 MB, less than 45.21% of Java online submissions for Best Time to Buy and Sell Stock II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">                ans += (prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Leetcode-123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Leetcode 123 -  Best Time to Buy and Sell Stock III"></a>Leetcode 123 -  Best Time to Buy and Sell Stock III</h1><p><strong>Description</strong><br>Say you have an array for which the ith element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most two transactions.</p>
<p>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:</p>
<p>Input: [3,3,5,0,0,3,1,4]<br>Output: 6<br>Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.<br>             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.<br>Example 2:</p>
<p>Input: [1,2,3,4,5]<br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>             engaging multiple transactions at the same time. You must sell before buying again.<br>Example 3:</p>
<p>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<h2 id="Solution-One-Brute-Force"><a href="#Solution-One-Brute-Force" class="headerlink" title="Solution One: Brute Force"></a>Solution One: Brute Force</h2><!-- more -->

<h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 321 ms, faster than 14.08% of Java online submissions for Best Time to Buy and Sell Stock III.<br>Memory Usage: 39.6 MB, less than 39.40% of Java online submissions for Best Time to Buy and Sell Stock III.</p>
<h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code-2"><a href="#Java-code-2" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minVal = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> benefit1 = prices[i] - minVal;</span><br><span class="line">            minVal = Math.min(prices[i], minVal);</span><br><span class="line">            <span class="keyword">int</span> curMinVal = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">int</span> benefit2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curMinVal &lt; Integer.MAX_VALUE) </span><br><span class="line">                    benefit2 = Math.max(prices[j] - curMinVal, benefit2);</span><br><span class="line">                curMinVal = Math.min(prices[j], curMinVal);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, benefit1 + benefit2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Dynamic-Programming"><a href="#Solution-Two-Dynamic-Programming" class="headerlink" title="Solution Two: Dynamic Programming"></a>Solution Two: Dynamic Programming</h2><!-- more -->

<h3 id="Result-3"><a href="#Result-3" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 6 ms, faster than 22.19% of Java online submissions for Best Time to Buy and Sell Stock III.<br>Memory Usage: 42.1 MB, less than 5.33% of Java online submissions for Best Time to Buy and Sell Stock III.</p>
<h3 id="Analysis-3"><a href="#Analysis-3" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-3"><a href="#Java-code-3" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] benefits = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> minVal = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">            benefits[i] = Math.max(benefits[i - <span class="number">1</span>], prices[i] - minVal);</span><br><span class="line">            minVal = Math.min(minVal, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = benefits[N - <span class="number">1</span>];</span><br><span class="line">        benefits[N - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxVal = prices[N - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            benefits[i] = Math.max(benefits[i + <span class="number">1</span>], maxVal - prices[i]);</span><br><span class="line">            maxVal = Math.max(maxVal, prices[i]);</span><br><span class="line">            ans = Math.max(ans, benefits[i] + (i &gt; <span class="number">0</span> ? benefits[i - <span class="number">1</span>] : <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#Leetcode-188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="Leetcode 188 - Best Time to Buy and Sell Stock IV"></a>Leetcode 188 - Best Time to Buy and Sell Stock IV</h1><p><strong>Description</strong><br>Say you have an array for which the i-th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>Example 1:</p>
<p>Input: [2,4,1], k = 2<br>Output: 2<br>Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.<br>Example 2:</p>
<p>Input: [3,2,6,5,0,3], k = 2<br>Output: 7<br>Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.<br>             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</p>
<h2 id="Solution-One-Dynamic-Programming"><a href="#Solution-One-Dynamic-Programming" class="headerlink" title="Solution One: Dynamic Programming"></a>Solution One: Dynamic Programming</h2><!-- more -->

<h3 id="Result-4"><a href="#Result-4" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 96.28% of Java online submissions for Best Time to Buy and Sell Stock IV.<br>Memory Usage: 39.4 MB, less than 59.87% of Java online submissions for Best Time to Buy and Sell Stock IV.</p>
<h3 id="Analysis-4"><a href="#Analysis-4" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(nk), Time Complexity: O(nk).</p>
<h3 id="Java-code-4"><a href="#Java-code-4" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= len / <span class="number">2</span>) <span class="keyword">return</span> quickSolve(prices);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] t = <span class="keyword">new</span> <span class="keyword">int</span>[k + <span class="number">1</span>][len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpMax =  -prices[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                t[i][j] = Math.max(t[i][j - <span class="number">1</span>], prices[j] + tmpMax);</span><br><span class="line">                tmpMax =  Math.max(tmpMax, t[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t[k][len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">quickSolve</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">            <span class="comment">// as long as there is a price gap, we gain a profit.</span></span><br><span class="line">            <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>]) profit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 128 - Longest Consecutive Sequence</title>
    <url>/2020/06/02/leetcode-128/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</p>
<p>Your algorithm should run in O(n) complexity.</p>
<p>Example:</p>
<p>Input: [100, 4, 200, 1, 3, 2]<br>Output: 4<br>Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</p>
<h2 id="Solution-One-HashSet-and-Intelligent-Sequence-Building"><a href="#Solution-One-HashSet-and-Intelligent-Sequence-Building" class="headerlink" title="Solution One: HashSet and Intelligent Sequence Building"></a>Solution One: HashSet and Intelligent Sequence Building</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 64.30% of Java online submissions for Longest Consecutive Sequence.<br>Memory Usage: 39.9 MB, less than 15.52% of Java online submissions for Longest Consecutive Sequence.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (set.contains(num++)) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 15 - 3Sum</title>
    <url>/2020/06/05/leetcode-15/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:</p>
<p>The solution set must not contain duplicate triplets.</p>
<p>Example:</p>
<p>Given array nums = [-1, 0, 1, 2, -1, -4],</p>
<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<h2 id="Solution-One-HashSet"><a href="#Solution-One-HashSet" class="headerlink" title="Solution One: HashSet"></a>Solution One: HashSet</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 56 ms, faster than 31.25% of Java online submissions for 3Sum.<br>Memory Usage: 43 MB, less than 95.82% of Java online submissions for 3Sum.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity:<br>Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; ansMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            ansMap.put(num, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            Map&lt;Integer, Integer&gt; tupleMap = ansMap.get(nums[i]);</span><br><span class="line">            <span class="keyword">int</span> m = i + <span class="number">1</span>, n = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (m &lt; n) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[m] + nums[n];</span><br><span class="line">                <span class="keyword">if</span> (sum == - nums[i]) &#123;</span><br><span class="line">                    <span class="comment">// add to ansMap</span></span><br><span class="line">                    tupleMap.put(nums[m++], nums[n--]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; - nums[i]) &#123;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    m++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// from map to list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : ansMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : ansMap.get(i).entrySet()) &#123;</span><br><span class="line">                ans.add(Arrays.asList(</span><br><span class="line">                    <span class="keyword">new</span> Integer[]&#123;i, entry.getKey(), entry.getValue()&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-without-hashset"><a href="#Solution-Two-without-hashset" class="headerlink" title="Solution Two: without hashset"></a>Solution Two: without hashset</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 20 ms, faster than 64.67% of Java online submissions for 3Sum.<br>Memory Usage: 43.4 MB, less than 71.73% of Java online submissions for 3Sum.</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] num) &#123;</span><br><span class="line">        Arrays.sort(num);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length-<span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; num[i] != num[i-<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">int</span> lo = i+<span class="number">1</span>, hi = num.length-<span class="number">1</span>, sum = <span class="number">0</span> - num[i];</span><br><span class="line">                <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num[lo] + num[hi] == sum) &#123;</span><br><span class="line">                        res.add(Arrays.asList(num[i], num[lo], num[hi]));</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; num[lo] == num[lo+<span class="number">1</span>]) lo++;</span><br><span class="line">                        <span class="keyword">while</span> (lo &lt; hi &amp;&amp; num[hi] == num[hi-<span class="number">1</span>]) hi--;</span><br><span class="line">                        lo++; hi--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[lo] + num[hi] &lt; sum) lo++;</span><br><span class="line">                    <span class="keyword">else</span> hi--;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 179 - Largest Number</title>
    <url>/2020/06/01/leetcode-179/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a list of non negative integers, arrange them such that they form the largest number.</p>
<p>Example 1:</p>
<p>Input: [10,2]<br>Output: “210”<br>Example 2:</p>
<p>Input: [3,30,34,5,9]<br>Output: “9534330”<br>Note: The result may be very large, so you need to return a string instead of an integer.</p>
<h2 id="Solution-One-Sorting-via-Custom-Comparator"><a href="#Solution-One-Sorting-via-Custom-Comparator" class="headerlink" title="Solution One: Sorting via Custom Comparator"></a>Solution One: Sorting via Custom Comparator</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 6 ms, faster than 48.79% of Java online submissions for Largest Number.<br>Memory Usage: 39 MB, less than 6.67% of Java online submissions for Largest Number.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(nlogn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;String&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (s2 + s1).compareTo((s1 + s2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            queue.add(String.valueOf(num));</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            sb.append(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove leading zero</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; sb.length() - <span class="number">1</span> &amp;&amp; sb.charAt(start) == <span class="string">'0'</span>) </span><br><span class="line">            start++;</span><br><span class="line">        <span class="keyword">return</span> sb.substring(start).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 206 - Reverse Linked List</title>
    <url>/2020/06/06/leetcode-206/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Reverse a singly linked list.</p>
<p>Example:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br>Follow up:</p>
<p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<h2 id="Solution-One-Recursive"><a href="#Solution-One-Recursive" class="headerlink" title="Solution One: Recursive"></a>Solution One: Recursive</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.<br>Memory Usage: 40.4 MB, less than 5.03% of Java online submissions for Reverse Linked List.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode p = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-One-Iterative"><a href="#Solution-One-Iterative" class="headerlink" title="Solution One: Iterative"></a>Solution One: Iterative</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Reverse Linked List.<br>Memory Usage: 39.2 MB, less than 72.93% of Java online submissions for Reverse Linked List.</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = tmp.next;</span><br><span class="line">            tmp.next = dummy.next;</span><br><span class="line">            dummy.next = tmp;</span><br><span class="line">            tmp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 22 - Generate Parentheses</title>
    <url>/2020/06/06/leetcode-22/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:</p>
<p>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 83.78% of Java online submissions for Generate Parentheses.<br>Memory Usage: 39.2 MB, less than 94.43% of Java online submissions for Generate Parentheses.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>See<br><a href="https://leetcode.com/problems/generate-parentheses/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/generate-parentheses/solution/</a></p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        place(<span class="string">""</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(String s, <span class="keyword">int</span> open, <span class="keyword">int</span> close)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (open == <span class="number">0</span> &amp;&amp; close == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open &gt; close || open &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// place open parenthese</span></span><br><span class="line">        place(s + <span class="string">"("</span>, open - <span class="number">1</span>, close);</span><br><span class="line">        <span class="comment">// place close parenthese</span></span><br><span class="line">        place(s + <span class="string">")"</span>, open, close - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 173 - Binary Search Tree Iterator</title>
    <url>/2020/06/01/leetcode-173/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</p>
<p>Calling next() will return the next smallest number in the BST.</p>
<h2 id="Solution-One-Flatten-BST"><a href="#Solution-One-Flatten-BST" class="headerlink" title="Solution One: Flatten BST"></a>Solution One: Flatten BST</h2><h2 id="Solution-Two-Controlled-Recursion"><a href="#Solution-Two-Controlled-Recursion" class="headerlink" title="Solution Two: Controlled Recursion"></a>Solution Two: Controlled Recursion</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 14 ms, faster than 99.90% of Java online submissions for Binary Search Tree Iterator.<br>Memory Usage: 45 MB, less than 100.00% of Java online submissions for Binary Search Tree Iterator.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H).<br>Time Complexity: next() - the amortized (average) time complexity for this function would still be O(1).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayDeque&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        addNode(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        addNode(node.right);</span><br><span class="line">        <span class="keyword">return</span> node.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        TreeNode tmp = node;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(tmp);</span><br><span class="line">            tmp = tmp.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 2 - Add Two Numbers</title>
    <url>/2020/06/03/leetcode-2/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 = 807.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Add Two Numbers.<br>Memory Usage: 39.3 MB, less than 99.69% of Java online submissions for Add Two Numbers.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tmp = dummy, node1 = l1, node2 = l2;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span> || node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n1 = node1.val;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                n2 = node2.val;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = n1 + n2 + carry;</span><br><span class="line">            carry = cur / <span class="number">10</span>;</span><br><span class="line">            cur = cur % <span class="number">10</span>;</span><br><span class="line">            tmp.next = <span class="keyword">new</span> ListNode(cur);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) tmp.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 236 - Lowest Common Ancestor of a Binary Tree</title>
    <url>/2020/06/01/leetcode-236/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 100.00% of Java online submissions for Lowest Common Ancestor of a Binary Tree.<br>Memory Usage: 42 MB, less than 5.55% of Java online submissions for Lowest Common Ancestor of a Binary Tree.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(maximum height of p and q) because of recursion.<br>Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 4 - Median of Two Sorted Arrays</title>
    <url>/2020/06/04/leetcode-4/</url>
    <content><![CDATA[<p><strong>Description</strong><br>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Amazon</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 37 - Sudoku Solver &amp; 36 - Valid Sudoku</title>
    <url>/2020/06/04/leetcode-37/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>
<p>A sudoku solution must satisfy all of the following rules:</p>
<p>Each of the digits 1-9 must occur exactly once in each row.<br>Each of the digits 1-9 must occur exactly once in each column.<br>Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.<br>Empty cells are indicated by the character ‘.’.</p>
<p>Note:</p>
<p>The given board contain only digits 1-9 and the character ‘.’.<br>You may assume that the given Sudoku puzzle will have a single unique solution.<br>The given board size is always 9x9.</p>
<h2 id="Solution-One-Backtracking"><a href="#Solution-One-Backtracking" class="headerlink" title="Solution One: Backtracking"></a>Solution One: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 86.35% of Java online submissions for Sudoku Solver.<br>Memory Usage: 36.7 MB, less than 24.56% of Java online submissions for Sudoku Solver.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time complexity: Time complexity is constant here since the board size is fixed and there is no N-parameter to measure. Though let’s discuss the number of operations needed : (9!)^9</p>
<p>Space complexity : the board size is fixed, and the space is used to store board, rows, columns and boxes structures, each contains 81 elements.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] rowRecord, colRecord, boxRecord;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        rowRecord = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        colRecord = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        boxRecord = <span class="keyword">new</span> <span class="keyword">boolean</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = board[i][j] - <span class="string">'0'</span>;</span><br><span class="line">                    insertNum(board, i, j, num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> boxIndex = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!canPlace(board, i, j, k))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                insertNum(board, i, j, k);</span><br><span class="line">                <span class="keyword">if</span>(placeNext(board, i, j))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                removeNum(board, i, j, k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> placeNext(board, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">placeNext</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == N - <span class="number">1</span> &amp;&amp; j == N - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> backtracking(board, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> backtracking(board, i + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canPlace</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> boxIndex = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> !rowRecord[i][num - <span class="number">1</span>] &amp;&amp; !colRecord[j][num - <span class="number">1</span>]</span><br><span class="line">            &amp;&amp; !boxRecord[boxIndex][num - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertNum</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        board[i][j] = (<span class="keyword">char</span>)(<span class="string">'0'</span> + num);</span><br><span class="line">        <span class="keyword">int</span> boxIndex = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">        rowRecord[i][num - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        colRecord[j][num - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        boxRecord[boxIndex][num - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNum</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">        <span class="keyword">int</span> boxIndex = i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">        rowRecord[i][num - <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        colRecord[j][num - <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        boxRecord[boxIndex][num - <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-36-Valid-Sudoku"><a href="#Leetcode-36-Valid-Sudoku" class="headerlink" title="Leetcode 36 - Valid Sudoku"></a>Leetcode 36 - Valid Sudoku</h1><p><strong>Description</strong><br>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<p>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Valid Sudoku.<br>Memory Usage: 39.7 MB, less than 50.60% of Java online submissions for Valid Sudoku.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(1).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] row = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">        <span class="keyword">int</span>[][] col = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">        <span class="keyword">int</span>[][] box = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> num = board[i][j] - <span class="string">'1'</span>;</span><br><span class="line">                <span class="keyword">int</span> boxIndex = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span>;</span><br><span class="line">                <span class="comment">// row</span></span><br><span class="line">                <span class="keyword">if</span> (row[i][num] != <span class="number">0</span> </span><br><span class="line">                    || col[j][num] != <span class="number">0</span></span><br><span class="line">                    || box[boxIndex][num] != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                row[i][num]++;</span><br><span class="line">                col[j][num]++;</span><br><span class="line">                box[boxIndex][num]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 211 - Add and Search Word - Data structure design</title>
    <url>/2020/06/02/leetcode-211/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<h2 id="Solution-One-Trie-with-HashMap"><a href="#Solution-One-Trie-with-HashMap" class="headerlink" title="Solution One: Trie with HashMap"></a>Solution One: Trie with HashMap</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 67 ms, faster than 22.30% of Java online submissions for Add and Search Word - Data structure design.<br>Memory Usage: 50.8 MB, less than 100.00% of Java online submissions for Add and Search Word - Data structure design.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(number of words * average length of words).<br>Time Complexity: O(L).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        Map&lt;Character, TrieNode&gt; nextMap;</span><br><span class="line">        String word;</span><br><span class="line">        TrieNode(<span class="keyword">char</span> ch, String w) &#123;</span><br><span class="line">            c = ch;</span><br><span class="line">            nextMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            word = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode(<span class="string">'.'</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWord</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        TrieNode tmp = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> curC = word.charAt(i);</span><br><span class="line">            tmp.nextMap.putIfAbsent(curC, <span class="keyword">new</span> TrieNode(curC, <span class="keyword">null</span>));</span><br><span class="line">            tmp = tmp.nextMap.get(curC);</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.word = word;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span> || word.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ArrayDeque&lt;TrieNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="comment">// match</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> curC = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            updateQueue(queue,curC);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check queue</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.poll().word != <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateQueue</span><span class="params">(ArrayDeque&lt;TrieNode&gt; queue, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = queue.size();</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TrieNode preNode = queue.poll();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> curC : preNode.nextMap.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(c != <span class="string">'.'</span> &amp;&amp; curC != c))</span><br><span class="line">                    queue.offer(preNode.nextMap.get(curC));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj.addWord(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Trie-with-Array"><a href="#Solution-Two-Trie-with-Array" class="headerlink" title="Solution Two: Trie with Array"></a>Solution Two: Trie with Array</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 445 - Add Two Numbers II</title>
    <url>/2020/06/04/leetcode-445/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Follow up:<br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
<p>Example:</p>
<p>Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 98.24% of Java online submissions for Add Two Numbers II.<br>Memory Usage: 39.3 MB, less than 93.70% of Java online submissions for Add Two Numbers II.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        l1 = reverse(l1);</span><br><span class="line">        l2 = reverse(l2);</span><br><span class="line">        ListNode node1 = l1, node2 = l2;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span> || node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = node1 == <span class="keyword">null</span> ? <span class="number">0</span> : node1.val;</span><br><span class="line">            <span class="keyword">int</span> num2 = node2 == <span class="keyword">null</span> ? <span class="number">0</span> : node2.val;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 + num2 + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            dummy.next = <span class="keyword">new</span> ListNode(sum, dummy.next);</span><br><span class="line">            <span class="keyword">if</span> (node1 != <span class="keyword">null</span>) node1 = node1.next;</span><br><span class="line">            <span class="keyword">if</span> (node2 != <span class="keyword">null</span>) node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) dummy.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>, dummy.next);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tmp = node;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = tmp.next;</span><br><span class="line">            tmp.next = dummy.next;</span><br><span class="line">            dummy.next = tmp;</span><br><span class="line">            tmp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 621 - Task Scheduler</title>
    <url>/2020/06/02/leetcode-621/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>
<p>However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>
<p>You need to return the least number of intervals the CPU will take to finish all the given tasks.</p>
<h2 id="Solution-One-Greedy"><a href="#Solution-One-Greedy" class="headerlink" title="Solution One: Greedy"></a>Solution One: Greedy</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 99.68% of Java online submissions for Task Scheduler.<br>Memory Usage: 40.9 MB, less than 8.82% of Java online submissions for Task Scheduler.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(26), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] countArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> maxFreq = <span class="number">0</span>, maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> t : tasks) &#123;</span><br><span class="line">            <span class="keyword">int</span> freq = countArr[t - <span class="string">'A'</span>] + <span class="number">1</span>;</span><br><span class="line">            countArr[t - <span class="string">'A'</span>] = freq;</span><br><span class="line">            <span class="keyword">if</span> (freq &gt; maxFreq) &#123;</span><br><span class="line">                maxFreq = freq;</span><br><span class="line">                maxCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freq == maxFreq) &#123;</span><br><span class="line">                maxCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mainTasks = maxFreq * maxCount;</span><br><span class="line">        <span class="keyword">int</span> emptyCol = n - Math.min(n, maxCount - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> emptySlots = emptyCol * (maxFreq - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> otherTasks = tasks.length - mainTasks;</span><br><span class="line">        <span class="keyword">int</span> idles = Math.max(<span class="number">0</span>, emptySlots - otherTasks);</span><br><span class="line">        <span class="keyword">return</span> tasks.length + idles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 695 - Max Area of Island</title>
    <url>/2020/06/05/leetcode-695/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 99.77% of Java online submissions for Max Area of Island.<br>Memory Usage: 39.8 MB, less than 65.71% of Java online submissions for Max Area of Island.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(R * C), for recursion<br>Time Complexity: O(R * C)</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M, N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        M = grid.length;</span><br><span class="line">        N = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                ans = Math.max(ans, countOne(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= M || j &lt; <span class="number">0</span> || j &gt;= N || grid[i][j] == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + countOne(grid, i + <span class="number">1</span>, j) + countOne(grid, i - <span class="number">1</span>, j) </span><br><span class="line">            + countOne(grid, i, j - <span class="number">1</span>) + countOne(grid, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Microsft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 987 - Vertical Order Traversal of a Binary Tree</title>
    <url>/2020/06/01/leetcode-987/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, return the vertical order traversal of its nodes values.</p>
<p>For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).</p>
<p>Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</p>
<p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p>
<p>Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.</p>
<h2 id="Solution-One-BFS-with-internal-class"><a href="#Solution-One-BFS-with-internal-class" class="headerlink" title="Solution One: BFS with internal class"></a>Solution One: BFS with internal class</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 70.59% of Java online submissions for Vertical Order Traversal of a Binary Tree.<br>Memory Usage: 39.4 MB, less than 6.67% of Java online submissions for Vertical Order Traversal of a Binary Tree.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(nlog(n/k)).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        TreeNode curNode;</span><br><span class="line">        <span class="keyword">int</span> X;</span><br><span class="line">        <span class="keyword">int</span> Y;</span><br><span class="line">        Node(TreeNode cur, <span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            curNode = cur;</span><br><span class="line">            X = x;</span><br><span class="line">            Y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        TreeMap&lt;Integer, List&lt;Node&gt;&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        ArrayDeque&lt;Node&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Node(root, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> H = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            H++;</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node node = queue.poll();</span><br><span class="line">                TreeNode curNode = node.curNode;</span><br><span class="line">                <span class="comment">// add to list</span></span><br><span class="line">                List&lt;Node&gt; list = map.getOrDefault(node.X, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                <span class="keyword">int</span> index = list.size();</span><br><span class="line">                <span class="keyword">while</span> (index - <span class="number">1</span> &gt;= <span class="number">0</span> </span><br><span class="line">                       &amp;&amp; list.get(index - <span class="number">1</span>).X == node.X</span><br><span class="line">                       &amp;&amp; list.get(index - <span class="number">1</span>).Y == node.Y</span><br><span class="line">                       &amp;&amp; list.get(index - <span class="number">1</span>).curNode.val &gt; curNode.val) &#123;</span><br><span class="line">                    index--;</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(index, node);</span><br><span class="line">                map.put(node.X, list);</span><br><span class="line">                <span class="comment">// add children</span></span><br><span class="line">                <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>) queue.offer(<span class="keyword">new</span> Node(curNode.left, node.X - <span class="number">1</span>, H));</span><br><span class="line">                <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>) queue.offer(<span class="keyword">new</span> Node(curNode.right, node.X + <span class="number">1</span>, H));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : map.keySet()) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Node node : map.get(i)) &#123;</span><br><span class="line">                list.add(node.curNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-BFS-with-Pair"><a href="#Solution-Two-BFS-with-Pair" class="headerlink" title="Solution Two: BFS with Pair"></a>Solution Two: BFS with Pair</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 70.59% of Java online submissions for Vertical Order Traversal of a Binary Tree.<br>Memory Usage: 39.5 MB, less than 6.67% of Java online submissions for Vertical Order Traversal of a Binary Tree.</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key: column; value: &lt;row, node_value&gt;</span></span><br><span class="line">    Map&lt;Integer, ArrayList&lt;Pair&lt;Integer, Integer&gt;&gt;&gt; columnTable = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">int</span> minColumn = <span class="number">0</span>, maxColumn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tuples of &lt;column, &lt;row, value&gt;&gt;</span></span><br><span class="line">        Queue&lt;Pair&lt;TreeNode, Pair&lt;Integer, Integer&gt;&gt;&gt; queue = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Pair(root, <span class="keyword">new</span> Pair(row, column)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Pair&lt;TreeNode, Pair&lt;Integer, Integer&gt;&gt; p = queue.poll();</span><br><span class="line">            root = p.getKey();</span><br><span class="line">            row = p.getValue().getKey();</span><br><span class="line">            column = p.getValue().getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!columnTable.containsKey(column)) &#123;</span><br><span class="line">                    columnTable.put(column, <span class="keyword">new</span> ArrayList&lt;Pair&lt;Integer, Integer&gt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                columnTable.get(column).add(<span class="keyword">new</span> Pair&lt;&gt;(row, root.val));</span><br><span class="line">                minColumn = Math.min(minColumn, column);</span><br><span class="line">                maxColumn = Math.max(maxColumn, column);</span><br><span class="line"></span><br><span class="line">                queue.offer(<span class="keyword">new</span> Pair(root.left, <span class="keyword">new</span> Pair(row + <span class="number">1</span>, column - <span class="number">1</span>)));</span><br><span class="line">                queue.offer(<span class="keyword">new</span> Pair(root.right, <span class="keyword">new</span> Pair(row + <span class="number">1</span>, column + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; verticalTraversal(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step 1). BFS traversal</span></span><br><span class="line">        <span class="keyword">this</span>.BFS(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step 2). retrieve the value from the columnTable</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = minColumn; i &lt; maxColumn + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// order by both "row" and "value"</span></span><br><span class="line">            Collections.sort(columnTable.get(i), <span class="keyword">new</span> Comparator&lt;Pair&lt;Integer, Integer&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Pair&lt;Integer, Integer&gt; p1, Pair&lt;Integer, Integer&gt; p2)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (p1.getKey().equals(p2.getKey()))</span><br><span class="line">                        <span class="keyword">return</span> p1.getValue() - p2.getValue();</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> p1.getKey() - p2.getKey();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; sortedColumn = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            <span class="keyword">for</span> (Pair&lt;Integer, Integer&gt; p : columnTable.get(i)) &#123;</span><br><span class="line">                sortedColumn.add(p.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            output.add(sortedColumn);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Three-DFS-with-Pair"><a href="#Solution-Three-DFS-with-Pair" class="headerlink" title="Solution Three: DFS with Pair"></a>Solution Three: DFS with Pair</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 11 - Container With Most Water</title>
    <url>/2020/06/07/leetcode-11/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.</p>
<h2 id="Solution-One-Two-Pointer"><a href="#Solution-One-Two-Pointer" class="headerlink" title="Solution One: Two Pointer"></a>Solution One: Two Pointer</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 95.11% of Java online submissions for Container With Most Water.<br>Memory Usage: 39.8 MB, less than 54.75% of Java online submissions for Container With Most Water.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height == <span class="keyword">null</span> || height.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            ans = Math.max((j - i) * Math.min(height[i], height[j]), ans);</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Two Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 10 - Regular Expression Matching</title>
    <url>/2020/06/10/leetcode-10/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.</p>
<p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.<br>The matching should cover the entire input string (not partial).</p>
<p>Note:</p>
<p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like . or *.</p>
<h2 id="Solution-One-Recursion"><a href="#Solution-One-Recursion" class="headerlink" title="Solution One: Recursion"></a>Solution One: Recursion</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 66 ms, faster than 21.90% of Java online submissions.<br>Memory Usage: 39.3 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/regular-expression-matching/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/regular-expression-matching/solution/</a></p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> check(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s, <span class="keyword">int</span> i, String p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length()) <span class="keyword">return</span> i == s.length();</span><br><span class="line">        <span class="keyword">char</span> tar = p.charAt(j);</span><br><span class="line">        <span class="keyword">char</span> cur = i &lt; s.length() ? s.charAt(i) : <span class="string">'?'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> firstMatch = (i &lt; s.length() &amp;&amp; ((cur == tar) || (tar == <span class="string">'.'</span>)));</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (check(s, i, p, j + <span class="number">2</span>) || </span><br><span class="line">                    (firstMatch &amp;&amp; check(s, i + <span class="number">1</span>, p, j)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstMatch &amp;&amp; check(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Recursion-with-memorization"><a href="#Solution-Two-Recursion-with-memorization" class="headerlink" title="Solution Two: Recursion with memorization"></a>Solution Two: Recursion with memorization</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 92.73% of Java online submissions for Regular Expression Matching.<br>Memory Usage: 40 MB, less than 17.18% of Java online submissions for Regular Expression Matching.</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>][p.length()];</span><br><span class="line">        <span class="keyword">return</span> check(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String s, <span class="keyword">int</span> i, String p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length()) <span class="keyword">return</span> i == s.length();</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="number">0</span>) <span class="keyword">return</span> memo[i][j] == <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> tar = p.charAt(j);</span><br><span class="line">        <span class="keyword">char</span> cur = i &lt; s.length() ? s.charAt(i) : <span class="string">'?'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> firstMatch = (i &lt; s.length() &amp;&amp; ((cur == tar) || (tar == <span class="string">'.'</span>)));</span><br><span class="line">        <span class="keyword">boolean</span> tmp;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">            tmp = (check(s, i, p, j + <span class="number">2</span>) || </span><br><span class="line">                    (firstMatch &amp;&amp; check(s, i + <span class="number">1</span>, p, j)));</span><br><span class="line">            memo[i][j] = tmp ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = firstMatch &amp;&amp; check(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        memo[i][j] = tmp ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 301 - Remove Invalid Parentheses</title>
    <url>/2020/06/10/leetcode-301/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p>
<p>Note: The input string may contain letters other than the parentheses ( and ).</p>
<p>Example 1:</p>
<p>Input: “()())()”<br>Output: [“()()()”, “(())()”]<br>Example 2:</p>
<p>Input: “(a)())()”<br>Output: [“(a)()()”, “(a())()”]<br>Example 3:</p>
<p>Input: “)(“<br>Output: [“”]</p>
<h2 id="Solution-One-Backtracking"><a href="#Solution-One-Backtracking" class="headerlink" title="Solution One: Backtracking"></a>Solution One: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 78.59% of Java online submissions for Remove Invalid Parentheses.<br>Memory Usage: 38.3 MB, less than 90.13% of Java online submissions for Remove Invalid Parentheses.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(2^N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Status</span></span>&#123;</span><br><span class="line">        StringBuilder sb;</span><br><span class="line">        <span class="keyword">int</span> leftCount = <span class="number">0</span>; <span class="comment">// additional count</span></span><br><span class="line">        <span class="keyword">int</span> rightCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftToRemove;</span><br><span class="line">        <span class="keyword">int</span> rightToRemove;</span><br><span class="line">        Status(StringBuilder s, <span class="keyword">int</span> leftTar, <span class="keyword">int</span> rightTar) &#123;</span><br><span class="line">            sb = s;</span><br><span class="line">            leftToRemove = leftTar;</span><br><span class="line">            rightToRemove = rightTar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Set&lt;String&gt; ansSet;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">removeInvalidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        ansSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// count numbers to be removed</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="string">'('</span>) left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left &gt; <span class="number">0</span>) left--;</span><br><span class="line">                <span class="keyword">else</span> right++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Status status = <span class="keyword">new</span> Status(<span class="keyword">new</span> StringBuilder(), left, right);</span><br><span class="line">        buildValidString(s, <span class="number">0</span>, status);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(ansSet);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildValidString</span><span class="params">(String s, <span class="keyword">int</span> index, Status status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status.leftCount == status.rightCount</span><br><span class="line">           &amp;&amp; status.leftToRemove == <span class="number">0</span> &amp;&amp; status.rightToRemove == <span class="number">0</span>)</span><br><span class="line">                ansSet.add(status.sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> cur = s.charAt(index);</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="string">'('</span>) &#123;</span><br><span class="line">            <span class="comment">// try to remove</span></span><br><span class="line">            <span class="keyword">if</span> (status.leftToRemove &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                status.leftToRemove--;</span><br><span class="line">                buildValidString(s, index + <span class="number">1</span>, status);</span><br><span class="line">                status.leftToRemove++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// try to add</span></span><br><span class="line">            status.leftCount++;</span><br><span class="line">            status.sb.append(cur);</span><br><span class="line">            buildValidString(s, index + <span class="number">1</span>, status);</span><br><span class="line">            status.leftCount--;</span><br><span class="line">            status.sb.deleteCharAt(status.sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="comment">// try to remove</span></span><br><span class="line">            <span class="keyword">if</span> (status.rightToRemove &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                status.rightToRemove--;</span><br><span class="line">                buildValidString(s, index + <span class="number">1</span>, status);</span><br><span class="line">                status.rightToRemove++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// try to add</span></span><br><span class="line">            <span class="keyword">if</span> (status.leftCount &gt; status.rightCount) &#123;</span><br><span class="line">                status.rightCount++;</span><br><span class="line">                status.sb.append(cur);</span><br><span class="line">                buildValidString(s, index + <span class="number">1</span>, status);</span><br><span class="line">                status.rightCount--;</span><br><span class="line">                status.sb.deleteCharAt(status.sb.length() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status.sb.append(cur);</span><br><span class="line">            buildValidString(s, index + <span class="number">1</span>, status);</span><br><span class="line">            status.sb.deleteCharAt(status.sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 394 - Decode String</title>
    <url>/2020/06/08/leetcode-394/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an encoded string, return its decoded string.</p>
<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4].</p>
<p>Example 1:</p>
<p>Input: s = “3[a]2[bc]”<br>Output: “aaabcbc”<br>Example 2:</p>
<p>Input: s = “3[a2[c]]”<br>Output: “accaccacc”</p>
<h2 id="Solution-One-ArrayDeque"><a href="#Solution-One-ArrayDeque" class="headerlink" title="Solution One: ArrayDeque"></a>Solution One: ArrayDeque</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 68.19% of Java online submissions for Decode String.<br>Memory Usage: 37.3 MB, less than 80.83% of Java online submissions for Decode String.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(L * k), Time Complexity: O(L * k).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="string">']'</span>) &#123;</span><br><span class="line">                stack.addLast(String.valueOf(cur));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// get repeated element</span></span><br><span class="line">                StringBuilder sub = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">while</span> (!stack.peekLast().equals(<span class="string">"["</span>)) &#123;</span><br><span class="line">                    sub = sub.insert(<span class="number">0</span>, stack.pollLast());</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pollLast();</span><br><span class="line">                <span class="comment">// get count</span></span><br><span class="line">                String countS = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() </span><br><span class="line">                       &amp;&amp; Character.isDigit(stack.peekLast().charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                    countS = stack.pollLast() + countS;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> count = Integer.parseInt(countS);</span><br><span class="line">                <span class="comment">// make string</span></span><br><span class="line">                String subS = sub.toString();</span><br><span class="line">                <span class="keyword">while</span> (--count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    sub.append(subS);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.addLast(sub.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ans += stack.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Stack</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 49 - Group Anagrams</title>
    <url>/2020/06/07/leetcode-49/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of strings, group anagrams together.</p>
<p>Example:</p>
<p>Input: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Output:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note:</p>
<p>All inputs will be in lowercase.<br>The order of your output does not matter. </p>
<h2 id="Solution-One-sort"><a href="#Solution-One-sort" class="headerlink" title="Solution One: sort"></a>Solution One: sort</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 9 ms, faster than 43.75% of Java online submissions for Group Anagrams.<br>Memory Usage: 42.8 MB, less than 46.55% of Java online submissions for Group Anagrams.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(NK), Time Complexity: O(NKlogK).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : strs) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] curArr = s.toCharArray();</span><br><span class="line">            Arrays.sort(curArr);</span><br><span class="line">            String cur = Arrays.toString(curArr);</span><br><span class="line">            List&lt;String&gt; list = map.getOrDefault(cur, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list.add(s);</span><br><span class="line">            map.put(cur, list);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// from map to list</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList(map.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-One-count"><a href="#Solution-One-count" class="headerlink" title="Solution One: count"></a>Solution One: count</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 53 - Maximum Subarray</title>
    <url>/2020/06/11/leetcode-53/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p>Example:</p>
<p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.<br>Follow up:</p>
<p>If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h2 id="Solution-One-Greedy"><a href="#Solution-One-Greedy" class="headerlink" title="Solution One: Greedy"></a>Solution One: Greedy</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 67.14% of Java online submissions for Maximum Subarray.<br>Memory Usage: 41.4 MB, less than 12.86% of Java online submissions for Maximum Subarray.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minSum = <span class="number">0</span>, ans = Integer.MIN_VALUE, curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            curSum += nums[i];</span><br><span class="line">            ans = Math.max(curSum - minSum, ans);</span><br><span class="line">            minSum = Math.min(minSum, curSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Divide-and-Conquer"><a href="#Solution-Two-Divide-and-Conquer" class="headerlink" title="Solution Two: Divide and Conquer"></a>Solution Two: Divide and Conquer</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 68 - Text Justification</title>
    <url>/2020/06/11/leetcode-68/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ‘ ‘ when necessary so that each line has exactly maxWidth characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left justified and no extra space is inserted between words.</p>
<p>Note:</p>
<p>A word is defined as a character sequence consisting of non-space characters only.<br>Each word’s length is guaranteed to be greater than 0 and not exceed maxWidth.<br>The input array words contains at least one word.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 53.98% of Java online submissions for Text Justification.<br>Memory Usage: 39.5 MB, less than 11.08% of Java online submissions for Text Justification.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        fill(words, <span class="number">0</span>, maxWidth);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; curList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        curList.add(words[start]);</span><br><span class="line">        sb.append(words[start]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = words[start].length();</span><br><span class="line">        <span class="keyword">int</span> i = start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; words.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (length + <span class="number">1</span> + words[i].length() &gt; maxWidth) <span class="keyword">break</span>;</span><br><span class="line">            length += words[i].length() + <span class="number">1</span>;</span><br><span class="line">            curList.add(words[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if last line</span></span><br><span class="line">        <span class="keyword">if</span> (i == words.length) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; curList.size(); k++) &#123;</span><br><span class="line">                sb.append(<span class="string">" "</span>).append(curList.get(k));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (sb.length() &lt; maxWidth) sb.append(<span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// if not last line</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> minSpace, leftExtra;</span><br><span class="line">            <span class="comment">// if only one word</span></span><br><span class="line">            <span class="keyword">if</span> (curList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                minSpace = maxWidth - length;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (count++ &lt; minSpace) sb.append(<span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// if more than one word</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                minSpace = (maxWidth - length) / (curList.size() - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                leftExtra = (maxWidth - length) % (curList.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; curList.size(); k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> spaceNum = minSpace + (leftExtra-- &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">while</span> (count++ &lt; spaceNum) sb.append(<span class="string">" "</span>);</span><br><span class="line">                    sb.append(curList.get(k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(sb.toString());</span><br><span class="line">        <span class="keyword">if</span> (i &lt; words.length) fill(words, i, maxWidth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 70 - Climbing Stairs</title>
    <url>/2020/06/09/leetcode-70/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are climbing a stair case. It takes n steps to reach to the top.</p>
<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>
<p>Note: Given n will be a positive integer.</p>
<p>Example 1:</p>
<p>Input: 2<br>Output: 2<br>Explanation: There are two ways to climb to the top.</p>
<ol>
<li>1 step + 1 step</li>
<li>2 steps<br>Example 2:</li>
</ol>
<p>Input: 3<br>Output: 3<br>Explanation: There are three ways to climb to the top.</p>
<ol>
<li>1 step + 1 step + 1 step</li>
<li>1 step + 2 steps</li>
<li>2 steps + 1 step</li>
</ol>
<h2 id="Solution-One-Dynamic-Programming"><a href="#Solution-One-Dynamic-Programming" class="headerlink" title="Solution One: Dynamic Programming"></a>Solution One: Dynamic Programming</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Climbing Stairs.<br>Memory Usage: 38 MB, less than 8.44% of Java online submissions for Climbing Stairs.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Fibonacci-Number"><a href="#Solution-Two-Fibonacci-Number" class="headerlink" title="Solution Two: Fibonacci Number"></a>Solution Two: Fibonacci Number</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Climbing Stairs.<br>Memory Usage: 37.9 MB, less than 10.50% of Java online submissions for Climbing Stairs.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> second = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 79 - Word Search</title>
    <url>/2020/06/08/leetcode-79/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<p>Example:</p>
<p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
<p>Given word = “ABCCED”, return true.<br>Given word = “SEE”, return true.<br>Given word = “ABCB”, return false.</p>
<p>Constraints:</p>
<p>board and word consists only of lowercase and uppercase English letters.<br>1 &lt;= board.length &lt;= 200<br>1 &lt;= board[i].length &lt;= 200<br>1 &lt;= word.length &lt;= 10^3</p>
<h2 id="Solution-One-Backtracking"><a href="#Solution-One-Backtracking" class="headerlink" title="Solution One: Backtracking"></a>Solution One: Backtracking</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 38.17% of Java online submissions for Word Search.<br>Memory Usage: 47 MB, less than 12.46% of Java online submissions for Word Search.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(Length of word).<br>Time Complexity: O(m * n * 4^Length).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (search(board, i, j, word, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, String word, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == word.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1000</span> * i + j;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length || j &gt;= board[<span class="number">0</span>].length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span> cur = board[i][j];</span><br><span class="line">        <span class="keyword">char</span> tar = word.charAt(start);</span><br><span class="line">        <span class="keyword">if</span> (cur != tar) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        board[i][j] = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] d : directions) &#123;</span><br><span class="line">            <span class="keyword">int</span> curI = i + d[<span class="number">0</span>], curJ = j + d[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (search(board, curI, curJ, word, start + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = cur;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 7 - Reverse Integer</title>
    <url>/2020/06/11/leetcode-7/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p>Example 1:</p>
<p>Input: 123<br>Output: 321<br>Example 2:</p>
<p>Input: -123<br>Output: -321<br>Example 3:</p>
<p>Input: 120<br>Output: 21<br>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 8.15% of Java online submissions for Reverse Integer.<br>Memory Usage: 37 MB, less than 31.85% of Java online submissions for Reverse Integer.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        String s = String.valueOf(x);</span><br><span class="line">        <span class="keyword">boolean</span> negative = s.charAt(<span class="number">0</span>) == <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">if</span> (negative) s = s.substring(<span class="number">1</span>);</span><br><span class="line">        StringBuilder sb = (<span class="keyword">new</span> StringBuilder(s)).reverse();</span><br><span class="line">        s = sb.toString();</span><br><span class="line">        String max = String.valueOf(Integer.MAX_VALUE);</span><br><span class="line">        String min = String.valueOf(Integer.MIN_VALUE).substring(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((!negative &amp;&amp; s.length() &gt;= max.length() &amp;&amp; s.compareTo(min) &gt; <span class="number">0</span>)</span><br><span class="line">           || (negative &amp;&amp; s.length() &gt;= min.length() &amp;&amp; s.compareTo(min) &gt; <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">int</span> ans = Integer.parseInt(sb.toString());</span><br><span class="line">        <span class="keyword">return</span> negative ? - ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 773 - Sliding Puzzle</title>
    <url>/2020/06/12/leetcode-773/</url>
    <content><![CDATA[<p><strong>Description</strong><br>On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.</p>
<p>A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.</p>
<p>The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].</p>
<p>Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.</p>
<p>Examples:</p>
<p>Input: board = [[1,2,3],[4,0,5]]<br>Output: 1<br>Explanation: Swap the 0 and the 5 in one move.<br>Input: board = [[1,2,3],[5,4,0]]<br>Output: -1<br>Explanation: No number of moves will make the board solved.<br>Input: board = [[4,1,2],[5,0,3]]<br>Output: 5<br>Explanation: 5 is the smallest number of moves that solves the board.<br>An example path:<br>After move 0: [[4,1,2],[5,0,3]]<br>After move 1: [[4,1,2],[0,5,3]]<br>After move 2: [[0,1,2],[4,5,3]]<br>After move 3: [[1,0,2],[4,5,3]]<br>After move 4: [[1,2,0],[4,5,3]]<br>After move 5: [[1,2,3],[4,5,0]]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 20 ms, faster than 33.29% of Java online submissions for Sliding Puzzle.<br>Memory Usage: 39.3 MB, less than 57.52% of Java online submissions for Sliding Puzzle.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time Complexity: O(R∗C∗(R∗C)!), where R,C are the number of rows and columns in board. There are O((R∗C)!) possible board states.</p>
<p>Space Complexity: O(R∗C∗(R∗C)!).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] board;</span><br><span class="line">        <span class="keyword">int</span> depth;</span><br><span class="line">        <span class="keyword">int</span> zeroR;</span><br><span class="line">        <span class="keyword">int</span> zeroC;</span><br><span class="line">        Node(<span class="keyword">int</span>[][] newBoard, <span class="keyword">int</span> d, <span class="keyword">int</span> zr, <span class="keyword">int</span> zc) &#123;</span><br><span class="line">            board = newBoard;</span><br><span class="line">            depth = d;</span><br><span class="line">            zeroR = zr;</span><br><span class="line">            zeroC = zc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] directions;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        String target = Arrays.deepToString(<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;&#125;);</span><br><span class="line">        directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        ArrayDeque&lt;Node&gt; q = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.addLast(<span class="keyword">new</span> Node(board, <span class="number">0</span>, i, j));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.add(Arrays.deepToString(board));</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = q.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node curNode = q.pollFirst();</span><br><span class="line">                <span class="keyword">if</span> (target.equals(Arrays.deepToString(curNode.board))) </span><br><span class="line">                    <span class="keyword">return</span> curNode.depth;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] d : directions) &#123;</span><br><span class="line">                    <span class="keyword">int</span> neiR = curNode.zeroR + d[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> neiC = curNode.zeroC + d[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (neiR &gt;= <span class="number">0</span> &amp;&amp; neiC &gt;= <span class="number">0</span> &amp;&amp; neiR &lt; <span class="number">2</span> &amp;&amp; neiC &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span>[][] newBoard = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i ++)</span><br><span class="line">                            System.arraycopy(curNode.board[i], <span class="number">0</span>, newBoard[i], <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">                        <span class="keyword">int</span> tmp = newBoard[neiR][neiC];</span><br><span class="line">                        newBoard[neiR][neiC] = <span class="number">0</span>;</span><br><span class="line">                        newBoard[curNode.zeroR][curNode.zeroC] = tmp;</span><br><span class="line">                        String newS = Arrays.deepToString(newBoard);</span><br><span class="line">                        <span class="keyword">if</span> (visited.contains(newS))</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        visited.add(newS);</span><br><span class="line">                        q.addLast(<span class="keyword">new</span> Node(newBoard, curNode.depth + <span class="number">1</span>,</span><br><span class="line">                                          neiR, neiC));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 937 - Reorder Data in Log Files</title>
    <url>/2020/06/11/leetcode-937/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You have an array of logs.  Each log is a space delimited string of words.</p>
<p>For each log, the first word in each log is an alphanumeric identifier.  Then, either:</p>
<p>Each word after the identifier will consist only of lowercase letters, or;<br>Each word after the identifier will consist only of digits.<br>We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.</p>
<p>Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.</p>
<p>Return the final order of the logs.</p>
<p>Example 1:</p>
<p>Input: logs = [“dig1 8 1 5 1”,”let1 art can”,”dig2 3 6”,”let2 own kit dig”,”let3 art zero”]<br>Output: [“let1 art can”,”let3 art zero”,”let2 own kit dig”,”dig1 8 1 5 1”,”dig2 3 6”]</p>
<h2 id="Solution-One-Full-Comparator"><a href="#Solution-One-Full-Comparator" class="headerlink" title="Solution One: Full Comparator"></a>Solution One: Full Comparator</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 10 ms, faster than 24.57% of Java online submissions for Reorder Data in Log Files.<br>Memory Usage: 47 MB, less than 5.03% of Java online submissions for Reorder Data in Log Files.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(NlogN).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] reorderLogFiles(String[] logs) &#123;</span><br><span class="line">        Arrays.sort(logs, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                String[] split1 = s1.split(<span class="string">" "</span>, <span class="number">2</span>);</span><br><span class="line">                String[] split2 = s2.split(<span class="string">" "</span>, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">boolean</span> isDigitLog1 = Character.isDigit(split1[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line">                <span class="keyword">boolean</span> isDigitLog2 = Character.isDigit(split2[<span class="number">1</span>].charAt(<span class="number">0</span>));</span><br><span class="line">                <span class="keyword">if</span> (isDigitLog1 &amp;&amp; isDigitLog2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (isDigitLog1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (isDigitLog2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// both letter</span></span><br><span class="line">                <span class="keyword">int</span> cmp = split1[<span class="number">1</span>].compareTo(split2[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> split1[<span class="number">0</span>].compareTo(split2[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> cmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> logs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-One-Partitial-Comparator"><a href="#Solution-One-Partitial-Comparator" class="headerlink" title="Solution One: Partitial Comparator"></a>Solution One: Partitial Comparator</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 88.28% of Java online submissions for Reorder Data in Log Files.<br>Memory Usage: 39.7 MB, less than 81.24% of Java online submissions for Reorder Data in Log Files.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(Min(MlogM, N)).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] reorderLogFiles(String[] logs) &#123;</span><br><span class="line">        String[] ans = <span class="keyword">new</span> String[logs.length];</span><br><span class="line">        List&lt;String&gt; digList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; letList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; logs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = logs[i].indexOf(<span class="string">" "</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> c = logs[i].charAt(index);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                digList.add(logs[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                letList.add(logs[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(letList, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                String[] split1 = s1.split(<span class="string">" "</span>, <span class="number">2</span>);</span><br><span class="line">                String[] split2 = s2.split(<span class="string">" "</span>, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span> (split1[<span class="number">1</span>].equals(split2[<span class="number">1</span>])) <span class="keyword">return</span> split1[<span class="number">0</span>].compareTo(split2[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> split1[<span class="number">1</span>].compareTo(split2[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String s : letList) &#123;</span><br><span class="line">            ans[count++] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String s : digList) &#123;</span><br><span class="line">            ans[count++] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 322 - Coin Change I &amp; II</title>
    <url>/2020/06/06/leetcode-322/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:</p>
<p>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1<br>Example 2:</p>
<p>Input: coins = [2], amount = 3<br>Output: -1<br>Note:<br>You may assume that you have an infinite number of each kind of coin.</p>
<h2 id="Solution-One-DP-bottom-up"><a href="#Solution-One-DP-bottom-up" class="headerlink" title="Solution One: DP, bottom up"></a>Solution One: DP, bottom up</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 11 ms, faster than 86.63% of Java online submissions for Coin Change.<br>Memory Usage: 39 MB, less than 73.27% of Java online submissions for Coin Change.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(amount)<br>Time Complexity: O(amount * n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i - coins[j]] + <span class="number">1</span>, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-518-Coin-Change-2"><a href="#Leetcode-518-Coin-Change-2" class="headerlink" title="Leetcode 518 - Coin Change 2"></a>Leetcode 518 - Coin Change 2</h1><p><strong>Description</strong><br>You are given coins of different denominations and a total amount of money. Write a function to compute the number of combinations that make up that amount. You may assume that you have infinite number of each kind of coin.</p>
<p>Example 1:</p>
<p>Input: amount = 5, coins = [1, 2, 5]<br>Output: 4<br>Explanation: there are four ways to make up the amount:<br>5=5<br>5=2+2+1<br>5=2+1+1+1<br>5=1+1+1+1+1<br>Example 2:</p>
<p>Input: amount = 3, coins = [2]<br>Output: 0<br>Explanation: the amount of 3 cannot be made up just with coins of 2.<br>Example 3:</p>
<p>Input: amount = 10, coins = [10]<br>Output: 1</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 100.00% of Java online submissions for Coin Change 2.<br>Memory Usage: 36.9 MB, less than 74.80% of Java online submissions for Coin Change 2.</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (coins == null || coins.length == 0) return 0;</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 34 - Find First and Last Position of Element in Sorted Array</title>
    <url>/2020/06/09/leetcode-34/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>If the target is not found in the array, return [-1, -1].</p>
<p>Example 1:</p>
<p>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]<br>Example 2:</p>
<p>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p>
<h2 id="Solution-One-Separate-Binary-Search"><a href="#Solution-One-Separate-Binary-Search" class="headerlink" title="Solution One: Separate Binary Search"></a>Solution One: Separate Binary Search</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Find First and Last Position of Element in Sorted Array.<br>Memory Usage: 42.3 MB, less than 96.01% of Java online submissions for Find First and Last Position of Element in Sorted Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> firstIndex = searchFirst(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">if</span> (firstIndex == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// check leftmost one</span></span><br><span class="line">        <span class="keyword">int</span> leftIndex = firstIndex;</span><br><span class="line">        <span class="keyword">if</span> (firstIndex &gt; <span class="number">0</span> &amp;&amp; nums[firstIndex - <span class="number">1</span>] == target)</span><br><span class="line">            leftIndex = searchLeftMost(nums, <span class="number">0</span>, firstIndex - <span class="number">1</span>, target);</span><br><span class="line">        <span class="comment">// check rightmost one</span></span><br><span class="line">        <span class="keyword">int</span> rightIndex = firstIndex;</span><br><span class="line">        <span class="keyword">if</span> (firstIndex &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[firstIndex + <span class="number">1</span>] == target)</span><br><span class="line">            rightIndex = searchRightMost(nums, firstIndex + <span class="number">1</span>, nums.length - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;leftIndex, rightIndex&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start, j = end, mid;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) j = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchLeftMost</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start, j = end, mid;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid &gt; start &amp;&amp; nums[mid - <span class="number">1</span>] == target) j = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) j = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">searchRightMost</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start, j = end, mid;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid &lt; end &amp;&amp; nums[mid + <span class="number">1</span>] == target) i = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) j = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Range-Binary-Search"><a href="#Solution-Two-Range-Binary-Search" class="headerlink" title="Solution Two: Range Binary Search"></a>Solution Two: Range Binary Search</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 33 - Search in Rotated Sorted Array I &amp; II</title>
    <url>/2020/06/06/leetcode-33/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of O(log n).</p>
<p>Example 1:</p>
<p>Input: nums = [4,5,6,7,0,1,2], target = 0<br>Output: 4<br>Example 2:</p>
<p>Input: nums = [4,5,6,7,0,1,2], target = 3<br>Output: -1</p>
<h2 id="Solution-One-Binary-Search"><a href="#Solution-One-Binary-Search" class="headerlink" title="Solution One: Binary Search"></a>Solution One: Binary Search</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Search in Rotated Sorted Array.<br>Memory Usage: 38.7 MB, less than 96.25% of Java online submissions for Search in Rotated Sorted Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[j]) &#123; <span class="comment">// left part is sorted</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// right part is sorted</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[j])</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Search-in-Rotated-Sorted-Array-II"><a href="#Search-in-Rotated-Sorted-Array-II" class="headerlink" title="Search in Rotated Sorted Array II"></a>Search in Rotated Sorted Array II</h1><h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[j]) &#123; <span class="comment">// left part is sorted</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[j]) &#123; <span class="comment">// right part is sorted</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[j])</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 528 - Random Pick with Weight</title>
    <url>/2020/06/03/leetcode-528/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight.</p>
<p>Note:</p>
<p>1 &lt;= w.length &lt;= 10000<br>1 &lt;= w[i] &lt;= 10^5<br>pickIndex will be called at most 10000 times.<br>Example 1:</p>
<p>Input:<br>[“Solution”,”pickIndex”]<br>[[[1]],[]]<br>Output: [null,0]<br>Example 2:</p>
<p>Input:<br>[“Solution”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”,”pickIndex”]<br>[[[1,3]],[],[],[],[],[]]<br>Output: [null,0,1,1,1,0]</p>
<h2 id="Solution-One-Prefix-Sums-with-TreeMap"><a href="#Solution-One-Prefix-Sums-with-TreeMap" class="headerlink" title="Solution One:  Prefix Sums with TreeMap"></a>Solution One:  Prefix Sums with TreeMap</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 29 ms, faster than 34.04% of Java online submissions for Random Pick with Weight.<br>Memory Usage: 43.5 MB, less than 100.00% of Java online submissions for Random Pick with Weight.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(logn), Time Complexity: O(n) for pickIndex.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;Double, Integer&gt; partitionMap;</span><br><span class="line">    Random rand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] w)</span> </span>&#123;</span><br><span class="line">        partitionMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        rand = <span class="keyword">new</span> Random();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : w) &#123;</span><br><span class="line">            sum += (<span class="keyword">double</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> portion = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w.length; i++) &#123;</span><br><span class="line">            portion += (<span class="keyword">double</span>)w[i] / sum;</span><br><span class="line">            partitionMap.put(portion, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> d = rand.nextDouble();</span><br><span class="line">        <span class="keyword">return</span> partitionMap.ceilingEntry(d).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(w);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pickIndex();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-Prefix-Sums-with-Linear-Search-Binary-Search"><a href="#Solution-Two-Prefix-Sums-with-Linear-Search-Binary-Search" class="headerlink" title="Solution Two:  Prefix Sums with Linear Search/Binary Search"></a>Solution Two:  Prefix Sums with Linear Search/Binary Search</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 46 - Permutations &amp;&amp; 47 - Permutations II</title>
    <url>/2020/06/08/leetcode-46/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a collection of distinct integers, return all possible permutations.</p>
<p>Example:</p>
<p>Input: [1,2,3]<br>Output:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<h2 id="Solution-One-Backtracking-with-HashSet"><a href="#Solution-One-Backtracking-with-HashSet" class="headerlink" title="Solution One: Backtracking with HashSet"></a>Solution One: Backtracking with HashSet</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 15.16% of Java online submissions for Permutations.<br>Memory Usage: 42.1 MB.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N!), Time Complexity: O(N!).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(nums, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;Integer&gt; list, Set&lt;Integer&gt; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(i)) <span class="keyword">continue</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            visited.add(i);</span><br><span class="line">            backtrack(nums, list, visited);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            visited.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-Backtracking-with-swap"><a href="#Solution-Two-Backtracking-with-swap" class="headerlink" title="Solution Two: Backtracking with swap"></a>Solution Two: Backtracking with swap</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 91.01% of Java online submissions for Permutations.<br>Memory Usage: 39.8 MB, less than 45.62% of Java online submissions for Permutations.</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ArrayList&lt;Integer&gt; nums,</span></span></span><br><span class="line"><span class="function"><span class="params">                        List&lt;List&lt;Integer&gt;&gt; output,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if all integers are used up</span></span><br><span class="line">    <span class="keyword">if</span> (first == n)</span><br><span class="line">      output.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(nums));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="comment">// place i-th integer first </span></span><br><span class="line">      <span class="comment">// in the current permutation</span></span><br><span class="line">      Collections.swap(nums, first, i);</span><br><span class="line">      <span class="comment">// use next integers to complete the permutations</span></span><br><span class="line">      backtrack(n, nums, output, first + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// backtrack</span></span><br><span class="line">      Collections.swap(nums, first, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// init output list</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; output = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert nums into list since the output is a list of lists</span></span><br><span class="line">    ArrayList&lt;Integer&gt; nums_lst = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">      nums_lst.add(num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    backtrack(n, nums_lst, output, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-47-Permutations-II"><a href="#Leetcode-47-Permutations-II" class="headerlink" title="Leetcode 47 - Permutations II"></a>Leetcode 47 - Permutations II</h1><p><strong>Description</strong></p>
<h2 id="Solution-One-Backtracking-with-swap"><a href="#Solution-One-Backtracking-with-swap" class="headerlink" title="Solution One: Backtracking with swap"></a>Solution One: Backtracking with swap</h2><!-- more -->

<h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.36% of Java online submissions for Permutations II.<br>Memory Usage: 40.4 MB, less than 29.22% of Java online submissions for Permutations II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N!)?</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        permute(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">permute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> first)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == nums.length) &#123;</span><br><span class="line">            ans.add(getList(nums));</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; appeared = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!appeared.contains(nums[i])) &#123;</span><br><span class="line">                swap(nums, i, first);</span><br><span class="line">                permute(nums, first + <span class="number">1</span>);</span><br><span class="line">                swap(nums, i, first);</span><br><span class="line">                appeared.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">getList</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(nums.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) list.add(num);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-60-Permutation-Sequence"><a href="#Leetcode-60-Permutation-Sequence" class="headerlink" title="Leetcode 60 - Permutation Sequence"></a>Leetcode 60 - Permutation Sequence</h1>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 224 - Basic Calculator I &amp; II</title>
    <url>/2020/06/12/leetcode-224/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p>
<h2 id="Solution-One-Stack"><a href="#Solution-One-Stack" class="headerlink" title="Solution One: Stack"></a>Solution One: Stack</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 35 ms, faster than 15.06% of Java online submissions for Basic Calculator.<br>Memory Usage: 45.3 MB, less than 13.27% of Java online submissions for Basic Calculator.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">                stack.push(String.valueOf(cur));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String expr = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span> (!stack.peek().equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">                expr = stack.pop() + expr;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.pop(); <span class="comment">// pop "("</span></span><br><span class="line">            <span class="keyword">int</span> result = process(expr);</span><br><span class="line">            <span class="keyword">if</span> (result &lt; <span class="number">0</span> &amp;&amp; !stack.isEmpty() &amp;&amp; (stack.peek().equals(<span class="string">"+"</span>) || stack.peek().equals(<span class="string">"-"</span>))) &#123;</span><br><span class="line">                String sig = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (sig.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">                    stack.push(<span class="string">"+"</span>);</span><br><span class="line">                    result = - result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(String.valueOf(result));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// last expr</span></span><br><span class="line">        String ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            ans = stack.pop() + ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> process(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">        String num = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="string">'+'</span> || cur == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="comment">// calculate last one</span></span><br><span class="line">                <span class="keyword">if</span> (num.length() &gt; <span class="number">0</span>) ans += flag * (Integer.parseInt(num));</span><br><span class="line">                flag = cur == <span class="string">'+'</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">                num = <span class="string">""</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num += cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += flag * (Integer.parseInt(num));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p>calculate using stack instead of string</p>
<h2 id="Leetcode-227-Basic-Calculator-II"><a href="#Leetcode-227-Basic-Calculator-II" class="headerlink" title="Leetcode 227 - Basic Calculator II"></a>Leetcode 227 - Basic Calculator II</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 22 ms, faster than 22.10% of Java online submissions for Basic Calculator II.<br>Memory Usage: 47.5 MB, less than 9.54% of Java online submissions for Basic Calculator II.</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        String num = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">boolean</span> pending = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(cur)) &#123;</span><br><span class="line">                num += cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur != <span class="string">' '</span>) &#123; <span class="comment">// "+=*/"</span></span><br><span class="line">                <span class="comment">// complete pending caculation */</span></span><br><span class="line">                <span class="keyword">if</span> (pending) num = processTop(stack, num);</span><br><span class="line">                <span class="comment">// push previous number</span></span><br><span class="line">                stack.push(num);</span><br><span class="line">                num = <span class="string">""</span>;</span><br><span class="line">                <span class="comment">// set pending</span></span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="string">'*'</span> || cur == <span class="string">'/'</span>) pending = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> pending = <span class="keyword">false</span>;</span><br><span class="line">                stack.push(String.valueOf(cur));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pending) num = processTop(stack, num);</span><br><span class="line">        stack.push(num);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// calculate + -</span></span><br><span class="line">        <span class="keyword">int</span> ans = Integer.valueOf(stack.removeLast());</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            String flag = stack.removeLast();</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt(stack.removeLast());</span><br><span class="line">            <span class="keyword">if</span> (flag.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">                ans += num1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans -= num1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">processTop</span><span class="params">(ArrayDeque&lt;String&gt; stack, String num)</span> </span>&#123;</span><br><span class="line">        String signal = stack.pop();</span><br><span class="line">        <span class="keyword">int</span> num1 = Integer.valueOf(stack.pop());</span><br><span class="line">        <span class="keyword">if</span> (signal.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            num = String.valueOf(num1 * Integer.valueOf(num));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num = String.valueOf(num1 / Integer.valueOf(num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Improvement-1"><a href="#Improvement-1" class="headerlink" title="Improvement"></a>Improvement</h3><p>calculate once encountered with “*/“</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 148 - Sort List</title>
    <url>/2020/06/15/leetcode-148/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Sort a linked list in O(n log n) time using constant space complexity.</p>
<p>Example 1:</p>
<p>Input: 4-&gt;2-&gt;1-&gt;3<br>Output: 1-&gt;2-&gt;3-&gt;4<br>Example 2:</p>
<p>Input: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>Output: -1-&gt;0-&gt;3-&gt;4-&gt;5</p>
<h2 id="Solution-One-Insertion-Sort"><a href="#Solution-One-Insertion-Sort" class="headerlink" title="Solution One: Insertion Sort"></a>Solution One: Insertion Sort</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1128 ms, faster than 5.01% of Java online submissions for Sort List.<br>Memory Usage: 42.1 MB, less than 39.50% of Java online submissions for Sort List.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(nlogn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Insertion Sort</span></span><br><span class="line">    ListNode dummy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line">        ListNode tail = head;</span><br><span class="line">        <span class="keyword">while</span> (tail != <span class="keyword">null</span> &amp;&amp; tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = extend(tail);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return new tail</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">extend</span><span class="params">(ListNode tail)</span> </span>&#123;</span><br><span class="line">        ListNode tar = tail.next;</span><br><span class="line">        ListNode tmp = dummy;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != tar &amp;&amp; tmp.next.val &lt;= tar.val) &#123;</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.next == tar) <span class="keyword">return</span> tar;</span><br><span class="line">        tail.next = tar.next;</span><br><span class="line">        tar.next = tmp.next;</span><br><span class="line">        tmp.next = tar;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
        <tag>Microsoft</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 289 - Game of Life</title>
    <url>/2020/06/12/leetcode-289/</url>
    <content><![CDATA[<p><strong>Description</strong><br>According to the Wikipedia’s article: “The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.”</p>
<p>Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):</p>
<p>Any live cell with fewer than two live neighbors dies, as if caused by under-population.<br>Any live cell with two or three live neighbors lives on to the next generation.<br>Any live cell with more than three live neighbors dies, as if by over-population..<br>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.<br>Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously.</p>
<p>Example:</p>
<p>Input:<br>[<br>  [0,1,0],<br>  [0,0,1],<br>  [1,1,1],<br>  [0,0,0]<br>]<br>Output:<br>[<br>  [0,0,0],<br>  [1,0,1],<br>  [0,1,1],<br>  [0,1,0]<br>]<br>Follow up:</p>
<p>Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells.<br>In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?</p>
<h2 id="Solution-One-Record-status"><a href="#Solution-One-Record-status" class="headerlink" title="Solution One: Record status"></a>Solution One: Record status</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Game of Life.<br>Memory Usage: 37.3 MB, less than 98.52% of Java online submissions for Game of Life.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(colNum), Time Complexity: O(rowNum * colNum).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> rowNum = board.length, colNum = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] lastRowStatus = <span class="keyword">new</span> <span class="keyword">int</span>[colNum];</span><br><span class="line">        <span class="keyword">int</span>[] curRowStatus = <span class="keyword">new</span> <span class="keyword">int</span>[colNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">                <span class="comment">// count live neighbors</span></span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>, cur = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123; <span class="comment">// last row</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> c = Math.max(j - <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">                         c &lt;= Math.min(colNum - <span class="number">1</span>, j + <span class="number">1</span>); c++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lastRowStatus[c] == <span class="number">1</span>) count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; curRowStatus[j - <span class="number">1</span>] == <span class="number">1</span>) count++; <span class="comment">// left</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; colNum - <span class="number">1</span> &amp;&amp; board[i][j + <span class="number">1</span>] == <span class="number">1</span>) count++; <span class="comment">// right</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; rowNum - <span class="number">1</span>) &#123; <span class="comment">// next row</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> c = Math.max(j - <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">                         c &lt;= Math.min(colNum - <span class="number">1</span>, j + <span class="number">1</span>); c++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i + <span class="number">1</span>][c] == <span class="number">1</span>) count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// change status</span></span><br><span class="line">                <span class="keyword">if</span> (cur == <span class="number">1</span> &amp;&amp; (count &lt; <span class="number">2</span> || count &gt; <span class="number">3</span>)) board[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="number">0</span> &amp;&amp; count == <span class="number">3</span>) board[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// record</span></span><br><span class="line">                curRowStatus[j] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            lastRowStatus = curRowStatus;</span><br><span class="line">            curRowStatus = <span class="keyword">new</span> <span class="keyword">int</span>[colNum];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 6 - ZigZag Conversion</title>
    <url>/2020/06/15/leetcode-6/</url>
    <content><![CDATA[<p><strong>Description</strong><br>The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>
<p>P   A   H   N<br>A P L S I I G<br>Y   I   R<br>And then read line by line: “PAHNAPLSIIGYIR”</p>
<p>Write the code that will take a string and make this conversion given a number of rows:</p>
<p>string convert(string s, int numRows);<br>Example 1:</p>
<p>Input: s = “PAYPALISHIRING”, numRows = 3<br>Output: “PAHNAPLSIIGYIR”<br>Example 2:</p>
<p>Input: s = “PAYPALISHIRING”, numRows = 4<br>Output: “PINALSIGYAHRPI”<br>Explanation:</p>
<p>P     I    N<br>A   L S  I G<br>Y A   H R<br>P     I</p>
<h2 id="Solution-One-Sort-by-Row"><a href="#Solution-One-Sort-by-Row" class="headerlink" title="Solution One: Sort by Row"></a>Solution One: Sort by Row</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 6 ms, faster than 58.80% of Java online submissions for ZigZag Conversion.<br>Memory Usage: 39.8 MB, less than 73.19% of Java online submissions for ZigZag Conversion.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My second solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || numRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line">        <span class="keyword">int</span> setSize = <span class="number">2</span> * numRows - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> setCount = size / setSize;</span><br><span class="line">        List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(numRows, size); i++)</span><br><span class="line">            rows.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= setCount; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = setSize * i; <span class="comment">// index of String s</span></span><br><span class="line">            <span class="comment">// up to down</span></span><br><span class="line">            <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (row &lt; numRows &amp;&amp; j &lt; size) &#123;</span><br><span class="line">                rows.get(row++).append(s.charAt(j++));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left down to up right</span></span><br><span class="line">            row = numRows - <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (row &gt; <span class="number">0</span> &amp;&amp; j &lt; size) &#123;</span><br><span class="line">                rows.get(row--).append(s.charAt(j++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// build string</span></span><br><span class="line">        StringBuilder ans = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder sb : rows) &#123;</span><br><span class="line">            ans.append(sb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 91 - Decode Ways</title>
    <url>/2020/06/13/leetcode-91/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A message containing letters from A-Z is being encoded to numbers using the following mapping:</p>
<p>‘A’ -&gt; 1<br>‘B’ -&gt; 2<br>…<br>‘Z’ -&gt; 26<br>Given a non-empty string containing only digits, determine the total number of ways to decode it.</p>
<p>Example 1:</p>
<p>Input: “12”<br>Output: 2<br>Explanation: It could be decoded as “AB” (1 2) or “L” (12).<br>Example 2:</p>
<p>Input: “226”<br>Output: 3<br>Explanation: It could be decoded as “BZ” (2 26), “VF” (22 6), or “BBF” (2 2 6).</p>
<h2 id="Solution-One-Dynamic-Programming"><a href="#Solution-One-Dynamic-Programming" class="headerlink" title="Solution One: Dynamic Programming"></a>Solution One: Dynamic Programming</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 97.64% of Java online submissions for Decode Ways.<br>Memory Usage: 37.6 MB, less than 86.89% of Java online submissions for Decode Ways.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) != <span class="string">'0'</span>) dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            String tuple = s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">int</span> tupleN = Integer.parseInt(tuple);</span><br><span class="line">            <span class="keyword">if</span> (tupleN &lt;= <span class="number">26</span> &amp;&amp; tupleN &gt;= <span class="number">10</span>) dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) != <span class="string">'0'</span>) dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 609 - Find Duplicate File in System</title>
    <url>/2020/06/15/leetcode-609/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a list of directory info including directory path, and all the files with contents in this directory, you need to find out all the groups of duplicate files in the file system in terms of their paths.</p>
<p>A group of duplicate files consists of at least two files that have exactly the same content.</p>
<p>A single directory info string in the input list has the following format:</p>
<p>“root/d1/d2/…/dm f1.txt(f1_content) f2.txt(f2_content) … fn.txt(fn_content)”</p>
<p>It means there are n files (f1.txt, f2.txt … fn.txt with content f1_content, f2_content … fn_content, respectively) in directory root/d1/d2/…/dm. Note that n &gt;= 1 and m &gt;= 0. If m = 0, it means the directory is just the root directory.</p>
<p>The output is a list of group of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:</p>
<p>“directory_path/file_name.txt”</p>
<p>Example 1:</p>
<p>Input:<br>[“root/a 1.txt(abcd) 2.txt(efgh)”, “root/c 3.txt(abcd)”, “root/c/d 4.txt(efgh)”, “root 4.txt(efgh)”]<br>Output:<br>[[“root/a/2.txt”,”root/c/d/4.txt”,”root/4.txt”],[“root/a/1.txt”,”root/c/3.txt”]]</p>
<h2 id="Solution-One-Using-HashMap"><a href="#Solution-One-Using-HashMap" class="headerlink" title="Solution One: Using HashMap"></a>Solution One: Using HashMap</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 64 ms, faster than 14.11% of Java online submissions for Find Duplicate File in System.<br>Memory Usage: 48.3 MB, less than 76.63% of Java online submissions for Find Duplicate File in System.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Time complexity : O(n*x). n strings of average length x is parsed.</p>
<p>Space complexity : O(n<em>x). map and resres size grows up to n</em>x.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; findDuplicate(String[] paths) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String path : paths) &#123;</span><br><span class="line">            String[] pathArr = path.split(<span class="string">" "</span>);</span><br><span class="line">            String dir = pathArr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">                String[] cur = pathArr[i].split(<span class="string">"[()]"</span>);</span><br><span class="line">                List&lt;String&gt; list = map.getOrDefault(cur[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                list.add(dir + <span class="string">"/"</span> + cur[<span class="number">0</span>]);</span><br><span class="line">                map.put(cur[<span class="number">1</span>], list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String content : map.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(content).size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans.add(map.get(content));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// when content is very long</span></span><br><span class="line"><span class="comment">//     private int compareContent(String content1, String content2) &#123;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 981 - Time Based Key-Value Store</title>
    <url>/2020/06/13/leetcode-981/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Create a timebased key-value store class TimeMap, that supports two operations.</p>
<ol>
<li>set(string key, string value, int timestamp)</li>
</ol>
<p>Stores the key and value, along with the given timestamp.<br>2. get(string key, int timestamp)</p>
<p>Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev &lt;= timestamp.<br>If there are multiple such values, it returns the one with the largest timestamp_prev.<br>If there are no values, it returns the empty string (“”).</p>
<h2 id="Solution-One-HashMap-TreeMap"><a href="#Solution-One-HashMap-TreeMap" class="headerlink" title="Solution One: HashMap + TreeMap"></a>Solution One: HashMap + TreeMap</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 148 ms, faster than 30.02% of Java online submissions for Time Based Key-Value Store.<br>Memory Usage: 114.8 MB, less than 70.19% of Java online submissions for Time Based Key-Value Store.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1) for set, O(logn) for get<br>Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, TreeMap&lt;Integer, String&gt;&gt; map;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TimeMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        TreeMap&lt;Integer, String&gt; subMap = map.getOrDefault(key, <span class="keyword">new</span> TreeMap&lt;&gt;());</span><br><span class="line">        subMap.put(timestamp, value);</span><br><span class="line">        map.put(key, subMap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)</span><br><span class="line">           || map.get(key).floorEntry(timestamp) == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> map.get(key).floorEntry(timestamp).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TimeMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TimeMap obj = new TimeMap();</span></span><br><span class="line"><span class="comment"> * obj.set(key,value,timestamp);</span></span><br><span class="line"><span class="comment"> * String param_2 = obj.get(key,timestamp);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 362 - Design Hit Counter</title>
    <url>/2020/06/15/leetcode-362/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Design a hit counter which counts the number of hits received in the past 5 minutes.</p>
<p>Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.</p>
<p>It is possible that several hits arrive roughly at the same time.</p>
<p>Example:</p>
<p>HitCounter counter = new HitCounter();</p>
<p>// hit at timestamp 1.<br>counter.hit(1);</p>
<p>// hit at timestamp 2.<br>counter.hit(2);</p>
<p>// hit at timestamp 3.<br>counter.hit(3);</p>
<p>// get hits at timestamp 4, should return 3.<br>counter.getHits(4);</p>
<p>// hit at timestamp 300.<br>counter.hit(300);</p>
<p>// get hits at timestamp 300, should return 4.<br>counter.getHits(300);</p>
<p>// get hits at timestamp 301, should return 3.<br>counter.getHits(301);<br>Follow up:<br>What if the number of hits per second could be very large? Does your design scale?</p>
<h2 id="Solution-One-Binary-Search"><a href="#Solution-One-Binary-Search" class="headerlink" title="Solution One: Binary Search"></a>Solution One: Binary Search</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 96.03% of Java online submissions for Design Hit Counter.<br>Memory Usage: 39 MB, less than 15.73% of Java online submissions for Design Hit Counter.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(1) - hit, O(logn) - getHits.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HitCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> RANGE = <span class="number">300</span>;</span><br><span class="line">    List&lt;Integer&gt; hits;</span><br><span class="line">    <span class="comment">// Map&lt;Integer, Integer&gt; freqMap;</span></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HitCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hits = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Record a hit.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> timestamp - The current timestamp (in seconds granularity). */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hit</span><span class="params">(<span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        hits.add(timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Return the number of hits in the past 5 minutes.</span></span><br><span class="line"><span class="comment">        <span class="doctag">@param</span> timestamp - The current timestamp (in seconds granularity). */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHits</span><span class="params">(<span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// not equal to timestamp - 300</span></span><br><span class="line">        <span class="keyword">int</span> index = getTarget(timestamp - RANGE);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> hits.size() - index;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getTarget</span><span class="params">(<span class="keyword">int</span> sec)</span> </span>&#123; <span class="comment">// find first element &gt; sec</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = hits.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> midVal = hits.get(mid);</span><br><span class="line">            <span class="keyword">if</span> (midVal &lt;= sec) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; sec) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == left || hits.get(mid - <span class="number">1</span>) &lt;= sec) <span class="keyword">return</span> mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your HitCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * HitCounter obj = new HitCounter();</span></span><br><span class="line"><span class="comment"> * obj.hit(timestamp);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.getHits(timestamp);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 135 - Candy</title>
    <url>/2020/06/19/leetcode-135/</url>
    <content><![CDATA[<p><strong>Description</strong><br>There are N children standing in a line. Each child is assigned a rating value.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<p>Each child must have at least one candy.<br>Children with a higher rating get more candies than their neighbors.<br>What is the minimum candies you must give?</p>
<p>Example 1:</p>
<p>Input: [1,0,2]<br>Output: 5<br>Explanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.<br>Example 2:</p>
<p>Input: [1,2,2]<br>Output: 4<br>Explanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.<br>             The third child gets 1 candy because it satisfies the above two conditions.</p>
<h2 id="Solution-One-Brute-Force"><a href="#Solution-One-Brute-Force" class="headerlink" title="Solution One: Brute Force"></a>Solution One: Brute Force</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 813 ms, faster than 5.02% of Java online submissions for Candy.<br>Memory Usage: 40.2 MB, less than 60.11% of Java online submissions for Candy.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings == <span class="keyword">null</span> || ratings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = ratings.length;</span><br><span class="line">        <span class="keyword">int</span>[] candies = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// to left</span></span><br><span class="line">            <span class="keyword">int</span> left = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; ratings[left] &gt; ratings[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[left] = Math.max(candies[left], candies[left + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// to right</span></span><br><span class="line">            <span class="keyword">int</span> right = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; size &amp;&amp; ratings[right] &gt; ratings[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                candies[right] = Math.max(candies[right], candies[right - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println(Arrays.toString(candies));</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            ans += candies[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Two-Pass"><a href="#Solution-Two-Two-Pass" class="headerlink" title="Solution Two: Two Pass"></a>Solution Two: Two Pass</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 39.72% of Java online submissions for Candy.<br>Memory Usage: 49.4 MB, less than 5.11% of Java online submissions for Candy.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ratings == <span class="keyword">null</span> || ratings.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = ratings.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>])</span><br><span class="line">                ans[i] = ans[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>])</span><br><span class="line">                ans[i] = Math.max(ans[i], ans[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            sum += ans[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Three-One-Pass-with-Constant-Space"><a href="#Solution-Three-One-Pass-with-Constant-Space" class="headerlink" title="Solution Three: One Pass with Constant Space"></a>Solution Three: One Pass with Constant Space</h2><h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><h3 id="Java-Code-1"><a href="#Java-Code-1" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 13 - Roman to Integer</title>
    <url>/2020/06/16/leetcode-13/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p>Example 1:</p>
<p>Input: “III”<br>Output: 3<br>Example 2:</p>
<p>Input: “IV”<br>Output: 4<br>Example 3:</p>
<p>Input: “IX”<br>Output: 9<br>Example 4:</p>
<p>Input: “LVIII”<br>Output: 58<br>Explanation: L = 50, V= 5, III = 3.<br>Example 5:</p>
<p>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
<h2 id="Solution-One-left-to-right-pass"><a href="#Solution-One-left-to-right-pass" class="headerlink" title="Solution One: left to right pass"></a>Solution One: left to right pass</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 21.53% of Java online submissions for Roman to Integer.<br>Memory Usage: 40 MB, less than 47.83% of Java online submissions for Roman to Integer.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        buildMap(map);</span><br><span class="line">        String num = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span> prev = <span class="string">'?'</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (map.get(cur) &lt; map.get(prev)) &#123;</span><br><span class="line">                ans += parse(map, num);</span><br><span class="line">                num = String.valueOf(cur);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num += String.valueOf(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += parse(map, num);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parse</span><span class="params">(Map&lt;Character, Integer&gt; map, String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> last = num.charAt(num.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = map.get(last);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = num.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur == last) ans += map.get(cur);</span><br><span class="line">            <span class="keyword">else</span> ans -= map.get(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildMap</span><span class="params">(Map&lt;Character, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="string">'I'</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">'V'</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">'X'</span>, <span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">'L'</span>, <span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">'C'</span>, <span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">'D'</span>, <span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">'M'</span>, <span class="number">1000</span>);</span><br><span class="line">        map.put(<span class="string">'?'</span>, <span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p>Hard code IV…<br>no situations like IIV</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 155 - Min Stack</title>
    <url>/2020/06/16/leetcode-155/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>getMin() – Retrieve the minimum element in the stack.</p>
<h2 id="Solution-One-Two-Stack"><a href="#Solution-One-Two-Stack" class="headerlink" title="Solution One: Two Stack"></a>Solution One: Two Stack</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 91.49% of Java online submissions for Min Stack.<br>Memory Usage: 40.8 MB, less than 97.29% of Java online submissions for Min Stack.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(1).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ArrayDeque&lt;Integer&gt; stack;</span><br><span class="line">    ArrayDeque&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="keyword">int</span> minValue;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        minValue = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        minValue = Math.min(minValue, x);</span><br><span class="line">        minStack.push(minValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        minValue = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 209 - Minimum Size Subarray Sum</title>
    <url>/2020/06/18/leetcode-209/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p>
<p>Example: </p>
<p>Input: s = 7, nums = [2,3,1,2,4,3]<br>Output: 2<br>Explanation: the subarray [4,3] has the minimal length under the problem constraint.<br>Follow up:<br>If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). </p>
<h2 id="Solution-One-Using-Binary-search-or-TreeMap"><a href="#Solution-One-Using-Binary-search-or-TreeMap" class="headerlink" title="Solution One: Using Binary search or TreeMap"></a>Solution One: Using Binary search or TreeMap</h2><h2 id="Solution-Two-Two-Pointers"><a href="#Solution-Two-Two-Pointers" class="headerlink" title="Solution Two: Two Pointers"></a>Solution Two: Two Pointers</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Runtime: 1 ms, faster than 99.92% of Java online submissions for Minimum Size Subarray Sum.<br>Memory Usage: 39.4 MB, less than 74.34% of Java online submissions for Minimum Size Subarray Sum.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = Integer.MAX_VALUE, left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">                ans = Math.min(ans, i - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 253 - Meeting Rooms II</title>
    <url>/2020/06/19/leetcode-253/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), find the minimum number of conference rooms required.</p>
<p>Example 1:</p>
<p>Input: [[0, 30],[5, 10],[15, 20]]<br>Output: 2<br>Example 2:</p>
<p>Input: [[7,10],[2,4]]<br>Output: 1<br>NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<h2 id="Solution-One-Sort-and-TreeMap"><a href="#Solution-One-Sort-and-TreeMap" class="headerlink" title="Solution One: Sort and TreeMap"></a>Solution One: Sort and TreeMap</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 9 ms, faster than 27.01% of Java online submissions for Meeting Rooms II.<br>Memory Usage: 39.8 MB, less than 33.15% of Java online submissions for Meeting Rooms II.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(nlogn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// &lt;end, start&gt;</span></span><br><span class="line">        TreeMap&lt;Integer, List&lt;Integer&gt;&gt; intervalMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!intervalMap.isEmpty() &amp;&amp; intervalMap.firstKey() &lt;= interval[<span class="number">0</span>])&#123;</span><br><span class="line">                num -= intervalMap.pollFirstEntry().getValue().size();</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; list = intervalMap.getOrDefault(interval[<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list.add(interval[<span class="number">0</span>]);</span><br><span class="line">            intervalMap.put(interval[<span class="number">1</span>], list);</span><br><span class="line">            num++;</span><br><span class="line">            ans = Math.max(ans, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p>use PriorityQueue to store end time, instead of storing pairs in TreeMap</p>
<h1 id="Leetcode-252-Meeting-Rooms"><a href="#Leetcode-252-Meeting-Rooms" class="headerlink" title="Leetcode 252 - Meeting Rooms"></a>Leetcode 252 - Meeting Rooms</h1><p><strong>Description</strong><br>Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],…] (si &lt; ei), determine if a person could attend all meetings.</p>
<p>Example 1:</p>
<p>Input: [[0,30],[5,10],[15,20]]<br>Output: false<br>Example 2:</p>
<p>Input: [[7,10],[2,4]]<br>Output: true<br>NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<h2 id="Other-Similar-Questions"><a href="#Other-Similar-Questions" class="headerlink" title="Other Similar Questions"></a>Other Similar Questions</h2><p>Merge Intervals</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Sort</tag>
        <tag>Intervals</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 332 - Reconstruct Itinerary</title>
    <url>/2020/06/16/leetcode-332/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p>
<p>Note:</p>
<p>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].<br>All airports are represented by three capital letters (IATA code).<br>You may assume all tickets form at least one valid itinerary.<br>One must use all the tickets once and only once.<br>Example 1:</p>
<p>Input: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]<br>Output: [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]<br>Example 2:</p>
<p>Input: [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]<br>Output: [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]<br>Explanation: Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”].<br>             But it is larger in lexical order.</p>
<h2 id="Solution-One-DFS-Eulerian-Path"><a href="#Solution-One-DFS-Eulerian-Path" class="headerlink" title="Solution One: DFS (Eulerian Path)"></a>Solution One: DFS (Eulerian Path)</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 6 ms, faster than 53.20% of Java online submissions for Reconstruct Itinerary.<br>Memory Usage: 40 MB, less than 72.26% of Java online submissions for Reconstruct Itinerary.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/reconstruct-itinerary/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/reconstruct-itinerary/solution/</a></p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;String&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> </span>&#123;</span><br><span class="line">        ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Map&lt;String, LinkedList&lt;String&gt;&gt; toMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; ticket : tickets) &#123;</span><br><span class="line">            LinkedList&lt;String&gt; list = toMap.getOrDefault(ticket.get(<span class="number">0</span>), <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            list.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">            toMap.put(ticket.get(<span class="number">0</span>), list);</span><br><span class="line">        &#125;</span><br><span class="line">        toMap.forEach((key, value) -&gt; Collections.sort(value));</span><br><span class="line">        dfs(toMap, <span class="string">"JFK"</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// post order visit</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Map&lt;String, LinkedList&lt;String&gt;&gt; toMap, String from)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;String&gt; list = toMap.getOrDefault(from, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">while</span> (!list.isEmpty()) &#123;</span><br><span class="line">            String to = list.pollFirst();</span><br><span class="line">            dfs(toMap, to);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.addFirst(from);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 339 - Nested List Weight Sum I &amp;&amp; II</title>
    <url>/2020/06/18/leetcode-339/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Example 1:</p>
<p>Input: [[1,1],2,[1,1]]<br>Output: 10<br>Explanation: Four 1’s at depth 2, one 2 at depth 1.<br>Example 2:</p>
<p>Input: [1,[4,[6]]]<br>Output: 27<br>Explanation: One 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4<em>2 + 6</em>3 = 27.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Nested List Weight Sum.<br>Memory Usage: 37.1 MB, less than 41.73% of Java online submissions for Nested List Weight Sum.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * public interface NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     public NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     public NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     public boolean isInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     public Integer getInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     public void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     public void add(NestedInteger ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSum(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger element : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.isInteger())</span><br><span class="line">                sum += depth * element.getInteger();</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                sum += getSum(element.getList(), depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-364-Nested-List-Weight-Sum-II"><a href="#Leetcode-364-Nested-List-Weight-Sum-II" class="headerlink" title="Leetcode 364 - Nested List Weight Sum II"></a>Leetcode 364 - Nested List Weight Sum II</h1><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p>
<p>Example 1:</p>
<p>Input: [[1,1],2,[1,1]]<br>Output: 8<br>Explanation: Four 1’s at depth 1, one 2 at depth 2.<br>Example 2:</p>
<p>Input: [1,[4,[6]]]<br>Output: 17<br>Explanation: One 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1<em>3 + 4</em>2 + 6*1 = 17.</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Nested List Weight Sum II.<br>Memory Usage: 37 MB, less than 53.94% of Java online submissions for Nested List Weight Sum II.</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = getDepth(nestedList) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getSum(nestedList, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger cur : nestedList) &#123;</span><br><span class="line">            depth = Math.max(depth, getDepth(cur.getList()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (NestedInteger element : nestedList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.isInteger())</span><br><span class="line">                sum += depth * element.getInteger();</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                sum += getSum(element.getList(), depth - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Nested</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 460 - LFU Cache</title>
    <url>/2020/06/18/leetcode-460/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.</p>
<p>Note that the number of times an item is used is the number of calls to the get and put functions for that item since it was inserted. This number is set to zero when the item is removed.</p>
<p>Follow up:<br>Could you do both operations in O(1) time complexity?</p>
<h2 id="Solution-One-Two-Map-and-Inner-class"><a href="#Solution-One-Two-Map-and-Inner-class" class="headerlink" title="Solution One: Two Map and Inner class"></a>Solution One: Two Map and Inner class</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 20 ms, faster than 76.17% of Java online submissions for LFU Cache.<br>Memory Usage: 47.4 MB, less than 89.27% of Java online submissions for LFU Cache.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(1).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">int</span> freq;</span><br><span class="line">        Node next;</span><br><span class="line">        Node prev;</span><br><span class="line">        Node(<span class="keyword">int</span> k, <span class="keyword">int</span> v) &#123;</span><br><span class="line">            key = k;</span><br><span class="line">            val = v;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">            prev = <span class="keyword">null</span>;</span><br><span class="line">            freq = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;"</span> + key + <span class="string">","</span> + val + <span class="string">","</span> + freq + <span class="string">"&gt;"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeMap&lt;Integer, Node&gt; freqMap;</span><br><span class="line">    Map&lt;Integer, Node&gt; dataMap;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> totalCapacity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LFUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        freqMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        dataMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        totalCapacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!dataMap.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Node node = dataMap.get(key);</span><br><span class="line">        <span class="keyword">int</span> ans = node.val;</span><br><span class="line">        <span class="comment">// update freq</span></span><br><span class="line">        removeFromFreqList(node);</span><br><span class="line">        node.freq += <span class="number">1</span>;</span><br><span class="line">        insertIntoFreqList(node);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFromFreqList</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> freq = node.freq;</span><br><span class="line">        <span class="keyword">if</span> (node.next == node) &#123;</span><br><span class="line">            freqMap.remove(freq);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node prevNode = node.prev;</span><br><span class="line">            Node nextNode = node.next;</span><br><span class="line">            prevNode.next = nextNode;</span><br><span class="line">            nextNode.prev = prevNode;</span><br><span class="line">            <span class="keyword">if</span> (node == freqMap.get(freq)) freqMap.put(freq, nextNode);</span><br><span class="line">        &#125;</span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertIntoFreqList</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> freq = node.freq;</span><br><span class="line">        <span class="keyword">if</span> (!freqMap.containsKey(freq)) &#123;</span><br><span class="line">            node.next = node;</span><br><span class="line">            node.prev = node;</span><br><span class="line">            freqMap.put(freq, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node head = freqMap.get(freq);</span><br><span class="line">            Node tail = head.prev;</span><br><span class="line">            head.prev = node;</span><br><span class="line">            node.next = head;</span><br><span class="line">            tail.next = node;</span><br><span class="line">            node.prev = tail;</span><br><span class="line">            freqMap.put(freq, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dataMap.containsKey(key)) &#123;</span><br><span class="line">            Node node = dataMap.get(key);</span><br><span class="line">            node.val = value;</span><br><span class="line">            <span class="comment">// update freq</span></span><br><span class="line">            removeFromFreqList(node);</span><br><span class="line">            node.freq += <span class="number">1</span>;</span><br><span class="line">            insertIntoFreqList(node);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span> (size++ == totalCapacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dataMap.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            Node victim = freqMap.firstEntry().getValue().prev;</span><br><span class="line">            removeFromFreqList(victim);</span><br><span class="line">            victim.freq = <span class="number">0</span>;</span><br><span class="line">            dataMap.remove(victim.key);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        dataMap.put(key, node);</span><br><span class="line">        insertIntoFreqList(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Data Structure</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 565 - Array Nesting</title>
    <url>/2020/06/18/leetcode-565/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A zero-indexed array A of length N contains all integers from 0 to N-1. Find and return the longest length of set S, where S[i] = {A[i], A[A[i]], A[A[A[i]]], … } subjected to the rule below.</p>
<p>Suppose the first element in S starts with the selection of element A[i] of index = i, the next element in S should be A[A[i]], and then A[A[A[i]]]… By that analogy, we stop adding right before a duplicate element occurs in S.</p>
<p>Example 1:</p>
<p>Input: A = [5,4,0,3,1,6,2]<br>Output: 4<br>Explanation:<br>A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</p>
<p>One of the longest S[K]:<br>S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}</p>
<p>Note:</p>
<p>N is an integer within the range [1, 20,000].<br>The elements of A are all distinct.<br>Each element of A is an integer within the range [0, N-1].</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 65.60% of Java online submissions for Array Nesting.<br>Memory Usage: 40.8 MB, less than 40.47% of Java online submissions for Array Nesting.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        N = nums.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, dfs(nums, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next = nums[index];</span><br><span class="line">        nums[index] -= N;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(nums, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Nested</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 496 - Next Greater Element I &amp; II &amp; III</title>
    <url>/2020/06/18/leetcode-496/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>
<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>
<p>Example 1:<br>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>Output: [-1,3,-1]<br>Explanation:<br>    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.<br>    For number 1 in the first array, the next greater number for it in the second array is 3.<br>    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.<br>Example 2:<br>Input: nums1 = [2,4], nums2 = [1,2,3,4].<br>Output: [3,-1]<br>Explanation:<br>    For number 2 in the first array, the next greater number for it in the second array is 3.<br>    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.<br>Note:<br>All elements in nums1 and nums2 are unique.<br>The length of both nums1 and nums2 would not exceed 1000.</p>
<h2 id="Solution-One-Monotonic-Stack"><a href="#Solution-One-Monotonic-Stack" class="headerlink" title="Solution One: Monotonic Stack"></a>Solution One: Monotonic Stack</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 84.93% of Java online submissions for Next Greater Element I.<br>Memory Usage: 40 MB, less than 26.84% of Java online submissions for Next Greater Element I.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; num &gt; stack.peekFirst()) &#123;</span><br><span class="line">                map.put(stack.pop(), num);</span><br><span class="line">            &#125; </span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            map.put(stack.pop(), -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-503-Next-Greater-Element-II"><a href="#Leetcode-503-Next-Greater-Element-II" class="headerlink" title="Leetcode 503 - Next Greater Element II"></a>Leetcode 503 - Next Greater Element II</h1><p><strong>Description</strong><br>Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number.</p>
<p>Example 1:<br>Input: [1,2,1]<br>Output: [2,-1,2]<br>Explanation: The first 1’s next greater number is 2;<br>The number 2 can’t find next greater number;<br>The second 1’s next greater number needs to search circularly, which is also 2.<br>Note: The length of given array won’t exceed 10000.</p>
<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 95.51% of Java online submissions for Next Greater Element II.<br>Memory Usage: 40.8 MB, less than 64.36% of Java online submissions for Next Greater Element II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">int</span> maxVal = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;(); <span class="comment">// record index</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i] &gt; nums[stack.peekFirst()]) &#123;</span><br><span class="line">                ans[stack.pop()] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            maxVal = Math.max(maxVal, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i] &gt; nums[stack.peekFirst()]) &#123;</span><br><span class="line">                ans[stack.pop()] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == maxVal)</span><br><span class="line">                ans[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-556-Next-Greater-Element-III"><a href="#Leetcode-556-Next-Greater-Element-III" class="headerlink" title="Leetcode 556 - Next Greater Element III"></a>Leetcode 556 - Next Greater Element III</h1><p><strong>Description</strong><br>Given a positive 32-bit integer n, you need to find the smallest 32-bit integer which has exactly the same digits existing in the integer n and is greater in value than n. If no such positive 32-bit integer exists, you need to return -1.</p>
<p>Example 1:</p>
<p>Input: 12<br>Output: 21</p>
<p>Example 2:</p>
<p>Input: 21<br>Output: -1</p>
<h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Next Greater Element III.<br>Memory Usage: 35.9 MB, less than 92.55% of Java online submissions for Next Greater Element III.</p>
<h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(nlogn).</p>
<h3 id="Java-Code-1"><a href="#Java-Code-1" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextGreaterElement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; tailList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> foundPivot = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; !foundPivot) &#123;</span><br><span class="line">            <span class="keyword">int</span> tail = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (!tailList.isEmpty() &amp;&amp; tail &lt; tailList.peekFirst()) </span><br><span class="line">                foundPivot = <span class="keyword">true</span>;</span><br><span class="line">            tailList.addFirst(tail);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!foundPivot) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// System.out.println("tailList" + tailList);</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tailSize = tailList.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pivotVal = tailList.removeFirst();</span><br><span class="line">        Integer[] tailArr = tailList.toArray(<span class="keyword">new</span> Integer[tailSize]);</span><br><span class="line">        <span class="keyword">int</span> nextIndex = <span class="number">0</span>, nextVal = tailArr[nextIndex];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; tailSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tailArr[i] &gt; pivotVal &amp;&amp; tailArr[i] &lt; nextVal) &#123;</span><br><span class="line">                nextIndex = i;</span><br><span class="line">                nextVal = tailArr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tailArr[nextIndex] = pivotVal;</span><br><span class="line">        Arrays.sort(tailArr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// System.out.println("tailArr" + Arrays.toString(tailArr));</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> ans = n * <span class="number">10</span> + nextVal;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tailSize; i++) &#123;</span><br><span class="line">            ans = <span class="number">10</span> * ans + tailArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println("ans" + ans);</span></span><br><span class="line">        <span class="keyword">if</span> (ans &gt; Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p>change Arrays.sort() to reverse</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Stack</tag>
        <tag>Monotonic Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 64 - Minimum Path Sum</title>
    <url>/2020/06/17/leetcode-64/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<p>Example:</p>
<p>Input:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>Output: 7<br>Explanation: Because the path 1→3→1→1→1 minimizes the sum.</p>
<h2 id="Solution-One-DP"><a href="#Solution-One-DP" class="headerlink" title="Solution One: DP"></a>Solution One: DP</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 88.32% of Java online submissions for Minimum Path Sum.<br>Memory Usage: 42.3 MB, less than 53.75% of Java online submissions for Minimum Path Sum.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(m * n), Time Complexity: O(m * n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rowNum = grid.length, colNum = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rowNum][colNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rowNum; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; colNum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) </span><br><span class="line">                    dp[i][j] = grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = grid[i][j] + Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = grid[i][j] + (i &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>][j] : dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rowNum - <span class="number">1</span>][colNum - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 8 - String to Integer (atoi)</title>
    <url>/2020/06/17/leetcode-8/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement atoi which converts a string to an integer.</p>
<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>
<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>
<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>
<p>If no valid conversion could be performed, a zero value is returned.</p>
<p>Note:</p>
<p>Only the space character ‘ ‘ is considered as whitespace character.<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for String to Integer (atoi).<br>Memory Usage: 39.3 MB, less than 74.74% of Java online submissions for String to Integer (atoi).</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// remove leading space</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, size = str.length();</span><br><span class="line">        <span class="keyword">while</span> (index &lt; size &amp;&amp; str.charAt(index) == <span class="string">' '</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// check flag</span></span><br><span class="line">        <span class="keyword">long</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(index) == <span class="string">'-'</span>) &#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(index) == <span class="string">'+'</span>) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// handle digit</span></span><br><span class="line">        <span class="keyword">while</span> (index &lt; size) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = str.charAt(index);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(cur)) <span class="keyword">break</span>;</span><br><span class="line">            ans = ans * <span class="number">10</span> + (cur - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag == -<span class="number">1</span> &amp;&amp; -ans &lt; (<span class="keyword">long</span>)Integer.MIN_VALUE) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                ans = Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; ans &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) &#123;</span><br><span class="line">                ans = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(flag * ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 934 - Shortest Bridge</title>
    <url>/2020/06/17/leetcode-934/</url>
    <content><![CDATA[<p><strong>Description</strong><br>In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)</p>
<p>Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.</p>
<p>Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)</p>
<p>Example 1:</p>
<p>Input: A = [[0,1],[1,0]]<br>Output: 1<br>Example 2:</p>
<p>Input: A = [[0,1,0],[0,0,0],[0,0,1]]<br>Output: 2<br>Example 3:</p>
<p>Input: A = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>Output: 1</p>
<p>Constraints:</p>
<p>2 &lt;= A.length == A[0].length &lt;= 100<br>A[i][j] == 0 or A[i][j] == 1</p>
<h2 id="Solution-One-BFS"><a href="#Solution-One-BFS" class="headerlink" title="Solution One: BFS"></a>Solution One: BFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 7 ms, faster than 78.88% of Java online submissions for Shortest Bridge.<br>Memory Usage: 40.3 MB, less than 48.76% of Java online submissions for Shortest Bridge.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(A), Time Complexity: O(A).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayDeque&lt;<span class="keyword">int</span>[]&gt; queue;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestBridge</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = A.length * A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span> foundOne = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; A.length &amp;&amp; !foundOne) &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; A[<span class="number">0</span>].length &amp;&amp; !foundOne) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dfs(A, i, j);</span><br><span class="line">                    foundOne = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// bfs</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.size() &lt; size) &#123;</span><br><span class="line">            step++;</span><br><span class="line">            <span class="keyword">int</span> count = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] cur = queue.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nextRow = cur[<span class="number">0</span>] + direction[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> nextCol = cur[<span class="number">1</span>] + direction[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextCol &lt; <span class="number">0</span> || nextRow &gt;= A.length || nextCol &gt;= A[<span class="number">0</span>].length || A[nextRow][nextCol] == -<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (A[nextRow][nextCol] == <span class="number">1</span>) <span class="keyword">return</span> step - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// mark</span></span><br><span class="line">                    A[nextRow][nextCol] = -<span class="number">1</span>;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nextRow, nextCol&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] A, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= A.length || j &gt;= A[<span class="number">0</span>].length || A[i][j] == -<span class="number">1</span> || A[i][j] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        A[i][j] = -<span class="number">1</span>;</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">            dfs(A, i + direction[<span class="number">0</span>], j + direction[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>BFS</tag>
        <tag>Microsoft</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 98 - Validate Binary Search Tree</title>
    <url>/2020/06/17/leetcode-98/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p>Example 1:</p>
<pre><code>2</code></pre><p>   / <br>  1   3</p>
<p>Input: [2,1,3]<br>Output: true<br>Example 2:</p>
<pre><code>5</code></pre><p>   / <br>  1   4<br>     / <br>    3   6</p>
<p>Input: [5,1,4,null,null,3,6]<br>Output: false<br>Explanation: The root node’s value is 5 but its right child’s value is 4.</p>
<h2 id="Solution-One-Recursion"><a href="#Solution-One-Recursion" class="headerlink" title="Solution One: Recursion"></a>Solution One: Recursion</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree.<br>Memory Usage: 38.6 MB, less than 99.46% of Java online submissions for Validate Binary Search Tree.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My code</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValid(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(TreeNode node, Integer leftBound, Integer rightBound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ((leftBound != <span class="keyword">null</span> &amp;&amp; node.val &lt;= leftBound)</span><br><span class="line">           || (rightBound != <span class="keyword">null</span> &amp;&amp; node.val &gt;= rightBound))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        Integer rightBound1 = node.val;</span><br><span class="line">        <span class="keyword">if</span> (rightBound != <span class="keyword">null</span>) </span><br><span class="line">            rightBound1 = Math.min(rightBound1, rightBound);</span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        Integer leftBound1 = node.val;</span><br><span class="line">        <span class="keyword">if</span> (leftBound != <span class="keyword">null</span>) </span><br><span class="line">            leftBound1 = Math.max(leftBound, leftBound1);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isValid(node.left, leftBound, rightBound1)</span><br><span class="line">            &amp;&amp; isValid(node.right, leftBound1, rightBound);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Iteration"><a href="#Solution-Two-Iteration" class="headerlink" title="Solution Two: Iteration"></a>Solution Two: Iteration</h2><h2 id="Solution-Three-Inorder-traversal"><a href="#Solution-Three-Inorder-traversal" class="headerlink" title="Solution Three: Inorder traversal"></a>Solution Three: Inorder traversal</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 986 - Interval List Intersections</title>
    <url>/2020/06/17/leetcode-986/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.</p>
<p>Return the intersection of these two interval lists.</p>
<p>(Formally, a closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</p>
<p>Example 1:</p>
<p>Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]<br>Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]</p>
<p>Note:</p>
<p>0 &lt;= A.length &lt; 1000<br>0 &lt;= B.length &lt; 1000<br>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 99.70% of Java online submissions for Interval List Intersections.<br>Memory Usage: 40 MB, less than 94.30% of Java online submissions for Interval List Intersections.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(M+N), Time Complexity: O(M+N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ansList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; A.length &amp;&amp; j &lt; B.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = Math.max(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> hi = Math.min(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">                ansList.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;lo, hi&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[i][<span class="number">1</span>] &lt;= B[j][<span class="number">1</span>])</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ansList.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ansList.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 18 - 4Sum</title>
    <url>/2020/06/22/leetcode-18/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>
<p>Note:</p>
<p>The solution set must not contain duplicate quadruplets.</p>
<p>Example:</p>
<p>Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</p>
<p>A solution set is:<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 94.58% of Java online submissions for 4Sum.<br>Memory Usage: 39.5 MB, less than 93.15% of Java online submissions for 4Sum.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/4sum/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/4sum/solution/</a></p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> kSum(nums, <span class="number">0</span>, target, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; kSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length || nums[start] * k &gt; target || target &gt; nums[nums.length - <span class="number">1</span>] * k)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">2</span>) </span><br><span class="line">            <span class="keyword">return</span> twoSum(nums, start, target);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == start || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; list = kSum(nums, i + <span class="number">1</span>, target - nums[i], k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (List&lt;Integer&gt; subList : list) &#123;</span><br><span class="line">                    ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(nums[i])));</span><br><span class="line">                    ans.get(ans.size() - <span class="number">1</span>).addAll(subList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> lo = start, hi = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">while</span> (lo != start &amp;&amp; nums[lo] == nums[lo - <span class="number">1</span>]) lo++;</span><br><span class="line">            <span class="keyword">while</span> (hi != nums.length - <span class="number">1</span> &amp;&amp; nums[hi] == nums[hi + <span class="number">1</span>]) hi--;</span><br><span class="line">            <span class="keyword">if</span> (lo &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">int</span> curSum = nums[lo] + nums[hi];</span><br><span class="line">                <span class="keyword">if</span> (curSum == target) </span><br><span class="line">                    ans.add(Arrays.asList(nums[lo++], nums[hi--]));</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (curSum &lt; target) </span><br><span class="line">                    lo++;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Related-Questions"><a href="#Related-Questions" class="headerlink" title="Related Questions"></a>Related Questions</h2><p>Two Sum<br>3Sum</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 20 -  Valid Parentheses</title>
    <url>/2020/06/22/leetcode-20/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<p>Open brackets must be closed by the same type of brackets.<br>Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.</p>
<p>Example 1:</p>
<p>Input: “()”<br>Output: true<br>Example 2:</p>
<p>Input: “()[]{}”<br>Output: true</p>
<h2 id="Solution-One-Stack"><a href="#Solution-One-Stack" class="headerlink" title="Solution One: Stack"></a>Solution One: Stack</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 98.77% of Java online submissions for Valid Parentheses.<br>Memory Usage: 37.7 MB, less than 36.81% of Java online submissions for Valid Parentheses.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;Character&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="string">'('</span> || cur == <span class="string">'&#123;'</span> || cur == <span class="string">'['</span>) </span><br><span class="line">                stack.push(cur);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != <span class="string">'&#123;'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != <span class="string">'['</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.pop() != <span class="string">'('</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 27 - Remove Element</title>
    <url>/2020/06/22/leetcode-27/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p>Example 1:</p>
<p>Given nums = [3,2,2,3], val = 3,</p>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p>It doesn’t matter what you leave beyond the returned length.<br>Example 2:</p>
<p>Given nums = [0,1,2,2,3,0,4,2], val = 2,</p>
<p>Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</p>
<p>Note that the order of those five elements can be arbitrary.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
<h2 id="Solution-One-Two-Pointers"><a href="#Solution-One-Two-Pointers" class="headerlink" title="Solution One: Two Pointers"></a>Solution One: Two Pointers</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Element.<br>Memory Usage: 38.3 MB, less than 28.37% of Java online submissions for Remove Element.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != val) nums[last++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-One-Two-Pointers-when-elements-to-remove-are-rare"><a href="#Solution-One-Two-Pointers-when-elements-to-remove-are-rare" class="headerlink" title="Solution One: Two Pointers - when elements to remove are rare"></a>Solution One: Two Pointers - when elements to remove are rare</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 26 - Remove Duplicates from Sorted Array</title>
    <url>/2020/06/22/leetcode-26/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Example 1:</p>
<p>Given nums = [1,1,2],</p>
<p>Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</p>
<p>It doesn’t matter what you leave beyond the returned length.<br>Example 2:</p>
<p>Given nums = [0,0,1,1,1,2,2,3,3,4],</p>
<p>Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</p>
<p>It doesn’t matter what values are set beyond the returned length.</p>
<h2 id="Solution-One-Two-Pointers"><a href="#Solution-One-Two-Pointers" class="headerlink" title="Solution One: Two Pointers"></a>Solution One: Two Pointers</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Duplicates from Sorted Array.<br>Memory Usage: 41.5 MB, less than 38.63% of Java online submissions for Remove Duplicates from Sorted Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            nums[last++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-80-Remove-Duplicates-from-Sorted-Array-II"><a href="#Leetcode-80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="Leetcode 80 - Remove Duplicates from Sorted Array II"></a>Leetcode 80 - Remove Duplicates from Sorted Array II</h1><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 6.71% of Java online submissions for Remove Duplicates from Sorted Array II.<br>Memory Usage: 39.2 MB, less than 96.43% of Java online submissions for Remove Duplicates from Sorted Array II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; freqMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> freq = freqMap.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (freq &lt;= <span class="number">2</span>) nums[pos++] = nums[i];</span><br><span class="line">            freqMap.put(nums[i], freq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Duplicates from Sorted Array II.<br>Memory Usage: 39.1 MB, less than 98.67% of Java online submissions for Remove Duplicates from Sorted Array II.</p>
<h3 id="Java-code-2"><a href="#Java-code-2" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">2</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> lastCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) lastCount++;</span><br><span class="line">            <span class="keyword">else</span> lastCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (lastCount &lt;= <span class="number">2</span>) nums[pos++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 32 - Longest Valid Parentheses</title>
    <url>/2020/06/22/leetcode-32/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>Example 1:</p>
<p>Input: “(()”<br>Output: 2<br>Explanation: The longest valid parentheses substring is “()”<br>Example 2:</p>
<p>Input: “)()())”<br>Output: 4<br>Explanation: The longest valid parentheses substring is “()()”</p>
<h2 id="Solution-One-Dynamic-Programming"><a href="#Solution-One-Dynamic-Programming" class="headerlink" title="Solution One: Dynamic Programming"></a>Solution One: Dynamic Programming</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Longest Valid Parentheses.<br>Memory Usage: 39.5 MB, less than 45.09% of Java online submissions for Longest Valid Parentheses.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line">        <span class="comment">// longest length from i to j, both inclusive</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="string">')'</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">'('</span>) </span><br><span class="line">                    dp[i] = i == <span class="number">1</span> ? <span class="number">2</span> : (dp[i - <span class="number">2</span>] + <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// search from right to left</span></span><br><span class="line">                    <span class="keyword">int</span> start = i - <span class="number">1</span>; <span class="comment">// ')'</span></span><br><span class="line">                    <span class="keyword">while</span> (start &gt;= <span class="number">0</span> &amp;&amp; dp[start] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> pos = start - dp[start];</span><br><span class="line">                        <span class="keyword">if</span> (pos &gt;= <span class="number">0</span> &amp;&amp; s.charAt(pos) == <span class="string">'('</span>) &#123;</span><br><span class="line">                            dp[i] = i - pos + <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) dp[i] += dp[pos - <span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            start = pos;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two"><a href="#Solution-Two" class="headerlink" title="Solution Two:"></a>Solution Two:</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 35 - Search Insert Position</title>
    <url>/2020/06/22/leetcode-35/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
<p>You may assume no duplicates in the array.</p>
<p>Example 1:</p>
<p>Input: [1,3,5,6], 5<br>Output: 2<br>Example 2:</p>
<p>Input: [1,3,5,6], 2<br>Output: 1<br>Example 3:</p>
<p>Input: [1,3,5,6], 7<br>Output: 4<br>Example 4:</p>
<p>Input: [1,3,5,6], 0<br>Output: 0</p>
<h2 id="Solution-One-Binary-Search"><a href="#Solution-One-Binary-Search" class="headerlink" title="Solution One: Binary Search"></a>Solution One: Binary Search</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Search Insert Position.<br>Memory Usage: 39.3 MB, less than 41.21% of Java online submissions for Search Insert Position.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; target) <span class="keyword">return</span> mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot, left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      pivot = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span> (nums[pivot] == target) <span class="keyword">return</span> pivot;</span><br><span class="line">      <span class="keyword">if</span> (target &lt; nums[pivot]) right = pivot - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> left = pivot + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 39 - Combination Sum &amp; 40 - Combination Sum II &amp;&amp; 216 - Combination Sum III</title>
    <url>/2020/06/22/leetcode-39-40/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>
<p>The same repeated number may be chosen from candidates unlimited number of times.</p>
<p>Note:</p>
<p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>Example 1:</p>
<p>Input: candidates = [2,3,6,7], target = 7,<br>A solution set is:<br>[<br>  [7],<br>  [2,2,3]<br>]<br>Example 2:</p>
<p>Input: candidates = [2,3,5], target = 8,<br>A solution set is:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>


<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(candidates, <span class="number">0</span>, target, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; candidates[i]) <span class="keyword">break</span>;</span><br><span class="line">            list.add(candidates[i]);</span><br><span class="line">            backtrack(candidates, i, target - candidates[i], list);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-40-Combination-Sum-II"><a href="#Leetcode-40-Combination-Sum-II" class="headerlink" title="Leetcode 40 - Combination Sum II"></a>Leetcode 40 - Combination Sum II</h1><p><strong>Description</strong><br>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>
<p>Each number in candidates may only be used once in the combination.</p>
<p>Note:</p>
<p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.<br>Example 1:</p>
<p>Input: candidates = [10,1,2,7,6,1,5], target = 8,<br>A solution set is:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]<br>Example 2:</p>
<p>Input: candidates = [2,5,2,1,2], target = 5,<br>A solution set is:<br>[<br>  [1,2,2],<br>  [5]<br>]</p>
<h2 id="Solution-One-1"><a href="#Solution-One-1" class="headerlink" title="Solution One"></a>Solution One</h2><!-- more -->

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 3 ms, faster than 81.26% of Java online submissions for Combination Sum II.<br>Memory Usage: 39.3 MB, less than 93.78% of Java online submissions for Combination Sum II.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>To do…</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        find(candidates, <span class="number">0</span>, target, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> start, <span class="keyword">int</span> target, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == start || candidates[i] != candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                find(candidates, i + <span class="number">1</span>, target - candidates[i], list);</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Leetcode-216-Combination-Sum-III"><a href="#Leetcode-216-Combination-Sum-III" class="headerlink" title="Leetcode 216 - Combination Sum III"></a>Leetcode 216 - Combination Sum III</h1><p><strong>Description</strong><br>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Note:</p>
<p>All numbers will be positive integers.<br>The solution set must not contain duplicate combinations.<br>Example 1:</p>
<p>Input: k = 3, n = 7<br>Output: [[1,2,4]]<br>Example 2:</p>
<p>Input: k = 3, n = 9<br>Output: [[1,2,6], [1,3,5], [2,3,4]]</p>
<h2 id="Solution-One-Backtracking"><a href="#Solution-One-Backtracking" class="headerlink" title="Solution One: Backtracking"></a>Solution One: Backtracking</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 10.34% of Java online submissions for Combination Sum III.<br>Memory Usage: 38.3 MB, less than 15.08% of Java online submissions for Combination Sum III.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(k), Time Complexity: O(9^k).</p>
<h3 id="Java-code-2"><a href="#Java-code-2" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(k, n, <span class="number">1</span>, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> start, LinkedList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtrack(k - <span class="number">1</span>, n - i, i + <span class="number">1</span>, list);</span><br><span class="line">            list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 438 - Find All Anagrams in a String</title>
    <url>/2020/06/20/leetcode-438/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.</p>
<p>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</p>
<p>The order of output does not matter.</p>
<p>Example 1:</p>
<p>Input:<br>s: “cbaebabacd” p: “abc”</p>
<p>Output:<br>[0, 6]</p>
<p>Explanation:<br>The substring with start index = 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index = 6 is “bac”, which is an anagram of “abc”.<br>Example 2:</p>
<p>Input:<br>s: “abab” p: “ab”</p>
<p>Output:<br>[0, 1, 2]</p>
<p>Explanation:<br>The substring with start index = 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index = 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index = 2 is “ab”, which is an anagram of “ab”.</p>
<h2 id="Solution-One-Build-Anagram-Set"><a href="#Solution-One-Build-Anagram-Set" class="headerlink" title="Solution One: Build Anagram Set"></a>Solution One: Build Anagram Set</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Time Limit Exceeded</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/permutations/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/permutations/solution/</a></p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        findAnagrams(p.toCharArray(), <span class="number">0</span>, set);</span><br><span class="line">        <span class="comment">// System.out.println(set);</span></span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = p.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() - length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(s.substring(i, i + length))) &#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findAnagrams</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> first, Set&lt;String&gt; set)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == arr.length) set.add(<span class="keyword">new</span> String(arr));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; arr.length; i++) &#123;</span><br><span class="line">            swap(arr, i, first);</span><br><span class="line">            findAnagrams(arr, first + <span class="number">1</span>, set);</span><br><span class="line">            swap(arr, i, first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Sliding-Window-with-HashMap"><a href="#Solution-Two-Sliding-Window-with-HashMap" class="headerlink" title="Solution Two: Sliding Window with HashMap"></a>Solution Two: Sliding Window with HashMap</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 121 ms, faster than 19.44% of Java online submissions for Find All Anagrams in a String.<br>Memory Usage: 52.8 MB, less than 5.02% of Java online submissions for Find All Anagrams in a String.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = p.length();</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (length &gt; s.length()) <span class="keyword">return</span> ans;</span><br><span class="line">        Map&lt;Character, Integer&gt; pCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = p.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> count = pCount.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            pCount.put(cur, count);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Character, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// first window</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = s.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> count = countMap.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            countMap.put(cur, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pCount.equals(countMap)) ans.add(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// continue</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length() - length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> left = s.charAt(i - <span class="number">1</span>);</span><br><span class="line">            countMap.put(left, countMap.get(left) - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (countMap.get(left) == <span class="number">0</span>) countMap.remove(left);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span> right = s.charAt(i + length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> freq = countMap.getOrDefault(right, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            countMap.put(right, freq);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pCount.equals(countMap)) ans.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Three-Sliding-Window-with-Array"><a href="#Solution-Three-Sliding-Window-with-Array" class="headerlink" title="Solution Three: Sliding Window with Array"></a>Solution Three: Sliding Window with Array</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 44 - Wildcard Matching</title>
    <url>/2020/06/23/leetcode-44/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</p>
<p>‘?’ Matches any single character.<br>‘*’ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>
<p>Note:</p>
<p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like ? or *.<br>Example 1:</p>
<p>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.<br>Example 2:</p>
<p>Input:<br>s = “aa”<br>p = “*”<br>Output: true<br>Explanation: ‘*’ matches any sequence.<br>Example 3:</p>
<p>Input:<br>s = “cb”<br>p = “?a”<br>Output: false<br>Explanation: ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.<br>Example 4:</p>
<p>Input:<br>s = “adceb”<br>p = “<em>a</em>b”<br>Output: true<br>Explanation: The first ‘<em>‘ matches the empty sequence, while the second ‘</em>‘ matches the substring “dce”.<br>Example 5:</p>
<p>Input:<br>s = “acdcb”<br>p = “a*c?b”<br>Output: false</p>
<h2 id="Solution-One-Recursion-with-memorization"><a href="#Solution-One-Recursion-with-memorization" class="headerlink" title="Solution One: Recursion with memorization"></a>Solution One: Recursion with memorization</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 21 ms, faster than 67.15% of Java online submissions for Wildcard Matching.<br>Memory Usage: 41.6 MB, less than 22.88% of Java online submissions for Wildcard Matching.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/wildcard-matching/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/wildcard-matching/solution/</a></p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Boolean[][] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> Boolean[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> match(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String s, <span class="keyword">int</span> i, String p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length()) <span class="keyword">return</span> i == s.length();</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">char</span> curP = p.charAt(j);</span><br><span class="line">        <span class="comment">// s can be empty</span></span><br><span class="line">        <span class="keyword">if</span> (i == s.length()) </span><br><span class="line">            memo[i][j] = (curP == <span class="string">'*'</span> &amp;&amp; match(s, i, p, j + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (curP == <span class="string">'*'</span>) &#123;</span><br><span class="line">            memo[i][j] = match(s, i + <span class="number">1</span>, p, j) || match(s, i, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curP == <span class="string">'?'</span>) &#123;</span><br><span class="line">            memo[i][j] = match(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            memo[i][j] = s.charAt(i) == curP &amp;&amp; match(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Dynamic-Programming"><a href="#Solution-Two-Dynamic-Programming" class="headerlink" title="Solution Two: Dynamic Programming"></a>Solution Two: Dynamic Programming</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 48 - Rotate Image</title>
    <url>/2020/06/23/leetcode-48/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are given an n x n 2D matrix representing an image.</p>
<p>Rotate the image by 90 degrees (clockwise).</p>
<p>Note:</p>
<p>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p>
<p>Example 1:</p>
<p>Given input matrix =<br>[<br>  [1,2,3],<br>  [4,5,6],<br>  [7,8,9]<br>],</p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [7,4,1],<br>  [8,5,2],<br>  [9,6,3]<br>]<br>Example 2:</p>
<p>Given input matrix =<br>[<br>  [ 5, 1, 9,11],<br>  [ 2, 4, 8,10],<br>  [13, 3, 6, 7],<br>  [15,14,12,16]<br>], </p>
<p>rotate the input matrix in-place such that it becomes:<br>[<br>  [15,13, 2, 5],<br>  [14, 3, 4, 1],<br>  [12, 6, 8, 9],<br>  [16, 7,10,11]<br>]</p>
<h2 id="Solution-One-Rotate"><a href="#Solution-One-Rotate" class="headerlink" title="Solution One: Rotate"></a>Solution One: Rotate</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Rotate Image.<br>Memory Usage: 39.5 MB, less than 61.74% of Java online submissions for Rotate Image.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">int</span> preI = i, preJ = j;</span><br><span class="line">                <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ii = preJ;</span><br><span class="line">                    <span class="keyword">int</span> jj = n - <span class="number">1</span> - preI;</span><br><span class="line">                    tmp = changeVal(matrix, ii, jj, tmp);</span><br><span class="line">                    preI = ii;</span><br><span class="line">                    preJ = jj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">changeVal</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> originalVal = matrix[i][j];</span><br><span class="line">        matrix[i][j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> originalVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Transpose-and-then-reverse"><a href="#Solution-Two-Transpose-and-then-reverse" class="headerlink" title="Solution Two: Transpose and then reverse"></a>Solution Two: Transpose and then reverse</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Axis</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 50 - Pow(x, n)</title>
    <url>/2020/06/24/leetcode-50/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement pow(x, n), which calculates x raised to the power n (xn).</p>
<p>Example 1:</p>
<p>Input: 2.00000, 10<br>Output: 1024.00000<br>Example 2:</p>
<p>Input: 2.10000, 3<br>Output: 9.26100<br>Example 3:</p>
<p>Input: 2.00000, -2<br>Output: 0.25000<br>Explanation: 2-2 = 1/22 = 1/4 = 0.25<br>Note:</p>
<p>-100.0 &lt; x &lt; 100.0<br>n is a 32-bit signed integer, within the range [−231, 231 − 1]</p>
<h2 id="Solution-One-Recursion"><a href="#Solution-One-Recursion" class="headerlink" title="Solution One: Recursion"></a>Solution One: Recursion</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Pow(x, n).<br>Memory Usage: 37 MB, less than 34.45% of Java online submissions for Pow(x, n).</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(logn), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a^m = (a ^ 2) ^ (m / 2) * a ^ (m % 2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> positiveN = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> overflowed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == Integer.MIN_VALUE) &#123;</span><br><span class="line">                overflowed = <span class="keyword">true</span>;</span><br><span class="line">                n++;</span><br><span class="line">            &#125; </span><br><span class="line">            n = -n;</span><br><span class="line">            positiveN = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> ans = calculatePow(x, n);</span><br><span class="line">        <span class="keyword">if</span> (!positiveN) &#123;</span><br><span class="line">            ans = <span class="number">1</span> / ans;</span><br><span class="line">            <span class="keyword">if</span> (overflowed) ans *= (<span class="number">1</span> / x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculatePow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> half = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (half &gt;= <span class="number">1</span>) ans = myPow(x * x, half);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) ans *= x;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 55 - Jump Game</title>
    <url>/2020/06/24/leetcode-55/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Determine if you are able to reach the last index.</p>
<p>Example 1:</p>
<p>Input: nums = [2,3,1,1,4]<br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.<br>Example 2:</p>
<p>Input: nums = [3,2,1,0,4]<br>Output: false<br>Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</p>
<p>Constraints:</p>
<p>1 &lt;= nums.length &lt;= 3 * 10^4<br>0 &lt;= nums[i][j] &lt;= 10^5</p>
<h2 id="Solution-One-Greedy"><a href="#Solution-One-Greedy" class="headerlink" title="Solution One: Greedy"></a>Solution One: Greedy</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 98.89% of Java online submissions for Jump Game.<br>Memory Usage: 41.4 MB, less than 68.61% of Java online submissions for Jump Game.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxPos &lt; i) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            maxPos = Math.max(maxPos, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxPos &gt;= nums.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 51 - N-Queens</title>
    <url>/2020/06/24/leetcode-51/</url>
    <content><![CDATA[<p><strong>Description</strong><br>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.</p>
<p>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 20 ms, faster than 8.71% of Java online submissions for N-Queens.<br>Memory Usage: 40.4 MB, less than 22.20% of Java online submissions for N-Queens.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(N!).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[][] board;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        N = n;</span><br><span class="line">        backtracking(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == N) &#123;</span><br><span class="line">            addToAns();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][j] == <span class="string">'\u0000'</span>) &#123;</span><br><span class="line">                Map&lt;Integer, Set&lt;Integer&gt;&gt; newEmptyPos = addQueen(row, j);</span><br><span class="line">                backtracking(row + <span class="number">1</span>);</span><br><span class="line">                removeQueen(newEmptyPos, row, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            String s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                s += board[i][j] == <span class="string">'Q'</span> ? <span class="string">'Q'</span> : <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; addQueen(<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; newEmptyPos = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// add row</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> jj = <span class="number">0</span>; jj &lt; N; jj++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][jj] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                Set&lt;Integer&gt; set = newEmptyPos.getOrDefault(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                set.add(jj);</span><br><span class="line">                newEmptyPos.put(i, set);</span><br><span class="line">                board[i][jj] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add col</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; N; ii++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[ii][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                Set&lt;Integer&gt; set = newEmptyPos.getOrDefault(ii, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                set.add(j);</span><br><span class="line">                newEmptyPos.put(ii, set);</span><br><span class="line">                board[ii][j] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add hill</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; N; ii++) &#123;</span><br><span class="line">            <span class="keyword">int</span> jj = j - ii + i;</span><br><span class="line">            <span class="keyword">if</span> (jj &gt;= <span class="number">0</span> &amp;&amp; jj &lt; N &amp;&amp; board[ii][jj] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                Set&lt;Integer&gt; set = newEmptyPos.getOrDefault(ii, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                set.add(jj);</span><br><span class="line">                newEmptyPos.put(ii, set);</span><br><span class="line">                board[ii][jj] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// add dale</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = <span class="number">0</span>; ii &lt; N; ii++) &#123;</span><br><span class="line">            <span class="keyword">int</span> jj = j + ii - i; <span class="comment">// ii - i = jj - j</span></span><br><span class="line">            <span class="keyword">if</span> (jj &gt;= <span class="number">0</span> &amp;&amp; jj &lt; N &amp;&amp; board[ii][jj] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                Set&lt;Integer&gt; set = newEmptyPos.getOrDefault(ii, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                set.add(jj);</span><br><span class="line">                newEmptyPos.put(ii, set);</span><br><span class="line">                board[ii][jj] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">'Q'</span>;</span><br><span class="line">        <span class="keyword">return</span> newEmptyPos;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeQueen</span><span class="params">(Map&lt;Integer, Set&lt;Integer&gt;&gt; newEmptyPos, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer row : newEmptyPos.keySet()) &#123;</span><br><span class="line">            Set&lt;Integer&gt; colSet = newEmptyPos.get(row);</span><br><span class="line">            <span class="keyword">for</span> (Integer col : colSet) board[row][col] = <span class="string">'\u0000'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Backtracking</tag>
        <tag>Puzzle</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 45 - Jump Game II</title>
    <url>/2020/06/23/leetcode-45/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>
<p>Each element in the array represents your maximum jump length at that position.</p>
<p>Your goal is to reach the last index in the minimum number of jumps.</p>
<p>Example:</p>
<p>Input: [2,3,1,1,4]<br>Output: 2<br>Explanation: The minimum number of jumps to reach the last index is 2.<br>    Jump 1 step from index 0 to 1, then 3 steps to the last index.<br>Note:</p>
<p>You can assume that you can always reach the last index.</p>
<h2 id="Solution-One-backtracking-with-memorization"><a href="#Solution-One-backtracking-with-memorization" class="headerlink" title="Solution One: backtracking with memorization"></a>Solution One: backtracking with memorization</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Time Limit Exceeded</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> jumpFrom(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">jumpFrom</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[start] != <span class="number">0</span>) <span class="keyword">return</span> memo[start];</span><br><span class="line">        <span class="keyword">int</span> jumps = nums[start];</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length - <span class="number">1</span>) memo[start] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (jumps == <span class="number">0</span>) memo[start] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (start + jumps &gt;= nums.length - <span class="number">1</span>) memo[start] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> minNext = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = jumps; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = jumpFrom(nums, start + i);</span><br><span class="line">                <span class="keyword">if</span> (next &gt;= <span class="number">0</span>) minNext = Math.min(minNext, next);</span><br><span class="line">            &#125;</span><br><span class="line">            memo[start] = minNext == Integer.MAX_VALUE ? -<span class="number">1</span> : minNext + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Greedy"><a href="#Solution-Two-Greedy" class="headerlink" title="Solution Two: Greedy"></a>Solution Two: Greedy</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Jump Game II.<br>Memory Usage: 41.6 MB, less than 30.81% of Java online submissions for Jump Game II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxPos = nums[<span class="number">0</span>]; <span class="comment">// maximum position can arrive</span></span><br><span class="line">        <span class="keyword">int</span> maxStep = nums[<span class="number">0</span>]; <span class="comment">// maximum position current jump can arrive</span></span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; maxStep) &#123;</span><br><span class="line">                jump++;</span><br><span class="line">                maxStep = maxPos;</span><br><span class="line">            &#125;</span><br><span class="line">            maxPos = Math.max(maxPos, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jump;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 403 - Frog Jump</title>
    <url>/2020/06/26/leetcode-403/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>
<p>Given a list of stones’ positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.</p>
<p>If the frog’s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.</p>
<p>Note:</p>
<p>The number of stones is ≥ 2 and is &lt; 1,100.<br>Each stone’s position will be a non-negative integer &lt; 231.<br>The first stone’s position is always 0.<br>Example 1:</p>
<p>[0,1,3,5,6,8,12,17]</p>
<p>There are a total of 8 stones.<br>The first stone at the 0th unit, second stone at the 1st unit,<br>third stone at the 3rd unit, and so on…<br>The last stone at the 17th unit.</p>
<p>Return true. The frog can jump to the last stone by jumping<br>1 unit to the 2nd stone, then 2 units to the 3rd stone, then<br>2 units to the 4th stone, then 3 units to the 6th stone,<br>4 units to the 7th stone, and 5 units to the 8th stone.<br>Example 2:</p>
<p>[0,1,2,3,4,8,9,11]</p>
<p>Return false. There is no way to jump to the last stone as<br>the gap between the 5th and 6th stone is too large.</p>
<h2 id="Solution-One-Memorization"><a href="#Solution-One-Memorization" class="headerlink" title="Solution One: Memorization"></a>Solution One: Memorization</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 15 ms, faster than 80.84% of Java online submissions.<br>Memory Usage: 42.2 MB, less than 78.33% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n^2), Time Complexity: O(n^3).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lastPos;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; memoMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canCross</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = stones.length;</span><br><span class="line">        lastPos = stones[size - <span class="number">1</span>];</span><br><span class="line">        memoMap = <span class="keyword">new</span> HashMap&lt;&gt;(size);</span><br><span class="line">        Map&lt;Integer, Integer&gt; posMap = <span class="keyword">new</span> HashMap&lt;&gt;(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            posMap.put(stones[i], i);</span><br><span class="line">            memoMap.put(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> backtrack(posMap, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(Map&lt;Integer, Integer&gt; posMap, <span class="keyword">int</span> startPos, <span class="keyword">int</span> lastJump)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startPos == lastPos) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!posMap.containsKey(startPos)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> startIndex = posMap.get(startPos);</span><br><span class="line">        <span class="keyword">if</span> (memoMap.get(startIndex).contains(lastJump)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = -<span class="number">1</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> jump = lastJump + i;</span><br><span class="line">            <span class="keyword">int</span> nextPos = startPos + jump;</span><br><span class="line">            <span class="keyword">if</span> (jump &gt; <span class="number">0</span> &amp;&amp; backtrack(posMap, nextPos, jump)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memoMap.get(startIndex).add(lastJump);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 62 - Unique Paths &amp; 63 - Unique Paths II</title>
    <url>/2020/06/24/leetcode-62-63/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>How many possible unique paths are there?</p>
<h2 id="Solution-One-DP"><a href="#Solution-One-DP" class="headerlink" title="Solution One : DP"></a>Solution One : DP</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths.<br>Memory Usage: 36.3 MB, less than 51.85% of Java online submissions for Unique Paths.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(m * n), Time Complexity: O(m * n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-63-Unique-Paths-II"><a href="#Leetcode-63-Unique-Paths-II" class="headerlink" title="Leetcode 63 - Unique Paths II"></a>Leetcode 63 - Unique Paths II</h1><p><strong>Description</strong><br>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>
<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>
<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>
<h2 id="Solution-One-DP-1"><a href="#Solution-One-DP-1" class="headerlink" title="Solution One: DP"></a>Solution One: DP</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Paths II.<br>Memory Usage: 38.7 MB, less than 57.96% of Java online submissions for Unique Paths II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(m * n), Time Complexity: O(m * n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span></span><br><span class="line">           || obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 72 - Edit Distance</title>
    <url>/2020/06/25/leetcode-72/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</p>
<p>You have the following 3 operations permitted on a word:</p>
<p>Insert a character<br>Delete a character<br>Replace a character<br>Example 1:</p>
<p>Input: word1 = “horse”, word2 = “ros”<br>Output: 3<br>Explanation:<br>horse -&gt; rorse (replace ‘h’ with ‘r’)<br>rorse -&gt; rose (remove ‘r’)<br>rose -&gt; ros (remove ‘e’)<br>Example 2:</p>
<p>Input: word1 = “intention”, word2 = “execution”<br>Output: 5<br>Explanation:<br>intention -&gt; inention (remove ‘t’)<br>inention -&gt; enention (replace ‘i’ with ‘e’)<br>enention -&gt; exention (replace ‘n’ with ‘x’)<br>exention -&gt; exection (replace ‘n’ with ‘c’)<br>exection -&gt; execution (insert ‘u’)</p>
<h2 id="Solution-One-Dynamic-Programming"><a href="#Solution-One-Dynamic-Programming" class="headerlink" title="Solution One: Dynamic Programming"></a>Solution One: Dynamic Programming</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 11 ms, faster than 9.33% of Java online submissions for Edit Distance.<br>Memory Usage: 41.5 MB, less than 7.17% of Java online submissions for Edit Distance.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(m * n), Time Complexity: O(m * n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word1 == <span class="keyword">null</span> || word2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> m + n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> remove = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> insert = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> replace = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) != word2.charAt(j - <span class="number">1</span>)) replace++;</span><br><span class="line">                dp[i][j] = Math.min(insert, Math.min(remove, replace));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 69 - Sqrt(x)</title>
    <url>/2020/06/25/leetcode-69/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement int sqrt(int x).</p>
<p>Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</p>
<p>Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</p>
<p>Example 1:</p>
<p>Input: 4<br>Output: 2<br>Example 2:</p>
<p>Input: 8<br>Output: 2<br>Explanation: The square root of 8 is 2.82842…, and since<br>             the decimal part is truncated, 2 is returned.</p>
<h2 id="Solution-One-Binary-Search"><a href="#Solution-One-Binary-Search" class="headerlink" title="Solution One: Binary Search"></a>Solution One: Binary Search</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 27.95% of Java online submissions for Sqrt(x).<br>Memory Usage: 36.4 MB, less than 90.58% of Java online submissions for Sqrt(x).</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> find(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">46340</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cur = mid * mid;</span><br><span class="line">            <span class="keyword">if</span> (cur == x) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cur &lt; x) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Recursion-Bit-Shifts"><a href="#Solution-Two-Recursion-Bit-Shifts" class="headerlink" title="Solution Two: Recursion + Bit Shifts"></a>Solution Two: Recursion + Bit Shifts</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
        <tag>Calculator</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 71 - Simplify Path</title>
    <url>/2020/06/25/leetcode-71/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.</p>
<p>In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level.</p>
<p>Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.</p>
<p>Example 1:</p>
<p>Input: “/home/“<br>Output: “/home”<br>Explanation: Note that there is no trailing slash after the last directory name.<br>Example 2:</p>
<p>Input: “/../“<br>Output: “/“<br>Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.<br>Example 3:</p>
<p>Input: “/home//foo/“<br>Output: “/home/foo”<br>Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.<br>Example 4:</p>
<p>Input: “/a/./b/../../c/“<br>Output: “/c”<br>Example 5:</p>
<p>Input: “/a/../../b/../c//.//“<br>Output: “/c”<br>Example 6:</p>
<p>Input: “/a//b////c/d//././/..”<br>Output: “/a/b/c”</p>
<h2 id="Solution-One-Stack"><a href="#Solution-One-Stack" class="headerlink" title="Solution One: Stack"></a>Solution One: Stack</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 8 ms, faster than 30.12% of Java online submissions for Simplify Path.<br>Memory Usage: 39.7 MB, less than 38.14% of Java online submissions for Simplify Path.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = path.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= size) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; size &amp;&amp; path.charAt(i) != <span class="string">'/'</span>) s += path.charAt(i);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">"."</span>)) s = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s.equals(<span class="string">".."</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) stack.pop();</span><br><span class="line">                s = <span class="string">""</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!s.isEmpty()) stack.push(s);</span><br><span class="line">                s = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) <span class="keyword">return</span> <span class="string">"/"</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(<span class="string">"/"</span>).append(stack.pollLast());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 77 - Combinations</title>
    <url>/2020/06/26/leetcode-77/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>Example:</p>
<p>Input: n = 4, k = 2<br>Output:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 19 ms, faster than 58.93% of Java online submissions for Combinations.<br>Memory Usage: 40.6 MB, less than 75.38% of Java online submissions for Combinations.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/combinations/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/combinations/solution/</a></p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(n, <span class="number">1</span>, k, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start, <span class="keyword">int</span> k, LinkedList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtrack(n, i + <span class="number">1</span>, k - <span class="number">1</span>, list);</span><br><span class="line">            list.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>use linkedlist rather than arraylist</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 74 - Search a 2D Matrix</title>
    <url>/2020/06/26/leetcode-74/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>
<p>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.<br>Example 1:</p>
<p>Input:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 3<br>Output: true<br>Example 2:</p>
<p>Input:<br>matrix = [<br>  [1,   3,  5,  7],<br>  [10, 11, 16, 20],<br>  [23, 30, 34, 50]<br>]<br>target = 13<br>Output: false</p>
<h2 id="Solution-One-Binary-Searchs"><a href="#Solution-One-Binary-Searchs" class="headerlink" title="Solution One: Binary Searchs"></a>Solution One: Binary Searchs</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Search a 2D Matrix.<br>Memory Usage: 42 MB, less than 9.63% of Java online submissions for Search a 2D Matrix.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(NlogN).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length, cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = rows * cols - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mid / cols, j = mid % cols;</span><br><span class="line">            <span class="comment">// System.out.println(mid + ": " + i + "," + j);</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 82 - Remove Duplicates from Sorted List II</title>
    <url>/2020/06/26/leetcode-82/</url>
    <content><![CDATA[<p><strong>Description</strong><br>82. Remove Duplicates from Sorted List II<br>Medium</p>
<p>1606</p>
<p>106</p>
<p>Add to List</p>
<p>Share<br>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>Return the linked list sorted as well.</p>
<p>Example 1:</p>
<p>Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>Output: 1-&gt;2-&gt;5<br>Example 2:</p>
<p>Input: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>Output: 2-&gt;3</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Remove Duplicates from Sorted List II.<br>Memory Usage: 39.2 MB, less than 40.96% of Java online submissions for Remove Duplicates from Sorted List II.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line">        ListNode tail = dummy;</span><br><span class="line">        <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = tail.next;</span><br><span class="line">            <span class="keyword">if</span> (next.next == <span class="keyword">null</span> || next.val != next.next.val) &#123;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// skip duplicates</span></span><br><span class="line">                ListNode tmp = next.next;</span><br><span class="line">                <span class="keyword">while</span> (tmp != <span class="keyword">null</span> &amp;&amp; tmp.val == next.val) tmp = tmp.next;</span><br><span class="line">                tail.next = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 78 - Subsets &amp; 90 - Subsets II</title>
    <url>/2020/06/26/leetcode-78/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a set of distinct integers, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:</p>
<p>Input: nums = [1,2,3]<br>Output:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 61.20% of Java online submissions for Subsets.<br>Memory Usage: 39.3 MB, less than 94.76% of Java online submissions for Subsets.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n * 2^n), Time Complexity: O(n * 2^n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, LinkedList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// select</span></span><br><span class="line">        list.add(nums[start]);</span><br><span class="line">        dfs(nums, start + <span class="number">1</span>, list);</span><br><span class="line">        list.removeLast();</span><br><span class="line">        <span class="comment">// not select</span></span><br><span class="line">        dfs(nums, start + <span class="number">1</span>, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-90-Subsets-II"><a href="#Leetcode-90-Subsets-II" class="headerlink" title="Leetcode 90 - Subsets II"></a>Leetcode 90 - Subsets II</h1><p><strong>Description</strong><br>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p>
<p>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:</p>
<p>Input: [1,2,2]<br>Output:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]</p>
<h2 id="Solution-One-1"><a href="#Solution-One-1" class="headerlink" title="Solution One"></a>Solution One</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(2^n), Time Complexity: O(2^n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><p>```java<br>class Solution {<br>    List&lt;List<Integer>&gt; ans;<br>    public List&lt;List<Integer>&gt; subsetsWithDup(int[] nums) {<br>        ans = new ArrayList&lt;&gt;();<br>        Arrays.sort(nums);<br>        backtrack(nums, 0, new LinkedList&lt;&gt;());<br>        return ans;<br>    }</p>
<pre><code>private void backtrack(int[] nums, int start, LinkedList&lt;Integer&gt; list) {
    ans.add(new ArrayList&lt;&gt;(list));
    for (int i = start; i &lt; nums.length; i++) {
        if (i == start || nums[i] != nums[i - 1]) {
            list.add(nums[i]);
            backtrack(nums, i + 1, list);
            list.removeLast();
        }
    }
}</code></pre><p>}<br>``</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Backtrack</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 837 - New 21 Game</title>
    <url>/2020/06/26/leetcode-837/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Alice plays the following game, loosely based on the card game “21”.</p>
<p>Alice starts with 0 points, and draws numbers while she has less than K points.  During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer.  Each draw is independent and the outcomes have equal probabilities.</p>
<p>Alice stops drawing numbers when she gets K or more points.  What is the probability that she has N or less points?</p>
<p>Example 1:</p>
<p>Input: N = 10, K = 1, W = 10<br>Output: 1.00000<br>Explanation:  Alice gets a single card, then stops.<br>Example 2:</p>
<p>Input: N = 6, K = 1, W = 10<br>Output: 0.60000<br>Explanation:  Alice gets a single card, then stops.<br>In 6 out of W = 10 possibilities, she is at or below N = 6 points.<br>Example 3:</p>
<p>Input: N = 21, K = 17, W = 10<br>Output: 0.73278<br>Note:</p>
<p>0 &lt;= K &lt;= N &lt;= 10000<br>1 &lt;= W &lt;= 10000<br>Answers will be accepted as correct if they are within 10^-5 of the correct answer.<br>The judging time limit has been reduced for this question.</p>
<h2 id="Solution-One-Dynamic-Programming"><a href="#Solution-One-Dynamic-Programming" class="headerlink" title="Solution One: Dynamic Programming"></a>Solution One: Dynamic Programming</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span> || N &gt;= K + W) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span>[] dp = <span class="keyword">new</span> <span class="keyword">double</span>[N + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">double</span> oneP = <span class="number">1.0</span> / W;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Math.min(N, W); i++)</span><br><span class="line">            dp[i] = oneP;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> wSum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            dp[i] += wSum * oneP;</span><br><span class="line">            <span class="keyword">if</span> (i - W &gt; <span class="number">0</span>) wSum -= dp[i - W];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; K) wSum += dp[i];</span><br><span class="line">            <span class="keyword">else</span> ans += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Slow-Solution-DFS"><a href="#Slow-Solution-DFS" class="headerlink" title="Slow Solution: DFS"></a>Slow Solution: DFS</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Time Limit Exceeded</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">new21Game</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(N, K, W, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> W, <span class="keyword">int</span> points)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (points &gt;= K) &#123;</span><br><span class="line">        <span class="keyword">if</span> (points &lt;= N) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> prop = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxNext = Math.min(W, N - points);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxNext; i++) &#123;</span><br><span class="line">        prop += dfs(N, K, W, points + i) / W;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
        <tag>Apple</tag>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 112 - Path Sum &amp;&amp; 113 - Path Sum II</title>
    <url>/2020/06/28/leetcode-112-113/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given the below binary tree and sum = 22,</p>
<pre><code>  5
 / \
4   8</code></pre><p>   /   / <br>  11  13  4<br> /  \      <br>7    2      1<br>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(logn), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> getSum(root, sum, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> target, <span class="keyword">int</span> parentSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curSum = parentSum + root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> curSum == target;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; getSum(root.left, target, curSum))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; getSum(root.right, target, curSum))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-113-Path-Sum-II"><a href="#Leetcode-113-Path-Sum-II" class="headerlink" title="Leetcode 113 - Path Sum II"></a>Leetcode 113 - Path Sum II</h1><p><strong>Description</strong><br>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Given the below binary tree and sum = 22,</p>
<pre><code>  5
 / \
4   8</code></pre><p>   /   / <br>  11  13  4<br> /  \    / <br>7    2  5   1<br>Return:</p>
<p>[<br>   [5,4,11,2],<br>   [5,8,4,5]<br>]</p>
<h2 id="Solution-One-1"><a href="#Solution-One-1" class="headerlink" title="Solution One"></a>Solution One</h2><!-- more -->

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.87% of Java online submissions for Path Sum II.<br>Memory Usage: 40.1 MB, less than 44.53% of Java online submissions for Path Sum II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(logn), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        getSum(root, sum, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> target, LinkedList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) getSum(root.left, target, path);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) getSum(root.right, target, path);</span><br><span class="line">        &#125;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My first slow solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        getSum(root, sum, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> target, LinkedList&lt;Integer&gt; path)</span> </span>&#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        target -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="number">0</span>) ans.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) </span><br><span class="line">            getSum(root.left, target, <span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) </span><br><span class="line">            getSum(root.right, target, <span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 115 - Distinct Subsequences</title>
    <url>/2020/06/29/leetcode-115/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string S and a string T, count the number of distinct subsequences of S which equals T.</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ACE” is a subsequence of “ABCDE” while “AEC” is not).</p>
<p>It’s guaranteed the answer fits on a 32-bit signed integer.</p>
<p>Example 1:</p>
<p>Input: S = “rabbbit”, T = “rabbit”<br>Output: 3<br>Explanation:<br>As shown below, there are 3 ways you can generate “rabbit” from S.<br>(The caret symbol ^ means the chosen letters)</p>
<p>rabbbit<br>^^^^ ^^<br>rabbbit<br>^^ ^^^^<br>rabbbit<br>^^^ ^^^<br>Example 2:</p>
<p>Input: S = “babgbag”, T = “bag”<br>Output: 5<br>Explanation:<br>As shown below, there are 5 ways you can generate “bag” from S.<br>(The caret symbol ^ means the chosen letters)</p>
<p>babgbag<br>^^ ^<br>babgbag<br>^^    ^<br>babgbag<br>^    ^^<br>babgbag<br>  ^  ^^<br>babgbag<br>    ^^^</p>
<h2 id="Solution-One-Dynamic-Programming"><a href="#Solution-One-Dynamic-Programming" class="headerlink" title="Solution One: Dynamic Programming"></a>Solution One: Dynamic Programming</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 89.68% of Java online submissions for Distinct Subsequences.<br>Memory Usage: 39.6 MB, less than 44.97% of Java online submissions for Distinct Subsequences.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(M * N), Time Complexity: O(M * N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = t.length(), n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(j) == t.charAt(i)) &#123;</span><br><span class="line">                    dp[i][j] = (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] : <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Space-optimized-Dynamic-Programming"><a href="#Solution-Two-Space-optimized-Dynamic-Programming" class="headerlink" title="Solution Two: Space optimized Dynamic Programming"></a>Solution Two: Space optimized Dynamic Programming</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 150 - Evaluate Reverse Polish Notation</title>
    <url>/2020/06/30/leetcode-150/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>Valid operators are +, -, *, /. Each operand may be an integer or another expression.</p>
<p>Note:</p>
<p>Division between two integers should truncate toward zero.<br>The given RPN expression is always valid. That means the expression would always evaluate to a result and there won’t be any divide by zero operation.<br>Example 1:</p>
<p>Input: [“2”, “1”, “+”, “3”, “*”]<br>Output: 9<br>Explanation: ((2 + 1) * 3) = 9<br>Example 2:</p>
<p>Input: [“4”, “13”, “5”, “/“, “+”]<br>Output: 6<br>Explanation: (4 + (13 / 5)) = 6<br>Example 3:</p>
<p>Input: [“10”, “6”, “9”, “3”, “+”, “-11”, “*”, “/“, “*”, “17”, “+”, “5”, “+”]<br>Output: 22<br>Explanation:<br>  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5<br>= ((10 * (6 / (12 * -11))) + 17) + 5<br>= ((10 * (6 / -132)) + 17) + 5<br>= ((10 * 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22</p>
<h2 id="Solution-One-Stack"><a href="#Solution-One-Stack" class="headerlink" title="Solution One: Stack"></a>Solution One: Stack</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 10 ms, faster than 21.13% of Java online submissions for Evaluate Reverse Polish Notation.<br>Memory Usage: 42.1 MB, less than 5.04% of Java online submissions for Evaluate Reverse Polish Notation.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens == <span class="keyword">null</span> || tokens.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        ArrayDeque&lt;String&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (token.equals(<span class="string">"+"</span>) || token.equals(<span class="string">"-"</span>) </span><br><span class="line">                || token.equals(<span class="string">"*"</span>) || token.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                stack.push(calculate(stack.pop(), stack.pop(), token));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">calculate</span><span class="params">(String num2, String num1, String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = Integer.parseInt(num1), n2 = Integer.parseInt(num2);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (token.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">            ans = n1 + n2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">            ans = n1 - n2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">            ans = n1 * n2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">            ans = n1 / n2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Reducing-the-List-In-place"><a href="#Solution-Two-Reducing-the-List-In-place" class="headerlink" title="Solution Two: Reducing the List In-place"></a>Solution Two: Reducing the List In-place</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Calculator</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 101 - Symmetric Tree</title>
    <url>/2020/06/27/leetcode-101/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>
<pre><code>1</code></pre><p>   / <br>  2   2<br> / \ / <br>3  4 4  3</p>
<p>But the following [1,2,2,null,3,null,3] is not:</p>
<pre><code>1</code></pre><p>   / <br>  2   2<br>   \   <br>   3    3</p>
<p>Follow up: Solve it both recursively and iteratively.</p>
<h2 id="Solution-One-Recursive"><a href="#Solution-One-Recursive" class="headerlink" title="Solution One: Recursive"></a>Solution One: Recursive</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Symmetric Tree.<br>Memory Usage: 39.6 MB, less than 7.86% of Java online submissions for Symmetric Tree.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode node1, TreeNode node2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> &amp;&amp; node2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> node1.val == node2.val &amp;&amp; compare(node1.left, node2.right)</span><br><span class="line">            &amp;&amp; compare(node1.right, node2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Iteratively"><a href="#Solution-Two-Iteratively" class="headerlink" title="Solution Two: Iteratively"></a>Solution Two: Iteratively</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 5.99% of Java online submissions for Symmetric Tree.<br>Memory Usage: 40.1 MB, less than 5.09% of Java online submissions for Symmetric Tree.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; stack1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; stack2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        TreeNode node1 = root.left;</span><br><span class="line">        TreeNode node2 = root.right;</span><br><span class="line">        <span class="keyword">while</span> (node1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack1.push(node1);</span><br><span class="line">            node1 = node1.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack2.push(node2);</span><br><span class="line">            node2 = node2.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty() &amp;&amp; !stack2.isEmpty()) &#123;</span><br><span class="line">            node1 = stack1.pop();</span><br><span class="line">            node2 = stack2.pop();</span><br><span class="line">            <span class="keyword">if</span> (node1.val != node2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node1 = node1.right;</span><br><span class="line">            node2 = node2.left;</span><br><span class="line">            <span class="keyword">while</span> (node1 != <span class="keyword">null</span> || node2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node1 == <span class="keyword">null</span> || node2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                stack1.push(node1);</span><br><span class="line">                node1 = node1.left;</span><br><span class="line">                stack2.push(node2);</span><br><span class="line">                node2 = node2.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty() &amp;&amp; stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        TreeNode t1 = q.poll();</span><br><span class="line">        TreeNode t2 = q.poll();</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1.val != t2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        q.add(t1.left);</span><br><span class="line">        q.add(t2.right);</span><br><span class="line">        q.add(t1.right);</span><br><span class="line">        q.add(t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 133 - Clone Graph</title>
    <url>/2020/06/29/leetcode-133/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a reference of a node in a connected undirected graph.</p>
<p>Return a deep copy (clone) of the graph.</p>
<p>Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.</p>
<p>class Node {<br>    public int val;<br>    public List<Node> neighbors;<br>}</p>
<p>Test case format:</p>
<p>For simplicity sake, each node’s value is the same as the node’s index (1-indexed). For example, the first node with val = 1, the second node with val = 2, and so on. The graph is represented in the test case using an adjacency list.</p>
<p>Adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.</p>
<p>The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.</p>
<h2 id="Solution-One-DFS"><a href="#Solution-One-DFS" class="headerlink" title="Solution One: DFS"></a>Solution One: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 38 ms, faster than 17.07% of Java online submissions for Clone Graph.<br>Memory Usage: 40.5 MB, less than 7.04% of Java online submissions for Clone Graph.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public List&lt;Node&gt; neighbors;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node() &#123;</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = new ArrayList&lt;Node&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = new ArrayList&lt;Node&gt;();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val, ArrayList&lt;Node&gt; _neighbors) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Node&gt; cloneMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">cloneGraph</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        cloneMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> cloneNode(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">cloneNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cloneMap.containsKey(node.val)) <span class="keyword">return</span> cloneMap.get(node.val);</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(node.val);</span><br><span class="line">        cloneMap.put(node.val, newNode);</span><br><span class="line">        <span class="keyword">for</span> (Node neighbor : node.neighbors) &#123;</span><br><span class="line">            newNode.neighbors.add(cloneNode(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 152 - Maximum Product Subarray</title>
    <url>/2020/06/30/leetcode-152/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>Example 1:</p>
<p>Input: [2,3,-2,4]<br>Output: 6<br>Explanation: [2,3] has the largest product 6.<br>Example 2:</p>
<p>Input: [-2,0,-1]<br>Output: 0<br>Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 36.11% of Java online submissions for Maximum Product Subarray.<br>Memory Usage: 40.2 MB, less than 12.48% of Java online submissions for Maximum Product Subarray.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length, ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = ans, min = ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = max;</span><br><span class="line">                max = min;</span><br><span class="line">                min = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            max = Math.max(nums[i], nums[i] * max);</span><br><span class="line">            min = Math.min(nums[i], nums[i] * min);</span><br><span class="line">            ans = Math.max(ans, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 130 - Surrounded Regions</title>
    <url>/2020/06/29/leetcode-130/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<p>Example:</p>
<p>X X X X<br>X O O X<br>X X O X<br>X O X X<br>After running your function, the board should be:</p>
<p>X X X X<br>X X X X<br>X X X X<br>X O X X<br>Explanation:</p>
<p>Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p>
<h2 id="Solution-One-DFS"><a href="#Solution-One-DFS" class="headerlink" title="Solution One: DFS"></a>Solution One: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 47.06% of Java online submissions for Surrounded Regions.<br>Memory Usage: 41.2 MB, less than 90.38% of Java online submissions for Surrounded Regions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        rows = board.length;</span><br><span class="line">        cols = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// search unavailble slot</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, cols - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, j);</span><br><span class="line">            dfs(board, rows - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set result</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'o'</span>) board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= rows || j &gt;= cols || board[i][j] != <span class="string">'O'</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        board[i][j] = <span class="string">'o'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">            dfs(board, i + direction[<span class="number">0</span>], j + direction[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 157 - Read N Characters Given Read4</title>
    <url>/2020/06/30/leetcode-157/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a file and assume that you can only read the file using a given method read4, implement a method to read n characters.</p>
<p>Method read4:</p>
<p>The API read4 reads 4 consecutive characters from the file, then writes those characters into the buffer array buf.</p>
<p>The return value is the number of actual characters read.</p>
<p>Note that read4() has its own file pointer, much like FILE *fp in C.</p>
<p>Definition of read4:</p>
<pre><code>Parameter:  char[] buf
Returns:    int</code></pre><p>Note: buf[] is destination not source, the results from read4 will be copied to buf[]<br>Below is a high level example of how read4 works:</p>
<p>File file(“abcdefghijk”); // File is “abcdefghijk”, initially file pointer (fp) points to ‘a’<br>char[] buf = new char[4]; // Create buffer with enough space to store characters<br>read4(buf); // read4 returns 4. Now buf = “abcd”, fp points to ‘e’<br>read4(buf); // read4 returns 4. Now buf = “efgh”, fp points to ‘i’<br>read4(buf); // read4 returns 3. Now buf = “ijk”, fp points to end of file</p>
<p>Method read:</p>
<p>By using the read4 method, implement the method read that reads n characters from the file and store it in the buffer array buf. Consider that you cannot manipulate the file directly.</p>
<p>The return value is the number of actual characters read.</p>
<p>Definition of read:</p>
<pre><code>Parameters:    char[] buf, int n
Returns:    int</code></pre><p>Note: buf[] is destination not source, you will need to write the results to buf[]</p>
<p>Example 1:</p>
<p>Input: file = “abc”, n = 4<br>Output: 3<br>Explanation: After calling your read method, buf should contain “abc”. We read a total of 3 characters from the file, so return 3. Note that “abc” is the file’s content, not buf. buf is the destination buffer that you will have to write the results to.<br>Example 2:</p>
<p>Input: file = “abcde”, n = 5<br>Output: 5<br>Explanation: After calling your read method, buf should contain “abcde”. We read a total of 5 characters from the file, so return 5.<br>Example 3:</p>
<p>Input: file = “abcdABCD1234”, n = 12<br>Output: 12<br>Explanation: After calling your read method, buf should contain “abcdABCD1234”. We read a total of 12 characters from the file, so return 12.<br>Example 4:</p>
<p>Input: file = “leetcode”, n = 5<br>Output: 5<br>Explanation: After calling your read method, buf should contain “leetc”. We read a total of 5 characters from the file, so return 5.</p>
<p>Note:</p>
<p>Consider that you cannot manipulate the file directly, the file is only accesible for read4 but not for read.<br>The read function will only be called once for each test case.<br>You may assume the destination buffer array, buf, is guaranteed to have enough space for storing n characters.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Read N Characters Given Read4.<br>Memory Usage: 39.4 MB, less than 5.04% of Java online submissions for Read N Characters Given Read4.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The read4 API is defined in the parent class Reader4.</span></span><br><span class="line"><span class="comment"> *     int read4(char[] buf);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Reader4</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf Destination buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n   Number of characters to read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    The number of actual characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] tmp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; (size = read4(tmp)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = Math.min(size, n);</span><br><span class="line">            System.arraycopy(tmp, <span class="number">0</span>, buf, offset, size);</span><br><span class="line">            offset += size;</span><br><span class="line">            n -= size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-158-Read-N-Characters-Given-Read4-II-Call-multiple-times"><a href="#Leetcode-158-Read-N-Characters-Given-Read4-II-Call-multiple-times" class="headerlink" title="Leetcode 158 - Read N Characters Given Read4 II - Call multiple times"></a>Leetcode 158 - Read N Characters Given Read4 II - Call multiple times</h1><p><strong>Description</strong><br>Given a file and assume that you can only read the file using a given method read4, implement a method read to read n characters. Your method read may be called multiple times.</p>
<p>Method read4:</p>
<p>The API read4 reads 4 consecutive characters from the file, then writes those characters into the buffer array buf.</p>
<p>The return value is the number of actual characters read.</p>
<p>Note that read4() has its own file pointer, much like FILE *fp in C.</p>
<p>Definition of read4:</p>
<pre><code>Parameter:  char[] buf
Returns:    int</code></pre><p>Note: buf[] is destination not source, the results from read4 will be copied to buf[]<br>Below is a high level example of how read4 works:</p>
<p>File file(“abcdefghijk”); // File is “abcdefghijk”, initially file pointer (fp) points to ‘a’<br>char[] buf = new char[4]; // Create buffer with enough space to store characters<br>read4(buf); // read4 returns 4. Now buf = “abcd”, fp points to ‘e’<br>read4(buf); // read4 returns 4. Now buf = “efgh”, fp points to ‘i’<br>read4(buf); // read4 returns 3. Now buf = “ijk”, fp points to end of file</p>
<p>Method read:</p>
<p>By using the read4 method, implement the method read that reads n characters from the file and store it in the buffer array buf. Consider that you cannot manipulate the file directly.</p>
<p>The return value is the number of actual characters read.</p>
<p>Definition of read:</p>
<pre><code>Parameters:    char[] buf, int n
Returns:    int</code></pre><p>Note: buf[] is destination not source, you will need to write the results to buf[]</p>
<p>Example 1:</p>
<p>File file(“abc”);<br>Solution sol;<br>// Assume buf is allocated and guaranteed to have enough space for storing all characters from the file.<br>sol.read(buf, 1); // After calling your read method, buf should contain “a”. We read a total of 1 character from the file, so return 1.<br>sol.read(buf, 2); // Now buf should contain “bc”. We read a total of 2 characters from the file, so return 2.<br>sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.<br>Example 2:</p>
<p>File file(“abc”);<br>Solution sol;<br>sol.read(buf, 4); // After calling your read method, buf should contain “abc”. We read a total of 3 characters from the file, so return 3.<br>sol.read(buf, 1); // We have reached the end of file, no more characters can be read. So return 0.</p>
<p>Note:</p>
<p>Consider that you cannot manipulate the file directly, the file is only accesible for read4 but not for read.<br>The read function may be called multiple times.<br>Please remember to RESET your class variables declared in Solution, as static/class variables are persisted across multiple test cases. Please see here for more details.<br>You may assume the destination buffer array, buf, is guaranteed to have enough space for storing n characters.<br>It is guaranteed that in a given test case the same buffer buf is called by read.</p>
<h2 id="Solution-One-1"><a href="#Solution-One-1" class="headerlink" title="Solution One"></a>Solution One</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Read N Characters Given Read4 II - Call multiple times.<br>Memory Usage: 37.9 MB, less than 84.54% of Java online submissions for Read N Characters Given Read4 II - Call multiple times.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The read4 API is defined in the parent class Reader4.</span></span><br><span class="line"><span class="comment"> *     int read4(char[] buf); </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Reader4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] tmp = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf Destination buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n   Number of characters to read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    The number of actual characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, offset = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// read previsous one</span></span><br><span class="line">        <span class="keyword">if</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            len = Math.min(tmp.length, n);</span><br><span class="line">            System.arraycopy(tmp, <span class="number">0</span>, buf, offset, len);</span><br><span class="line">            n -= len;</span><br><span class="line">            offset += len;</span><br><span class="line">            <span class="comment">// reset tmp array</span></span><br><span class="line">            <span class="keyword">if</span> (len &lt; tmp.length) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] newTmp = <span class="keyword">new</span> <span class="keyword">char</span>[tmp.length - len];</span><br><span class="line">                System.arraycopy(tmp, len, newTmp, <span class="number">0</span>, newTmp.length);</span><br><span class="line">                tmp = newTmp;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if no more read needed</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// continue read</span></span><br><span class="line">        <span class="keyword">char</span>[] curBuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span> &amp;&amp; (len = read4(curBuf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> actualLen = Math.min(n, len);</span><br><span class="line">            System.arraycopy(curBuf, <span class="number">0</span>, buf, offset, actualLen);</span><br><span class="line">            <span class="keyword">if</span> (len &gt; n) &#123;</span><br><span class="line">                <span class="comment">// keep unused buf</span></span><br><span class="line">                tmp = <span class="keyword">new</span> <span class="keyword">char</span>[len - n];</span><br><span class="line">                System.arraycopy(curBuf, n, tmp, <span class="number">0</span>, len - n);</span><br><span class="line">            &#125;</span><br><span class="line">            n -= actualLen;</span><br><span class="line">            offset += actualLen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> offset;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 161 - One Edit Distance</title>
    <url>/2020/07/01/leetcode-161/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given two strings s and t, determine if they are both one edit distance apart.</p>
<p>Note: </p>
<p>There are 3 possiblities to satisify one edit distance apart:</p>
<p>Insert a character into s to get t<br>Delete a character from s to get t<br>Replace a character of s to get t<br>Example 1:</p>
<p>Input: s = “ab”, t = “acb”<br>Output: true<br>Explanation: We can insert ‘c’ into s to get t.<br>Example 2:</p>
<p>Input: s = “cab”, t = “ad”<br>Output: false<br>Explanation: We cannot get t from s by only one step.<br>Example 3:</p>
<p>Input: s = “1203”, t = “1213”<br>Output: true<br>Explanation: We can replace ‘0’ with ‘1’ to get t.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for One Edit Distance.<br>Memory Usage: 38.1 MB, less than 58.28% of Java online submissions for One Edit Distance.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneEditDistance</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> diff = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = s.length(), n = t.length();</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(m - n) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">char</span> ci = s.charAt(i), cj = t.charAt(j);</span><br><span class="line">            <span class="keyword">if</span> (ci == cj) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                diff = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (m == n) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != m || j != n) diff = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> diff;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Related-Question"><a href="#Related-Question" class="headerlink" title="Related Question"></a>Related Question</h2><ol start="72">
<li>Edit Distance</li>
</ol>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 142 - Linked List Cycle II</title>
    <url>/2020/06/30/leetcode-142/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p>
<p>Note: Do not modify the linked list.</p>
<p>Example 1:</p>
<p>Input: head = [3,2,0,-4], pos = 1<br>Output: tail connects to node index 1<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.</p>
<h2 id="Solution-One-Use-HashSet"><a href="#Solution-One-Use-HashSet" class="headerlink" title="Solution One: Use HashSet"></a>Solution One: Use HashSet</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 9 ms, faster than 5.28% of Java online submissions for Linked List Cycle II.<br>Memory Usage: 43.8 MB, less than 5.02% of Java online submissions for Linked List Cycle II.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; recordSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (recordSet.contains(tmp)) <span class="keyword">return</span> tmp;</span><br><span class="line">            recordSet.add(tmp);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Floyd’s-Tortoise-and-Hare"><a href="#Solution-Two-Floyd’s-Tortoise-and-Hare" class="headerlink" title="Solution Two: Floyd’s Tortoise and Hare"></a>Solution Two: Floyd’s Tortoise and Hare</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Linked List Cycle II.<br>Memory Usage: 39 MB, less than 98.04% of Java online submissions for Linked List Cycle II.<br><a href="https://leetcode.com/problems/linked-list-cycle-ii/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/solution/</a></p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">getIntersect</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode tortoise = head;</span><br><span class="line">        ListNode hare = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A fast pointer will either loop around a cycle and meet the slow</span></span><br><span class="line">        <span class="comment">// pointer or reach the `null` at the end of a non-cyclic list.</span></span><br><span class="line">        <span class="keyword">while</span> (hare != <span class="keyword">null</span> &amp;&amp; hare.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tortoise = tortoise.next;</span><br><span class="line">            hare = hare.next.next;</span><br><span class="line">            <span class="keyword">if</span> (tortoise == hare) &#123;</span><br><span class="line">                <span class="keyword">return</span> tortoise;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there is a cycle, the fast/slow pointers will intersect at some</span></span><br><span class="line">        <span class="comment">// node. Otherwise, there is no cycle, so we cannot find an entrance to</span></span><br><span class="line">        <span class="comment">// a cycle.</span></span><br><span class="line">        ListNode intersect = getIntersect(head);</span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To find the entrance to the cycle, we have two pointers traverse at</span></span><br><span class="line">        <span class="comment">// the same speed -- one from the front of the list, and the other from</span></span><br><span class="line">        <span class="comment">// the point of intersection.</span></span><br><span class="line">        ListNode ptr1 = head;</span><br><span class="line">        ListNode ptr2 = intersect;</span><br><span class="line">        <span class="keyword">while</span> (ptr1 != ptr2) &#123;</span><br><span class="line">            ptr1 = ptr1.next;</span><br><span class="line">            ptr2 = ptr2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ptr1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 153 - Find Minimum in Rotated Sorted Array &amp;&amp; 154 - Find Minimum in Rotated Sorted Array II</title>
    <url>/2020/06/30/leetcode-153/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Example 1:</p>
<p>Input: [3,4,5,1,2]<br>Output: 1<br>Example 2:</p>
<p>Input: [4,5,6,7,0,1,2]<br>Output: 0</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Minimum in Rotated Sorted Array.<br>Memory Usage: 39.1 MB, less than 57.99% of Java online submissions for Find Minimum in Rotated Sorted Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// find max</span></span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>, mid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == size - <span class="number">1</span> || nums[mid] &gt; nums[mid + <span class="number">1</span>]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mid == size - <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> nums[mid + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#Leetcode-154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="Leetcode 154 - Find Minimum in Rotated Sorted Array II"></a>Leetcode 154 - Find Minimum in Rotated Sorted Array II</h1>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 162 - Find Peak Element</title>
    <url>/2020/07/01/leetcode-162/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that nums[-1] = nums[n] = -∞.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1]<br>Output: 2<br>Explanation: 3 is a peak element and your function should return the index number 2.<br>Example 2:</p>
<p>Input: nums = [1,2,1,3,5,6,4]<br>Output: 1 or 5<br>Explanation: Your function can return either index number 1 where the peak element is 2,<br>             or index number 5 where the peak element is 6.<br>Follow up: Your solution should be in logarithmic complexity.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Find Peak Element.<br>Memory Usage: 39.4 MB, less than 30.10% of Java online submissions for Find Peak Element.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) j = mid;</span><br><span class="line">            <span class="keyword">else</span> i = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 163 - Missing Ranges</title>
    <url>/2020/07/01/leetcode-163/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a sorted integer array nums, where the range of elements are in the inclusive range [lower, upper], return its missing ranges.</p>
<p>Example:</p>
<p>Input: nums = [0, 1, 3, 50, 75], lower = 0 and upper = 99,<br>Output: [“2”, “4-&gt;49”, “51-&gt;74”, “76-&gt;99”]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 6 ms, faster than 65.31% of Java online submissions for Missing Ranges.<br>Memory Usage: 37.8 MB, less than 66.85% of Java online submissions for Missing Ranges.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findMissingRanges</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lower, <span class="keyword">int</span> upper)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">int</span> preNum = lower; <span class="comment">// last num expected to appear</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == preNum + <span class="number">1</span>) &#123;</span><br><span class="line">                ans.add(String.valueOf(preNum));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; preNum) &#123;</span><br><span class="line">                ans.add(String.valueOf(preNum) + <span class="string">"-&gt;"</span> </span><br><span class="line">                        + String.valueOf(nums[i] - <span class="number">1</span>));</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == Integer.MAX_VALUE) <span class="keyword">break</span>;</span><br><span class="line">            preNum = nums[i] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; nums[size - <span class="number">1</span>] == Integer.MAX_VALUE) <span class="keyword">return</span> ans;</span><br><span class="line">        preNum = size == <span class="number">0</span> ? lower : nums[size - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (preNum == upper) &#123;</span><br><span class="line">            ans.add(String.valueOf(preNum));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (preNum &lt; upper) &#123;</span><br><span class="line">            ans.add(String.valueOf(preNum) + <span class="string">"-&gt;"</span> </span><br><span class="line">                    + String.valueOf(upper));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 168 - Excel Sheet Column Title &amp; Leetcode 171 - Excel Sheet Column Number</title>
    <url>/2020/07/01/leetcode-168/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a positive integer, return its corresponding column title as appear in an Excel sheet.</p>
<p>For example:</p>
<pre><code>1 -&gt; A
2 -&gt; B
3 -&gt; C
...
26 -&gt; Z
27 -&gt; AA
28 -&gt; AB 
...</code></pre><p>Example 1:</p>
<p>Input: 1<br>Output: “A”<br>Example 2:</p>
<p>Input: 28<br>Output: “AB”<br>Example 3:</p>
<p>Input: 701<br>Output: “ZY”</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 7 ms, faster than 15.21% of Java online submissions for Excel Sheet Column Title.<br>Memory Usage: 37.1 MB, less than 31.78% of Java online submissions for Excel Sheet Column Title.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n --;</span><br><span class="line">            ans = (<span class="keyword">char</span>)(<span class="string">'A'</span> + n % <span class="number">26</span>) + ans;</span><br><span class="line">            n /= <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-171-Excel-Sheet-Column-Number"><a href="#Leetcode-171-Excel-Sheet-Column-Number" class="headerlink" title="Leetcode 171 - Excel Sheet Column Number"></a>Leetcode 171 - Excel Sheet Column Number</h1><p><strong>Description</strong><br>Given a column title as appear in an Excel sheet, return its corresponding column number.</p>
<p>For example:</p>
<pre><code>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
...</code></pre><p>Example 1:</p>
<p>Input: “A”<br>Output: 1<br>Example 2:</p>
<p>Input: “AB”<br>Output: 28<br>Example 3:</p>
<p>Input: “ZY”<br>Output: 701</p>
<p>Constraints:</p>
<p>1 &lt;= s.length &lt;= 7<br>s consists only of uppercase English letters.<br>s is between “A” and “FXSHRXW”.</p>
<h2 id="Solution-One-1"><a href="#Solution-One-1" class="headerlink" title="Solution One"></a>Solution One</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 100.00% of Java online submissions for Excel Sheet Column Number.<br>Memory Usage: 38.2 MB, less than 63.06% of Java online submissions for Excel Sheet Column Number.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            ans += (s.charAt(size - <span class="number">1</span> - i) - <span class="string">'A'</span> + <span class="number">1</span>) * Math.pow(<span class="number">26</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 189 - Rotate Array</title>
    <url>/2020/07/01/leetcode-189/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<p>Follow up:</p>
<p>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,4,5,6,7], k = 3<br>Output: [5,6,7,1,2,3,4]<br>Explanation:<br>rotate 1 steps to the right: [7,1,2,3,4,5,6]<br>rotate 2 steps to the right: [6,7,1,2,3,4,5]<br>rotate 3 steps to the right: [5,6,7,1,2,3,4]<br>Example 2:</p>
<p>Input: nums = [-1,-100,3,99], k = 2<br>Output: [3,99,-1,-100]<br>Explanation:<br>rotate 1 steps to the right: [99,-1,-100,3]<br>rotate 2 steps to the right: [3,99,-1,-100]</p>
<p>Constraints:</p>
<p>1 &lt;= nums.length &lt;= 2 * 10^4<br>It’s guaranteed that nums[i] fits in a 32 bit-signed integer.<br>k &gt;= 0</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Rotate Array.<br>Memory Usage: 40.1 MB, less than 48.75% of Java online submissions for Rotate Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span> || k % nums.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        <span class="keyword">int</span> start = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[start];</span><br><span class="line">        <span class="keyword">int</span> i = start, count = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = (i - k + nums.length) % nums.length;</span><br><span class="line">            <span class="keyword">if</span> (left == start) &#123;</span><br><span class="line">                nums[i] = tmp;</span><br><span class="line">                start--;</span><br><span class="line">                tmp = nums[start];</span><br><span class="line">                i = start;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[i] = nums[left];</span><br><span class="line">                i = left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Using-Reverse"><a href="#Solution-Two-Using-Reverse" class="headerlink" title="Solution Two: Using Reverse"></a>Solution Two: Using Reverse</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 186 - Reverse Words in a String II</title>
    <url>/2020/07/01/leetcode-186/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an input string , reverse the string word by word. </p>
<p>Example:</p>
<p>Input:  [“t”,”h”,”e”,” “,”s”,”k”,”y”,” “,”i”,”s”,” “,”b”,”l”,”u”,”e”]<br>Output: [“b”,”l”,”u”,”e”,” “,”i”,”s”,” “,”s”,”k”,”y”,” “,”t”,”h”,”e”]<br>Note: </p>
<p>A word is defined as a sequence of non-space characters.<br>The input string does not contain leading or trailing spaces.<br>The words are always separated by a single space.<br>Follow up: Could you do it in-place without allocating extra space?</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.50% of Java online submissions for Reverse Words in a String II.<br>Memory Usage: 47.5 MB, less than 33.76% of Java online submissions for Reverse Words in a String II.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseWords</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reverse the whole array</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            swap(s, i++, j--);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// reverse each word</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (end &lt;= s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; s.length &amp;&amp; s[end] != <span class="string">' '</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i = start;</span><br><span class="line">            j = end - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                swap(s, i++, j--);</span><br><span class="line">            &#125;</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 149 - Max Points on a Line</title>
    <url>/2020/06/30/leetcode-149/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.</p>
<p>Example 1:</p>
<p>Input: [[1,1],[2,2],[3,3]]<br>Output: 3<br>Explanation:<br>^<br>|<br>|        o<br>|     o<br>|  o<br>+————-&gt;<br>0  1  2  3  4<br>Example 2:</p>
<p>Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br>Output: 4<br>Explanation:<br>^<br>|<br>|  o<br>|     o        o<br>|        o<br>|  o        o<br>+——————-&gt;<br>0  1  2  3  4  5  6<br>NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<h2 id="Solution-One-Enumeration-with-Pair"><a href="#Solution-One-Enumeration-with-Pair" class="headerlink" title="Solution One: Enumeration with Pair"></a>Solution One: Enumeration with Pair</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 36 ms, faster than 24.33% of Java online submissions for Max Points on a Line.<br>Memory Usage: 39.4 MB, less than 58.44% of Java online submissions for Max Points on a Line.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Pair&lt;Integer, Integer&gt; <span class="title">slope_coprime</span><span class="params">(<span class="keyword">int</span> dy, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">        Integer gcd = BigInteger.valueOf(dx).gcd(BigInteger.valueOf(dy)).intValue();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;Integer, Integer&gt;(dy / gcd, dx / gcd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points == <span class="keyword">null</span> || points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// &lt;k, &lt;b, freq&gt;&gt;</span></span><br><span class="line">        Map&lt;Pair&lt;Integer, Integer&gt;, Integer&gt; lineMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> verticalCount, duplicates;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            lineMap.clear();</span><br><span class="line">            duplicates = <span class="number">0</span>;</span><br><span class="line">            verticalCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> dy = points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> dx = points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (dx == <span class="number">0</span> &amp;&amp; dy == <span class="number">0</span>) duplicates++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">0</span>) verticalCount++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Pair&lt;Integer, Integer&gt; slope = <span class="keyword">this</span>.slope_coprime(dy, dx);</span><br><span class="line">                    <span class="keyword">int</span> freq = lineMap.getOrDefault(slope, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">                    lineMap.put(slope, freq);</span><br><span class="line">                    curMax = Math.max(curMax, freq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            curMax = Math.max(curMax, verticalCount);</span><br><span class="line">            ans = Math.max(ans, curMax + duplicates);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(lineMap);</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p>use Map&lt;String, Integer&gt;  instead of Map&lt;Pair&lt;Integer, Integer&gt;, Integer&gt; </p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 191 - Number of 1 Bits</title>
    <url>/2020/07/01/leetcode-191/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Write a function that takes an unsigned integer and return the number of ‘1’ bits it has (also known as the Hamming weight).</p>
<p>Example 1:</p>
<p>Input: 00000000000000000000000000001011<br>Output: 3<br>Explanation: The input binary string 00000000000000000000000000001011 has a total of three ‘1’ bits.<br>Example 2:</p>
<p>Input: 00000000000000000000000010000000<br>Output: 1<br>Explanation: The input binary string 00000000000000000000000010000000 has a total of one ‘1’ bit.<br>Example 3:</p>
<p>Input: 11111111111111111111111111111101<br>Output: 31<br>Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one ‘1’ bits.</p>
<p>Note:</p>
<p>Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.<br>In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3 above the input represents the signed integer -3.</p>
<p>Follow up:</p>
<p>If this function is called many times, how would you optimize it?</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Number of 1 Bits.<br>Memory Usage: 36.5 MB, less than 43.95% of Java online submissions for Number of 1 Bits.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(1).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            ans += n &amp; <span class="number">1</span>;</span><br><span class="line">            n = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Bit Operations</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 198 - House Robber &amp; 213 - House Robber II</title>
    <url>/2020/07/01/leetcode-198/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>             Total amount you can rob = 1 + 3 = 4.<br>Example 2:</p>
<p>Input: nums = [2,7,9,3,1]<br>Output: 12<br>Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).<br>             Total amount you can rob = 2 + 9 + 1 = 12.</p>
<p>Constraints:</p>
<p>0 &lt;= nums.length &lt;= 100<br>0 &lt;= nums[i] &lt;= 400</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber.<br>Memory Usage: 37.1 MB, less than 33.80% of Java online submissions for House Robber.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            nums[i] = Math.max(nums[i - <span class="number">2</span>] + nums[i], nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-213-House-Robber-II"><a href="#Leetcode-213-House-Robber-II" class="headerlink" title="Leetcode 213 - House Robber II"></a>Leetcode 213 - House Robber II</h1><p><strong>Description</strong><br>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:</p>
<p>Input: [2,3,2]<br>Output: 3<br>Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),<br>             because they are adjacent houses.<br>Example 2:</p>
<p>Input: [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>             Total amount you can rob = 1 + 3 = 4.</p>
<h2 id="Solution-One-DP"><a href="#Solution-One-DP" class="headerlink" title="Solution One: DP"></a>Solution One: DP</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for House Robber II.<br>Memory Usage: 39 MB, less than 5.26% of Java online submissions for House Robber II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> include = <span class="number">0</span>, exclude = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lo; j &lt;= hi; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = include, e = exclude;</span><br><span class="line">            include = e + num[j];</span><br><span class="line">            exclude = Math.max(e, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(include, exclude);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, nums.length - <span class="number">2</span>), rob(nums, <span class="number">1</span>, nums.length - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 86 - Partition List</title>
    <url>/2020/06/30/leetcode-86/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p>
<p>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>Example:</p>
<p>Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
<h2 id="Solution-One-Two-Pointer"><a href="#Solution-One-Two-Pointer" class="headerlink" title="Solution One: Two Pointer"></a>Solution One: Two Pointer</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Partition List.<br>Memory Usage: 39.1 MB, less than 49.47% of Java online submissions for Partition List.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>, head);</span><br><span class="line">        ListNode head1 = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode tail1 = head1, head2 = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tmp = dummy;</span><br><span class="line">        <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode next = tmp.next;</span><br><span class="line">            <span class="keyword">if</span> (next.val &lt; x) &#123;</span><br><span class="line">                <span class="comment">// remove</span></span><br><span class="line">                tmp.next = next.next;</span><br><span class="line">                next.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// add after tail1</span></span><br><span class="line">                tail1.next = next;</span><br><span class="line">                tail1 = tail1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (head2 == <span class="keyword">null</span>) head2 = tmp.next;</span><br><span class="line">                tmp = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tail1.next = head2;</span><br><span class="line">        <span class="keyword">return</span> head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>LinkedList</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 84 - Largest Rectangle in Histogram</title>
    <url>/2020/06/27/leetcode-84/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p>
<h2 id="Solution-One-Brute-Force"><a href="#Solution-One-Brute-Force" class="headerlink" title="Solution One: Brute Force"></a>Solution One: Brute Force</h2><h2 id="Solution-Two-Monotonic-Stack"><a href="#Solution-Two-Monotonic-Stack" class="headerlink" title="Solution Two: Monotonic Stack"></a>Solution Two: Monotonic Stack</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 6 ms, faster than 88.86% of Java online submissions for Largest Rectangle in Histogram.<br>Memory Usage: 40.3 MB, less than 92.17% of Java online submissions for Largest Rectangle in Histogram.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = heights.length;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; indexStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        indexStack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (indexStack.peek() != -<span class="number">1</span> &amp;&amp; heights[i] &lt; heights[indexStack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> H = heights[indexStack.pop()];</span><br><span class="line">                ans = Math.max(ans, H * (i - indexStack.peek() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            indexStack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (indexStack.peek() != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> H = heights[indexStack.pop()];</span><br><span class="line">            ans = Math.max(ans, H * (size - indexStack.peek() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Monotonic Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 96 - Unique Binary Search Trees</title>
    <url>/2020/06/27/leetcode-96/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n?</p>
<p>Example:</p>
<p>Input: 3<br>Output: 5<br>Explanation:<br>Given n = 3, there are a total of 5 unique BST’s:</p>
<p>   1         3     3      2      1<br>    \       /     /      / \      <br>     3     2     1      1   3      2<br>    /     /       \                 <br>   2     1         2                 3</p>
<h2 id="Solution-One-Dynamic-Programming"><a href="#Solution-One-Dynamic-Programming" class="headerlink" title="Solution One: Dynamic Programming"></a>Solution One: Dynamic Programming</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Unique Binary Search Trees.<br>Memory Usage: 36 MB, less than 71.98% of Java online submissions for Unique Binary Search Trees.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i - <span class="number">1</span> - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 174 - Dungeon Game</title>
    <url>/2020/07/02/leetcode-174/</url>
    <content><![CDATA[<p><strong>Description</strong><br>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.</p>
<p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.</p>
<p>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).</p>
<p>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.</p>
<p>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</p>
<p>For example, given the dungeon below, the initial health of the knight must be at least 7 if he follows the optimal path RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.</p>
<p>-2 (K)    -3        3<br>-5        -10        1<br>10        30        -5 (P)</p>
<p>Note:</p>
<p>The knight’s health has no upper bound.<br>Any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>
<h2 id="Solution-One-DFS"><a href="#Solution-One-DFS" class="headerlink" title="Solution One: DFS"></a>Solution One: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Time Limit Exceeded</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(M * N), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M, N, min;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dungeon == <span class="keyword">null</span> || dungeon.length == <span class="number">0</span> || dungeon[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        M = dungeon.length;</span><br><span class="line">        N = dungeon[<span class="number">0</span>].length;</span><br><span class="line">        min = Integer.MIN_VALUE;</span><br><span class="line">        minMemo = <span class="keyword">new</span> <span class="keyword">int</span>[M][N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">            Arrays.fill(minMemo[i], Integer.MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        forward(dungeon, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> min &gt; <span class="number">0</span> ? <span class="number">0</span> : -min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>[][] dungeon, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> minHealth, <span class="keyword">int</span> health)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curHealth = health + dungeon[i][j];</span><br><span class="line">        <span class="keyword">int</span> curMinHealth = Math.min(minHealth, curHealth);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// move right</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; N) </span><br><span class="line">            forward(dungeon, i, j + <span class="number">1</span>, curMinHealth, curHealth);</span><br><span class="line">        <span class="comment">// move down</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; M) </span><br><span class="line">            forward(dungeon, i + <span class="number">1</span>, j, curMinHealth, curHealth);</span><br><span class="line">        <span class="comment">// arrive</span></span><br><span class="line">        <span class="keyword">if</span> (i == M - <span class="number">1</span> &amp;&amp; j == N - <span class="number">1</span>) &#123;</span><br><span class="line">            min = Math.max(min, curMinHealth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><p>Dynamic Programming from right-down to left-up</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> inf = Integer.MAX_VALUE;</span><br><span class="line">  <span class="keyword">int</span>[][] dp;</span><br><span class="line">  <span class="keyword">int</span> rows, cols;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinHealth</span><span class="params">(<span class="keyword">int</span> currCell, <span class="keyword">int</span> nextRow, <span class="keyword">int</span> nextCol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nextRow &gt;= <span class="keyword">this</span>.rows || nextCol &gt;= <span class="keyword">this</span>.cols)</span><br><span class="line">      <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">int</span> nextCell = <span class="keyword">this</span>.dp[nextRow][nextCol];</span><br><span class="line">    <span class="comment">// hero needs at least 1 point to survive</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(<span class="number">1</span>, nextCell - currCell);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="keyword">int</span>[][] dungeon)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rows = dungeon.length;</span><br><span class="line">    <span class="keyword">this</span>.cols = dungeon[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">this</span>.dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] arr : <span class="keyword">this</span>.dp) &#123;</span><br><span class="line">      Arrays.fill(arr, <span class="keyword">this</span>.inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> currCell, rightHealth, downHealth, nextHealth, minHealth;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="keyword">this</span>.rows - <span class="number">1</span>; row &gt;= <span class="number">0</span>; --row) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="keyword">this</span>.cols - <span class="number">1</span>; col &gt;= <span class="number">0</span>; --col) &#123;</span><br><span class="line">        currCell = dungeon[row][col];</span><br><span class="line"></span><br><span class="line">        rightHealth = getMinHealth(currCell, row, col + <span class="number">1</span>);</span><br><span class="line">        downHealth = getMinHealth(currCell, row + <span class="number">1</span>, col);</span><br><span class="line">        nextHealth = Math.min(rightHealth, downHealth);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextHealth != inf) &#123;</span><br><span class="line">          minHealth = nextHealth;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          minHealth = currCell &gt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">1</span> - currCell;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dp[row][col] = minHealth;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 205 - Isomorphic Strings</title>
    <url>/2020/07/02/leetcode-205/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given two strings s and t, determine if they are isomorphic.</p>
<p>Two strings are isomorphic if the characters in s can be replaced to get t.</p>
<p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.</p>
<p>Example 1:</p>
<p>Input: s = “egg”, t = “add”<br>Output: true<br>Example 2:</p>
<p>Input: s = “foo”, t = “bar”<br>Output: false<br>Example 3:</p>
<p>Input: s = “paper”, t = “title”<br>Output: true<br>Note:<br>You may assume both s and t have the same length.</p>
<h2 id="Solution-One-Two-char-array"><a href="#Solution-One-Two-char-array" class="headerlink" title="Solution One: Two char array"></a>Solution One: Two char array</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 10 ms, faster than 38.02% of Java online submissions for Isomorphic Strings.<br>Memory Usage: 40.4 MB, less than 9.58% of Java online submissions for Isomorphic Strings.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.equals(analyze(s), analyze(t));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] analyze(String s) &#123;</span><br><span class="line">        Map&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> src = s.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> tar = map.getOrDefault(src, (<span class="keyword">char</span>)(count++ + <span class="string">'a'</span>));</span><br><span class="line">            map.put(src, tar);</span><br><span class="line">            arr[i] = tar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h3><p>use one hashmap<br>compare while scanning</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 208 - Implement Trie (Prefix Tree)</title>
    <url>/2020/07/02/leetcode-208/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement a trie with insert, search, and startsWith methods.</p>
<p>Example:</p>
<p>Trie trie = new Trie();</p>
<p>trie.insert(“apple”);<br>trie.search(“apple”);   // returns true<br>trie.search(“app”);     // returns false<br>trie.startsWith(“app”); // returns true<br>trie.insert(“app”);<br>trie.search(“app”);     // returns true<br>Note:</p>
<p>You may assume that all inputs are consist of lowercase letters a-z.<br>All inputs are guaranteed to be non-empty strings.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 44 ms, faster than 20.74% of Java online submissions for Implement Trie (Prefix Tree).<br>Memory Usage: 51.2 MB, less than 23.01% of Java online submissions for Implement Trie (Prefix Tree).</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">boolean</span> isEnd;</span><br><span class="line">        Map&lt;Character, TrieNode&gt; nextMap;</span><br><span class="line">        TrieNode(<span class="keyword">char</span> newC) &#123;</span><br><span class="line">            c = newC;</span><br><span class="line">            isEnd = <span class="keyword">false</span>;</span><br><span class="line">            nextMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode(<span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = word.charAt(i);</span><br><span class="line">            TrieNode next = node.nextMap.getOrDefault(cur, <span class="keyword">new</span> TrieNode(cur));</span><br><span class="line">            node.nextMap.put(cur, next);</span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.nextMap.containsKey(cur)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node = node.nextMap.get(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> cur = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.nextMap.containsKey(cur)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node = node.nextMap.get(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TrieNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.isEnd) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> cur : node.nextMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(node.nextMap.get(cur))) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 647 - Palindromic Substrings</title>
    <url>/2020/07/03/leetcode-647/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string, your task is to count how many palindromic substrings in this string.</p>
<p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p>
<p>Example 1:</p>
<p>Input: “abc”<br>Output: 3<br>Explanation: Three palindromic strings: “a”, “b”, “c”.</p>
<p>Example 2:</p>
<p>Input: “aaa”<br>Output: 6<br>Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.</p>
<p>Note:</p>
<p>The input string length won’t exceed 1000.</p>
<h2 id="Solution-One-Brute-Force"><a href="#Solution-One-Brute-Force" class="headerlink" title="Solution One: Brute Force"></a>Solution One: Brute Force</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 770 ms, faster than 5.03% of Java online submissions for Palindromic Substrings.<br>Memory Usage: 40 MB, less than 19.98% of Java online submissions for Palindromic Substrings.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My first Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            List&lt;Integer&gt; list = map.getOrDefault(s.charAt(i), <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> start : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isPalindromic(s, start, i)) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(i);</span><br><span class="line">            map.put(s.charAt(i), list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindromic</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(start++) != s.charAt(end--)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Extend-from-center"><a href="#Solution-Two-Extend-from-center" class="headerlink" title="Solution Two: Extend from center"></a>Solution Two: Extend from center</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 4 ms, faster than 58.45% of Java online submissions for Palindromic Substrings.<br>Memory Usage: 39.2 MB, less than 45.65% of Java online submissions for Palindromic Substrings.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">// i is the mid point</span></span><br><span class="line">            extendPalindrome(s, i, i); <span class="comment">// odd length;</span></span><br><span class="line">            extendPalindrome(s, i, i + <span class="number">1</span>); <span class="comment">// even length</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">extendPalindrome</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;=<span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            count++; left--; right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Apple</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 97 - Interleaving String</title>
    <url>/2020/07/03/leetcode-97/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p>
<p>Example 1:</p>
<p>Input: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbcbcac”<br>Output: true<br>Example 2:</p>
<p>Input: s1 = “aabcc”, s2 = “dbbca”, s3 = “aadbbbaccc”<br>Output: false</p>
<h2 id="Solution-One-Recursion-with-memorization"><a href="#Solution-One-Recursion-with-memorization" class="headerlink" title="Solution One: Recursion with memorization"></a>Solution One: Recursion with memorization</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 83.10% of Java online submissions for Interleaving String.<br>Memory Usage: 39.9 MB, less than 6.11% of Java online submissions for Interleaving String.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(m * n), Time Complexity: O(m * n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Boolean[][] memo;</span><br><span class="line">    <span class="keyword">int</span> N1, N2, N3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == <span class="keyword">null</span> || s2 == <span class="keyword">null</span> || s3 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        N1 = s1.length();</span><br><span class="line">        N2 = s2.length();</span><br><span class="line">        N3 = s3.length();</span><br><span class="line">        <span class="keyword">if</span> (N1 + N2 != N3) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> Boolean[N1 + <span class="number">1</span>][N2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> search(s1, <span class="number">0</span>, s2, <span class="number">0</span>, s3);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String s1, <span class="keyword">int</span> i1, String s2, <span class="keyword">int</span> i2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// basic cases</span></span><br><span class="line">        <span class="keyword">if</span> (i1 == N1 &amp;&amp; i2 == N2) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// recursive case 1: memorized</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i1][i2] != <span class="keyword">null</span>) <span class="keyword">return</span> memo[i1][i2];</span><br><span class="line">        <span class="comment">// recursive case 2</span></span><br><span class="line">        <span class="keyword">int</span> i3 = i1 + i2;</span><br><span class="line">        <span class="keyword">char</span> c1 = i1 == N1 ? <span class="string">'?'</span> : s1.charAt(i1);</span><br><span class="line">        <span class="keyword">char</span> c2 = i2 == N2 ? <span class="string">'?'</span> : s2.charAt(i2);</span><br><span class="line">        <span class="keyword">char</span> c3 = s3.charAt(i3);</span><br><span class="line">        <span class="keyword">boolean</span> case1 = <span class="keyword">false</span>, case2 = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i1 != N1)</span><br><span class="line">            case1 = c1 == c3 &amp;&amp; search(s1, i1 + <span class="number">1</span>, s2, i2, s3);</span><br><span class="line">        <span class="keyword">if</span> (i2 != N2)</span><br><span class="line">            case2 = c2 == c3 &amp;&amp; search(s1, i1, s2, i2 + <span class="number">1</span>, s3);</span><br><span class="line">        memo[i1][i2] = case1 || case2;</span><br><span class="line">        <span class="keyword">return</span> memo[i1][i2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Using-2D-Dynamic-Programming"><a href="#Solution-Two-Using-2D-Dynamic-Programming" class="headerlink" title="Solution Two: Using 2D Dynamic Programming"></a>Solution Two: Using 2D Dynamic Programming</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Apple</tag>
        <tag>memorization</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 214 - Shortest Palindrome</title>
    <url>/2020/07/04/leetcode-214/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string s, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation.</p>
<p>Example 1:</p>
<p>Input: “aacecaaa”<br>Output: “aaacecaaa”<br>Example 2:</p>
<p>Input: “abcd”<br>Output: “dcbabcd”</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 127 ms, faster than 44.01% of Java online submissions for Shortest Palindrome.<br>Memory Usage: 40.3 MB, less than 18.73% of Java online submissions for Shortest Palindrome.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line">        <span class="keyword">int</span> rightStart = size / <span class="number">2</span>, leftEnd = (size + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        StringBuilder rightSB = <span class="keyword">new</span> StringBuilder(s.substring(rightStart));</span><br><span class="line">        StringBuilder leftSB = <span class="keyword">new</span> StringBuilder(s.substring(<span class="number">0</span>, leftEnd));</span><br><span class="line">        leftSB = leftSB.reverse();</span><br><span class="line">        <span class="keyword">int</span> newSize = size;</span><br><span class="line">        <span class="keyword">while</span> (rightStart &gt; <span class="number">0</span> &amp;&amp; leftSB.compareTo(rightSB) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// no overlap</span></span><br><span class="line">            <span class="keyword">if</span> (newSize % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                rightSB.insert(<span class="number">0</span>, s.charAt(--rightStart));</span><br><span class="line">                rightSB.deleteCharAt(rightSB.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// overlap one element</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightSB.deleteCharAt(rightSB.length() - <span class="number">1</span>);</span><br><span class="line">                leftSB.deleteCharAt(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            newSize--;</span><br><span class="line">        &#125;</span><br><span class="line">        rightSB = <span class="keyword">new</span> StringBuilder(s.substring(rightStart));</span><br><span class="line">        String rightS = rightSB.toString();</span><br><span class="line">        <span class="keyword">if</span> (newSize % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> rightSB.reverse().toString() + rightS;</span><br><span class="line">        <span class="keyword">return</span> rightSB.deleteCharAt(<span class="number">0</span>).reverse().toString() + rightS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-KMP"><a href="#Solution-Two-KMP" class="headerlink" title="Solution Two: KMP"></a>Solution Two: KMP</h2><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 217 - Contains Duplicate &amp;&amp; II &amp;&amp; III</title>
    <url>/2020/07/04/leetcode-217/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of integers, find if the array contains any duplicates.</p>
<p>Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,1]<br>Output: true<br>Example 2:</p>
<p>Input: [1,2,3,4]<br>Output: false<br>Example 3:</p>
<p>Input: [1,1,1,3,3,4,3,2,4,2]<br>Output: true</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 7 ms, faster than 26.73% of Java online submissions for Contains Duplicate.<br>Memory Usage: 47.8 MB, less than 14.34% of Java online submissions for Contains Duplicate.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(nlogn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-219-Contains-Duplicate-II"><a href="#Leetcode-219-Contains-Duplicate-II" class="headerlink" title="Leetcode 219 - Contains Duplicate II"></a>Leetcode 219 - Contains Duplicate II</h1><p><strong>Description</strong><br>Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1], k = 3<br>Output: true<br>Example 2:</p>
<p>Input: nums = [1,0,1,1], k = 1<br>Output: true<br>Example 3:</p>
<p>Input: nums = [1,2,3,1,2,3], k = 2<br>Output: false</p>
<h2 id="Solution-One-HashMap"><a href="#Solution-One-HashMap" class="headerlink" title="Solution One: HashMap"></a>Solution One: HashMap</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 14 ms, faster than 22.86% of Java online submissions for Contains Duplicate II.<br>Memory Usage: 50.6 MB, less than 5.06% of Java online submissions for Contains Duplicate II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(k), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// &lt;num, index&gt;</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexMap.containsKey(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// remove element whose distance if larger than k</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (indexMap.get(nums[i - k]) == i - k)</span><br><span class="line">                    indexMap.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// add current element</span></span><br><span class="line">            indexMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-220-Contains-Duplicate-III"><a href="#Leetcode-220-Contains-Duplicate-III" class="headerlink" title="Leetcode 220 - Contains Duplicate III"></a>Leetcode 220 - Contains Duplicate III</h1><p><strong>Description</strong><br>Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.</p>
<p>Example 1:</p>
<p>Input: nums = [1,2,3,1], k = 3, t = 0<br>Output: true<br>Example 2:</p>
<p>Input: nums = [1,0,1,1], k = 1, t = 2<br>Output: true<br>Example 3:</p>
<p>Input: nums = [1,5,9,1,5,9], k = 2, t = 3<br>Output: false</p>
<h2 id="Solution-One-1"><a href="#Solution-One-1" class="headerlink" title="Solution One"></a>Solution One</h2><!-- more -->

<h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 24 ms, faster than 29.01% of Java online submissions for Contains Duplicate III.<br>Memory Usage: 45 MB, less than 5.05% of Java online submissions for Contains Duplicate III.</p>
<h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(k), Time Complexity: O(nlogn).</p>
<h3 id="Java-code-2"><a href="#Java-code-2" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// &lt;num, index&gt;</span></span><br><span class="line">        TreeMap&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        t = Math.abs(t);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(indexMap);</span></span><br><span class="line">            <span class="keyword">long</span> hi = Math.min((<span class="keyword">long</span>)nums[i] + (<span class="keyword">long</span>)t, (<span class="keyword">long</span>)Integer.MAX_VALUE);</span><br><span class="line">            <span class="keyword">long</span> lo = Math.max((<span class="keyword">long</span>)nums[i] - (<span class="keyword">long</span>)t, (<span class="keyword">long</span>)Integer.MIN_VALUE);</span><br><span class="line">            <span class="keyword">if</span> (!indexMap.subMap((<span class="keyword">int</span>)lo, <span class="keyword">true</span>, (<span class="keyword">int</span>)hi, <span class="keyword">true</span>).isEmpty())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// remove element whose distance if larger than k</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (indexMap.get(nums[i - k]) == i - k)</span><br><span class="line">                    indexMap.remove(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// add current element</span></span><br><span class="line">            indexMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Bit Operations</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 225 -  Implement Stack using Queues</title>
    <url>/2020/07/05/leetcode-225/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement the following operations of a stack using queues.</p>
<p>push(x) – Push element x onto stack.<br>pop() – Removes the element on top of the stack.<br>top() – Get the top element.<br>empty() – Return whether the stack is empty.<br>Example:</p>
<p>MyStack stack = new MyStack();</p>
<p>stack.push(1);<br>stack.push(2);<br>stack.top();   // returns 2<br>stack.pop();   // returns 2<br>stack.empty(); // returns false<br>Notes:</p>
<p>You must use only standard operations of a queue – which means only push to back, peek/pop from front, size, and is empty operations are valid.<br>Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.<br>You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).</p>
<h2 id="Solution-One-Two-Queues-push-O-1-pop-O-n"><a href="#Solution-One-Two-Queues-push-O-1-pop-O-n" class="headerlink" title="Solution One: Two Queues - push O(1), pop O(n)"></a>Solution One: Two Queues - push O(1), pop O(n)</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Implement Stack using Queues.<br>Memory Usage: 38.8 MB, less than 7.97% of Java online submissions for Implement Stack using Queues.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(1) for push, O(n) for pop.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayDeque&lt;Integer&gt; q1, q2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        q1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        q2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (q1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = q1.poll();</span><br><span class="line">        <span class="comment">// swap</span></span><br><span class="line">        ArrayDeque&lt;Integer&gt; tmp = q1;</span><br><span class="line">        q1 = q2;</span><br><span class="line">        q2 = tmp;</span><br><span class="line">        <span class="keyword">while</span> (q1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            q2.offer(q1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.isEmpty() &amp;&amp; q2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 226 -  Invert Binary Tree</title>
    <url>/2020/07/05/leetcode-226/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Invert a binary tree.</p>
<p>Example:</p>
<p>Input:</p>
<pre><code>4</code></pre><p>   /   <br>  2     7<br> / \   / <br>1   3 6   9<br>Output:</p>
<pre><code>4</code></pre><p>   /   <br>  7     2<br> / \   / <br>9   6 3   1<br>Trivia:<br>This problem was inspired by this original tweet by Max Howell:</p>
<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
<h2 id="Solution-One-Recursive"><a href="#Solution-One-Recursive" class="headerlink" title="Solution One: Recursive"></a>Solution One: Recursive</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Invert Binary Tree.<br>Memory Usage: 36.8 MB, less than 73.66% of Java online submissions for Invert Binary Tree.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode left = root.left, right = root.right;</span><br><span class="line">        root.left = invertTree(right);</span><br><span class="line">        root.right = invertTree(left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 228 - Summary Ranges</title>
    <url>/2020/07/05/leetcode-228/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a sorted integer array without duplicates, return the summary of its ranges.</p>
<p>Example 1:</p>
<p>Input:  [0,1,2,4,5,7]<br>Output: [“0-&gt;2”,”4-&gt;5”,”7”]<br>Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.<br>Example 2:</p>
<p>Input:  [0,2,3,4,6,8,9]<br>Output: [“0”,”2-&gt;4”,”6”,”8-&gt;9”]<br>Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 13 ms, faster than 8.74% of Java online submissions for Summary Ranges.<br>Memory Usage: 39.3 MB, less than 12.83% of Java online submissions for Summary Ranges.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> start = nums[<span class="number">0</span>], end = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == end + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// extend range</span></span><br><span class="line">                end++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; end + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// add to ans</span></span><br><span class="line">                <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                    ans.add(String.valueOf(start));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.add(String.valueOf(start) + <span class="string">"-&gt;"</span> + String.valueOf(end));</span><br><span class="line">                &#125;</span><br><span class="line">                start = nums[i];</span><br><span class="line">                end = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// skip duplicates</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add last range</span></span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            ans.add(String.valueOf(start));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.add(String.valueOf(start) + <span class="string">"-&gt;"</span> + String.valueOf(end));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// More Elegant one</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">summaryRanges</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; summary = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; nums.length; ++j) &#123;</span><br><span class="line">            <span class="comment">// check if j + 1 extends the range [nums[i], nums[j]]</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[j + <span class="number">1</span>] == nums[j] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// put the range [nums[i], nums[j]] into the list</span></span><br><span class="line">            <span class="keyword">if</span> (i == j)</span><br><span class="line">                summary.add(nums[i] + <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                summary.add(nums[i] + <span class="string">"-&gt;"</span> + nums[j]);</span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> summary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Related-Questions"><a href="#Related-Questions" class="headerlink" title="Related Questions"></a>Related Questions</h2><p>Missing Ranges</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 230 - Kth Smallest Element in a BST</title>
    <url>/2020/07/05/leetcode-230/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</p>
<p>Example 1:</p>
<p>Input: root = [3,1,4,null,2], k = 1<br>   3<br>  / <br> 1   4<br>  <br>   2<br>Output: 1<br>Example 2:</p>
<p>Input: root = [5,3,6,2,4,null,null,1], k = 3<br>       5<br>      / <br>     3   6<br>    / <br>   2   4<br>  /<br> 1<br>Output: 3<br>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p>Constraints:</p>
<p>The number of elements of the BST is between 1 to 10^4.<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<h2 id="Solution-One-Iteration"><a href="#Solution-One-Iteration" class="headerlink" title="Solution One: Iteration"></a>Solution One: Iteration</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 22.41% of Java online submissions for Kth Smallest Element in a BST.<br>Memory Usage: 43 MB, less than 10.09% of Java online submissions for Kth Smallest Element in a BST.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(H + K).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// inorder traverse</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            node = queue.pop();</span><br><span class="line">            <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> node.val;</span><br><span class="line">            TreeNode tmp = node.right;</span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.push(tmp);</span><br><span class="line">                tmp = tmp.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="More-Elegant-One"><a href="#More-Elegant-One" class="headerlink" title="More Elegant One"></a>More Elegant One</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      &#125;</span><br><span class="line">      root = stack.removeLast();</span><br><span class="line">      <span class="keyword">if</span> (--k == <span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">      root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 243 - Shortest Word Distance (series)</title>
    <url>/2020/07/06/leetcode-243/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>Example:<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p>
<p>Input: word1 = “coding”, word2 = “practice”<br>Output: 3<br>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p>
<h2 id="Solution-One-One-pass"><a href="#Solution-One-One-pass" class="headerlink" title="Solution One: One pass"></a>Solution One: One pass</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.77% of Java online submissions for Shortest Word Distance.<br>Memory Usage: 41.7 MB, less than 18.78% of Java online submissions for Shortest Word Distance.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = -<span class="number">1</span>, i2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = words.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i].equals(word1)) &#123;</span><br><span class="line">                i1 = i;</span><br><span class="line">                <span class="keyword">if</span> (i2 &gt;= <span class="number">0</span>) ans = Math.min(ans, i1 - i2);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[i].equals(word2)) &#123;</span><br><span class="line">                i2 = i;</span><br><span class="line">                <span class="keyword">if</span> (i1 &gt;= <span class="number">0</span>) ans = Math.min(ans, i2 - i1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-244-Shortest-Word-Distance-II"><a href="#Leetcode-244-Shortest-Word-Distance-II" class="headerlink" title="Leetcode 244 - Shortest Word Distance II"></a>Leetcode 244 - Shortest Word Distance II</h1><p><strong>Description</strong><br>Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list. Your method will be called repeatedly many times with different parameters. </p>
<p>Example:<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p>
<p>Input: word1 = “coding”, word2 = “practice”<br>Output: 3<br>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Note:<br>You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.</p>
<h2 id="Solution-One-HashMap"><a href="#Solution-One-HashMap" class="headerlink" title="Solution One: HashMap"></a>Solution One: HashMap</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 57 ms, faster than 10.81% of Java online submissions for Shortest Word Distance II.<br>Memory Usage: 57.1 MB, less than 15.73% of Java online submissions for Shortest Word Distance II.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(frequency of target words).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDistance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; indexMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordDistance</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = indexMap.getOrDefault(words[i], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list.add(i);</span><br><span class="line">            indexMap.put(words[i], list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortest</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = indexMap.get(word1);</span><br><span class="line">        List&lt;Integer&gt; list2 = indexMap.get(word2);</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">0</span>, i2 = <span class="number">0</span>, ans = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (i1 &lt; list1.size() &amp;&amp; i2 &lt; list2.size()) &#123;</span><br><span class="line">            ans = Math.min(ans, Math.abs(list1.get(i1) - list2.get(i2)));</span><br><span class="line">            <span class="keyword">if</span> (list1.get(i1) &lt; list2.get(i2)) i1++;</span><br><span class="line">            <span class="keyword">else</span> i2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDistance object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDistance obj = new WordDistance(words);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.shortest(word1,word2);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-245-Shortest-Word-Distance-III"><a href="#Leetcode-245-Shortest-Word-Distance-III" class="headerlink" title="Leetcode 245 - Shortest Word Distance III"></a>Leetcode 245 - Shortest Word Distance III</h1><p><strong>Description</strong><br>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>word1 and word2 may be the same and they represent two individual words in the list.</p>
<p>Example:<br>Assume that words = [“practice”, “makes”, “perfect”, “coding”, “makes”].</p>
<p>Input: word1 = “makes”, word2 = “coding”<br>Output: 1<br>Input: word1 = “makes”, word2 = “makes”<br>Output: 3<br>Note:<br>You may assume word1 and word2 are both in the list.</p>
<h2 id="Solution-One-One-pass-1"><a href="#Solution-One-One-pass-1" class="headerlink" title="Solution One: One pass"></a>Solution One: One pass</h2><!-- more -->

<h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 99.81% of Java online submissions for Shortest Word Distance III.<br>Memory Usage: 39.5 MB, less than 86.00% of Java online submissions for Shortest Word Distance III.</p>
<h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code-2"><a href="#Java-code-2" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestWordDistance</span><span class="params">(String[] words, String word1, String word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = -<span class="number">1</span>, i2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = words.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> equal1 = words[i].equals(word1);</span><br><span class="line">            <span class="keyword">boolean</span> equal2 = words[i].equals(word2);</span><br><span class="line">            <span class="keyword">if</span> (equal1 || equal2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.equals(word2)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i1 &lt;= i2) i1 = i;</span><br><span class="line">                    <span class="keyword">else</span> i2 = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (equal1) &#123;</span><br><span class="line">                    i1 = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i2 = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// update ans</span></span><br><span class="line">                <span class="keyword">if</span> (i1 != -<span class="number">1</span> &amp;&amp; i2 != -<span class="number">1</span>)</span><br><span class="line">                    ans = Math.min(ans, Math.abs(i1 - i2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 249 - Group Shifted Strings</title>
    <url>/2020/07/06/leetcode-249/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string, we can “shift” each of its letter to its successive letter, for example: “abc” -&gt; “bcd”. We can keep “shifting” which forms the sequence:</p>
<p>“abc” -&gt; “bcd” -&gt; … -&gt; “xyz”<br>Given a list of non-empty strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.</p>
<p>Example:</p>
<p>Input: [“abc”, “bcd”, “acef”, “xyz”, “az”, “ba”, “a”, “z”],<br>Output:<br>[<br>  [“abc”,”bcd”,”xyz”],<br>  [“az”,”ba”],<br>  [“acef”],<br>  [“a”,”z”]<br>]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 71.97% of Java online submissions for Group Shifted Strings.<br>Memory Usage: 40.5 MB, less than 20.87% of Java online submissions for Group Shifted Strings.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N * Length).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupStrings(String[] strings) &#123;</span><br><span class="line">        <span class="comment">// &lt;final string, groups&gt;</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; groupMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s: strings) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">            <span class="keyword">int</span> diff = <span class="string">'z'</span> - arr[<span class="number">0</span>]; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)  &#123;</span><br><span class="line">                arr[i] = (<span class="keyword">char</span>)(arr[i] + diff);</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; <span class="string">'z'</span>)</span><br><span class="line">                    arr[i] = (<span class="keyword">char</span>)(arr[i] - <span class="string">'z'</span> + <span class="string">'a'</span> - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String finalS = <span class="keyword">new</span> String(arr);</span><br><span class="line">            <span class="comment">// add to groups</span></span><br><span class="line">            List&lt;String&gt; list = groupMap.getOrDefault(finalS, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list.add(s);</span><br><span class="line">            groupMap.put(finalS, list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// convert map to list</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String key : groupMap.keySet()) &#123;</span><br><span class="line">            ans.add(groupMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 254 - Factor Combinations</title>
    <url>/2020/07/06/leetcode-254/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Numbers can be regarded as product of its factors. For example,</p>
<p>8 = 2 x 2 x 2;<br>  = 2 x 4.<br>Write a function that takes an integer n and return all possible combinations of its factors.</p>
<p>Note:</p>
<p>You may assume that n is always positive.<br>Factors should be greater than 1 and less than n.<br>Example 1:</p>
<p>Input: 1<br>Output: []<br>Example 2:</p>
<p>Input: 37<br>Output:[]<br>Example 3:</p>
<p>Input: 12<br>Output:<br>[<br>  [2, 6],<br>  [2, 2, 3],<br>  [3, 4]<br>]<br>Example 4:</p>
<p>Input: 32<br>Output:<br>[<br>  [2, 16],<br>  [2, 2, 8],<br>  [2, 2, 2, 4],<br>  [2, 2, 2, 2, 2],<br>  [2, 4, 4],<br>  [4, 8]<br>]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 69.14% of Java online submissions for Factor Combinations.<br>Memory Usage: 38.9 MB, less than 12.38% of Java online submissions for Factor Combinations.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(number of prime factors ^ 2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getFactors(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = backtrack(n, <span class="number">2</span>);</span><br><span class="line">        ans.remove(ans.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; backtrack(<span class="keyword">int</span> n, <span class="keyword">int</span> start) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> end = (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> next = n / i;</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; nextList = backtrack(next, i);</span><br><span class="line">                <span class="keyword">for</span> (List&lt;Integer&gt; list : nextList) &#123;</span><br><span class="line">                    List&lt;Integer&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    cur.add(i);</span><br><span class="line">                    cur.addAll(list);</span><br><span class="line">                    ans.add(cur);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add n</span></span><br><span class="line">        List&lt;Integer&gt; last = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        last.add(n);</span><br><span class="line">        ans.add(last);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 256 - Paint House</title>
    <url>/2020/07/07/leetcode-256/</url>
    <content><![CDATA[<p><strong>Description</strong><br>There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p>
<p>The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.</p>
<p>Note:<br>All costs are positive integers.</p>
<p>Example:</p>
<p>Input: [[17,2,17],[16,16,5],[14,3,19]]<br>Output: 10<br>Explanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.<br>             Minimum cost: 2 + 5 + 3 = 10.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 64.03% of Java online submissions for Paint House.<br>Memory Usage: 41.1 MB, less than 5.08% of Java online submissions for Paint House.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (costs == <span class="keyword">null</span> || costs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][0] = min(dp[i+1][1], dp[i+1][2]) + costs[i][0]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = costs.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            costs[i][<span class="number">0</span>] += Math.min(costs[i + <span class="number">1</span>][<span class="number">1</span>], costs[i + <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            costs[i][<span class="number">1</span>] += Math.min(costs[i + <span class="number">1</span>][<span class="number">0</span>], costs[i + <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            costs[i][<span class="number">2</span>] += Math.min(costs[i + <span class="number">1</span>][<span class="number">0</span>], costs[i + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(costs[<span class="number">0</span>][<span class="number">0</span>], Math.min(costs[<span class="number">0</span>][<span class="number">1</span>], costs[<span class="number">0</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programmming</tag>
        <tag>Premium</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 257 - Binary Tree Paths</title>
    <url>/2020/07/06/leetcode-257/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, return all root-to-leaf paths.</p>
<p>Note: A leaf is a node with no children.</p>
<p>Example:</p>
<p>Input:</p>
<p>   1<br> /   <br>2     3<br> <br>  5</p>
<p>Output: [“1-&gt;2-&gt;5”, “1-&gt;3”]</p>
<p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</p>
<h2 id="Solution-One-Preorder-DFS"><a href="#Solution-One-Preorder-DFS" class="headerlink" title="Solution One: Preorder DFS"></a>Solution One: Preorder DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 67.54% of Java online submissions for Binary Tree Paths.<br>Memory Usage: 39.8 MB, less than 37.17% of Java online submissions for Binary Tree Paths.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        backtrack(root, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode node, LinkedList&lt;String&gt; path)</span> </span>&#123;</span><br><span class="line">        path.add(String.valueOf(node.val));</span><br><span class="line">        TreeNode left = node.left, right = node.right;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ans.add(String.join(<span class="string">"-&gt;"</span>, path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span>) backtrack(node.left, path);</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="keyword">null</span>) backtrack(node.right, path);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Not a backtracking solution…</p>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 261 - Graph Valid Tree</title>
    <url>/2020/07/07/leetcode-261/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p>
<p>Example 1:</p>
<p>Input: n = 5, and edges = [[0,1], [0,2], [0,3], [1,4]]<br>Output: true<br>Example 2:</p>
<p>Input: n = 5, and edges = [[0,1], [1,2], [2,3], [1,3], [1,4]]<br>Output: false<br>Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0,1] is the same as [1,0] and thus will not appear together in edges.</p>
<h2 id="Solution-One-BFS"><a href="#Solution-One-BFS" class="headerlink" title="Solution One: BFS"></a>Solution One: BFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 96 ms, faster than 39.36% of Java online submissions for Sliding Window Median.<br>Memory Usage: 42.6 MB, less than 18.65% of Java online submissions for Sliding Window Median.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; leftQ = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1, Integer i2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i2.compareTo(i1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; rightQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// add to priorityQueue</span></span><br><span class="line">            <span class="keyword">if</span> (leftQ.isEmpty() || nums[i] &lt;= leftQ.peek()) </span><br><span class="line">                leftQ.add(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> rightQ.add(nums[i]);</span><br><span class="line">            <span class="comment">// adjust num</span></span><br><span class="line">            adjustPQ(leftQ, rightQ);</span><br><span class="line">            <span class="comment">// System.out.println("1: " + leftQ + ", 2: " + rightQ);</span></span><br><span class="line">            <span class="comment">// check median</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> start = i - k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) ans[start] = (<span class="keyword">double</span>)leftQ.peek() / <span class="number">2f</span> + (<span class="keyword">double</span>)rightQ.peek() / <span class="number">2f</span>;</span><br><span class="line">                <span class="keyword">else</span> ans[start] = (<span class="keyword">double</span>)leftQ.peek();</span><br><span class="line">                <span class="comment">// slide window</span></span><br><span class="line">                <span class="keyword">if</span> (nums[start] &lt;= leftQ.peek()) leftQ.remove(nums[start]);</span><br><span class="line">                <span class="keyword">else</span> rightQ.remove(nums[start]);</span><br><span class="line">                adjustPQ(leftQ, rightQ);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustPQ</span><span class="params">(PriorityQueue&lt;Integer&gt; leftQ, PriorityQueue&lt;Integer&gt; rightQ)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (rightQ.size() &gt; leftQ.size()) leftQ.add(rightQ.poll());</span><br><span class="line">        <span class="keyword">while</span> (leftQ.size() - rightQ.size() &gt; <span class="number">1</span>) rightQ.add(leftQ.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-One-DFS"><a href="#Solution-One-DFS" class="headerlink" title="Solution One: DFS"></a>Solution One: DFS</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 263 - Ugly Number</title>
    <url>/2020/07/07/leetcode-263/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Write a program to check whether a given number is an ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.</p>
<p>Example 1:</p>
<p>Input: 6<br>Output: true<br>Explanation: 6 = 2 × 3<br>Example 2:</p>
<p>Input: 8<br>Output: true<br>Explanation: 8 = 2 × 2 × 2<br>Example 3:</p>
<p>Input: 14<br>Output: false<br>Explanation: 14 is not ugly since it includes another prime factor 7.<br>Note:</p>
<p>1 is typically treated as an ugly number.<br>Input is within the 32-bit signed integer range: [−231,  231 − 1].</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 34.40% of Java online submissions for Ugly Number.<br>Memory Usage: 36.6 MB, less than 70.99% of Java online submissions for Ugly Number.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUgly</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">2</span> == <span class="number">0</span>) num /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">3</span> == <span class="number">0</span>) num /= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span> (num % <span class="number">5</span> == <span class="number">0</span>) num /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-264-Ugly-Number-II"><a href="#Leetcode-264-Ugly-Number-II" class="headerlink" title="Leetcode 264 - Ugly Number II"></a>Leetcode 264 - Ugly Number II</h1><p><strong>Description</strong><br>Write a program to find the n-th ugly number.</p>
<p>Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. </p>
<p>Example:</p>
<p>Input: n = 10<br>Output: 12<br>Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.<br>Note:  </p>
<p>1 is typically treated as an ugly number.<br>n does not exceed 1690.</p>
<h2 id="Solution-One-1"><a href="#Solution-One-1" class="headerlink" title="Solution One"></a>Solution One</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 6 ms, faster than 52.07% of Java online submissions for Ugly Number II.<br>Memory Usage: 38.4 MB, less than 60.42% of Java online submissions for Ugly Number II.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(1).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ugly</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1690</span>];</span><br><span class="line">  Ugly() &#123;</span><br><span class="line">    HashSet&lt;Long&gt; seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">    PriorityQueue&lt;Long&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Long&gt;();</span><br><span class="line">    seen.add(<span class="number">1L</span>);</span><br><span class="line">    heap.add(<span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> currUgly, newUgly;</span><br><span class="line">    <span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1690</span>; ++i) &#123;</span><br><span class="line">      currUgly = heap.poll();</span><br><span class="line">      nums[i] = (<span class="keyword">int</span>)currUgly;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j : primes) &#123;</span><br><span class="line">        newUgly = currUgly * j;</span><br><span class="line">        <span class="keyword">if</span> (!seen.contains(newUgly)) &#123;</span><br><span class="line">          seen.add(newUgly);</span><br><span class="line">          heap.add(newUgly);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Ugly u = <span class="keyword">new</span> Ugly();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u.nums[n - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 268 -  Missing Number</title>
    <url>/2020/07/07/leetcode-268/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p>Example 1:</p>
<p>Input: [3,0,1]<br>Output: 2<br>Example 2:</p>
<p>Input: [9,6,4,2,3,5,7,0,1]<br>Output: 8<br>Note:<br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<h2 id="Solution-One-sum"><a href="#Solution-One-sum" class="headerlink" title="Solution One: sum"></a>Solution One: sum</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 50.10% of Java online submissions for Missing Number.<br>Memory Usage: 48.3 MB, less than 14.88% of Java online submissions for Missing Number.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, tarSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            tarSum += (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tarSum - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two"><a href="#Solution-Two" class="headerlink" title="Solution Two"></a>Solution Two</h2><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> missing = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            missing ^= i ^ nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Bit Operations</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 269 - Alien Dictionary</title>
    <url>/2020/07/09/leetcode-269/</url>
    <content><![CDATA[<p><strong>Description</strong><br>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p>
<p>Example 1:</p>
<p>Input:<br>[<br>  “wrt”,<br>  “wrf”,<br>  “er”,<br>  “ett”,<br>  “rftt”<br>]</p>
<p>Output: “wertf”<br>Example 2:</p>
<p>Input:<br>[<br>  “z”,<br>  “x”<br>]</p>
<p>Output: “zx”<br>Example 3:</p>
<p>Input:<br>[<br>  “z”,<br>  “x”,<br>  “z”<br>] </p>
<p>Output: “” </p>
<p>Explanation: The order is invalid, so return “”.<br>Note:</p>
<p>You may assume all letters are in lowercase.<br>If the order is invalid, return an empty string.<br>There may be multiple valid order of letters, return any one of them is fine.</p>
<h2 id="Solution-One-Topological-Sort"><a href="#Solution-One-Topological-Sort" class="headerlink" title="Solution One: Topological Sort"></a>Solution One: Topological Sort</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 15 ms, faster than 6.18% of Java online submissions for Alien Dictionary.<br>Memory Usage: 39.9 MB, less than 20.98% of Java online submissions for Alien Dictionary.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/alien-dictionary/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/alien-dictionary/solution/</a></p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Set&lt;Character&gt;&gt; graphMap;</span><br><span class="line">    Map&lt;Character, Integer&gt; indegreeMap;</span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">alienOrder</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        graphMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        indegreeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        compare(words, <span class="number">0</span>, words.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// topological sort</span></span><br><span class="line">        Set&lt;Character&gt; headSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : indegreeMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegreeMap.get(c) == <span class="number">0</span>) headSet.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (!valid) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">while</span> (!headSet.isEmpty()) &#123;</span><br><span class="line">            List&lt;Character&gt; headList = <span class="keyword">new</span> ArrayList&lt;&gt;(headSet);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> head : headList) &#123;</span><br><span class="line">                ans += String.valueOf(head);</span><br><span class="line">                Set&lt;Character&gt; nextSet = graphMap.getOrDefault(head, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> next : nextSet) &#123;</span><br><span class="line">                    <span class="keyword">int</span> indegree = indegreeMap.get(next) - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (indegree == <span class="number">0</span>) headSet.add(next);</span><br><span class="line">                    indegreeMap.put(next, indegree);</span><br><span class="line">                &#125;</span><br><span class="line">                graphMap.remove(head);</span><br><span class="line">                headSet.remove(head);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ans.length() != indegreeMap.size()) ans = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">compare</span><span class="params">(String[] words, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> curStart = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            <span class="comment">// only happens before any words appear</span></span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= words[i].length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curStart != i) valid = <span class="keyword">false</span>;</span><br><span class="line">                curStart = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c1 = words[curStart].charAt(pos);</span><br><span class="line">            <span class="keyword">char</span> c2 = words[i].charAt(pos);</span><br><span class="line">            <span class="keyword">if</span> (c2 != c1) &#123;</span><br><span class="line">                <span class="comment">// add to graph</span></span><br><span class="line">                Set&lt;Character&gt; set = graphMap.getOrDefault(c1, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">                <span class="comment">// add to indegreeMap</span></span><br><span class="line">                <span class="keyword">if</span> (!set.contains(c2)) &#123;</span><br><span class="line">                    indegreeMap.put(c2, indegreeMap.getOrDefault(c2, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    set.add(c2);</span><br><span class="line">                    graphMap.put(c1, set);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// add up pos for next round comparision</span></span><br><span class="line">                compare(words, curStart, i - <span class="number">1</span>, pos + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// update curStart</span></span><br><span class="line">                curStart = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!indegreeMap.containsKey(c1))</span><br><span class="line">                indegreeMap.put(c1, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// handle last group of words</span></span><br><span class="line">        compare(words, curStart, end, pos + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 270 - Closest Binary Search Tree Value</title>
    <url>/2020/07/09/leetcode-270/</url>
    <content><![CDATA[<p><strong>Description</strong></p>
<p>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</p>
<p>Note:</p>
<p>Given target value is a floating point.<br>You are guaranteed to have only one unique value in the BST that is closest to the target.<br>Example:</p>
<p>Input: root = [4,2,5,1,3], target = 3.714286</p>
<pre><code>4</code></pre><p>   / <br>  2   5<br> / <br>1   3</p>
<p>Output: 4</p>
<h2 id="Solution-One-DFS"><a href="#Solution-One-DFS" class="headerlink" title="Solution One: DFS"></a>Solution One: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Closest Binary Search Tree Value.<br>Memory Usage: 40.8 MB, less than 13.34% of Java online submissions for Closest Binary Search Tree Value.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(H).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> minDiff;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        minDiff = Math.abs((<span class="keyword">double</span>)root.val - target);</span><br><span class="line">        ans = root.val;</span><br><span class="line">        find(root, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">double</span> curDiff = Math.abs((<span class="keyword">double</span>)root.val - target);</span><br><span class="line">        <span class="keyword">if</span> (curDiff &lt;= minDiff) &#123;</span><br><span class="line">            minDiff = curDiff;</span><br><span class="line">            ans = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &gt; root.val) find(root.right, target);</span><br><span class="line">        <span class="keyword">if</span> (target &lt; root.val) find(root.left, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">closestValue</span><span class="params">(TreeNode root, <span class="keyword">double</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val, closest = root.val;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">      val = root.val;</span><br><span class="line">      closest = Math.abs(val - target) &lt; Math.abs(closest - target) ? val : closest;</span><br><span class="line">      root =  target &lt; root.val ? root.left : root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closest;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 271 - Encode and Decode Strings</title>
    <url>/2020/07/09/leetcode-271/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings.</p>
<p>Machine 1 (sender) has the function:</p>
<p>string encode(vector<string> strs) {<br>  // … your code<br>  return encoded_string;<br>}<br>Machine 2 (receiver) has the function:<br>vector<string> decode(string s) {<br>  //… your code<br>  return strs;<br>}<br>So Machine 1 does:</p>
<p>string encoded_string = encode(strs);<br>and Machine 2 does:</p>
<p>vector<string> strs2 = decode(encoded_string);<br>strs2 in Machine 2 should be the same as strs in Machine 1.</p>
<p>Implement the encode and decode methods.</p>
<p>Note:</p>
<p>The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters.<br>Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless.<br>Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm.</p>
<h2 id="Solution-One-Non-ASCII-Delimiter"><a href="#Solution-One-Non-ASCII-Delimiter" class="headerlink" title="Solution One: Non-ASCII Delimiter"></a>Solution One: Non-ASCII Delimiter</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(N).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Encodes a list of strings to a single string.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(List&lt;String&gt; strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs.size() == <span class="number">0</span>) <span class="keyword">return</span> Character.toString((<span class="keyword">char</span>)<span class="number">258</span>);</span><br><span class="line"></span><br><span class="line">    String d = Character.toString((<span class="keyword">char</span>)<span class="number">257</span>);</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s: strs) &#123;</span><br><span class="line">      sb.append(s);</span><br><span class="line">      sb.append(d);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decodes a single string to a list of strings.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">decode</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String d = Character.toString((<span class="keyword">char</span>)<span class="number">258</span>);</span><br><span class="line">    <span class="keyword">if</span> (s.equals(d)) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    d = Character.toString((<span class="keyword">char</span>)<span class="number">257</span>);</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(s.split(d, -<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.decode(codec.encode(strs));</span></span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Chunked-Transfer-Encoding"><a href="#Solution-Two-Chunked-Transfer-Encoding" class="headerlink" title="Solution Two: Chunked Transfer Encoding"></a>Solution Two: Chunked Transfer Encoding</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Encodes string length to bytes string</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">intToString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = s.length();</span><br><span class="line">    <span class="keyword">char</span>[] bytes = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &gt; -<span class="number">1</span>; --i) &#123;</span><br><span class="line">      bytes[<span class="number">3</span> - i] = (<span class="keyword">char</span>) (x &gt;&gt; (i * <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Encodes a list of strings to a single string.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(List&lt;String&gt; strs)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String s: strs) &#123;</span><br><span class="line">      sb.append(intToString(s));</span><br><span class="line">      sb.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decodes bytes string to integer</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stringToInt</span><span class="params">(String bytesStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> b : bytesStr.toCharArray())</span><br><span class="line">      result = (result &lt;&lt; <span class="number">8</span>) + (<span class="keyword">int</span>)b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decodes a single string to a list of strings.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">decode</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = s.length();</span><br><span class="line">    List&lt;String&gt; output = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">      <span class="keyword">int</span> length = stringToInt(s.substring(i, i + <span class="number">4</span>));</span><br><span class="line">      i += <span class="number">4</span>;</span><br><span class="line">      output.add(s.substring(i, i + length));</span><br><span class="line">      i += length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 274 - H-Index</title>
    <url>/2020/07/07/leetcode-274/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>
<p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p>
<p>Example:</p>
<p>Input: citations = [3,0,6,1,5]<br>Output: 3<br>Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had<br>             received 3, 0, 6, 1, 5 citations respectively.<br>             Since the researcher has 3 papers with at least 3 citations each and the remaining<br>             two with no more than 3 citations each, her h-index is 3.<br>Note: If there are several possible values for h, the maximum one is taken as the h-index.</p>
<h2 id="Solution-One-Heap-sort"><a href="#Solution-One-Heap-sort" class="headerlink" title="Solution One: Heap (sort)"></a>Solution One: Heap (sort)</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 5.38% of Java online submissions for H-Index.<br>Memory Usage: 39.2 MB, less than 12.20% of Java online submissions for H-Index.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(nlogn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> citation : citations) pq.add(citation);</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty() &amp;&amp; pq.peek() &lt; pq.size()) &#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-Counting"><a href="#Solution-Two-Counting" class="headerlink" title="Solution Two: Counting"></a>Solution Two: Counting</h2><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="keyword">int</span>[] citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = citations.length;</span><br><span class="line">        <span class="keyword">int</span>[] papers = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// counting papers for each citation number</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c: citations)</span><br><span class="line">            papers[Math.min(n, c)]++;</span><br><span class="line">        <span class="comment">// finding the h-index</span></span><br><span class="line">        <span class="keyword">int</span> k = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = papers[n]; k &gt; s; s += papers[k])</span><br><span class="line">            k--;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Sort</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 276 - Paint Fence</title>
    <url>/2020/07/09/leetcode-276/</url>
    <content><![CDATA[<p><strong>Description</strong><br>There is a fence with n posts, each post can be painted with one of the k colors.</p>
<p>You have to paint all the posts such that no more than two adjacent fence posts have the same color.</p>
<p>Return the total number of ways you can paint the fence.</p>
<p>Note:<br>n and k are non-negative integers.</p>
<p>Example:</p>
<p>Input: n = 3, k = 2<br>Output: 6<br>Explanation: Take c1 as color 1, c2 as color 2. All possible ways are:</p>
<pre><code>post1  post2  post3      </code></pre><hr>
<p>   1         c1     c1     c2<br>   2         c1     c2     c1<br>   3         c1     c2     c2<br>   4         c2     c1     c1<br>   5         c2     c1     c2<br>   6         c2     c2     c1</p>
<h2 id="Solution-One-Dynamic-Programming"><a href="#Solution-One-Dynamic-Programming" class="headerlink" title="Solution One: Dynamic Programming"></a>Solution One: Dynamic Programming</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Paint Fence.<br>Memory Usage: 37.8 MB, less than 16.71% of Java online submissions for Paint Fence.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0: different from previous one</span></span><br><span class="line">        <span class="comment">// 1: two same</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (k - <span class="number">1</span>) * (dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">0</span>] + dp[n][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 277 - Find the Celebrity</title>
    <url>/2020/07/09/leetcode-277/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.</p>
<p>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: “Hi, A. Do you know B?” to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).</p>
<p>You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n). There will be exactly one celebrity if he/she is in the party. Return the celebrity’s label if there is a celebrity in the party. If there is no celebrity, return -1.</p>
<h2 id="Solution-One-Brute-Force"><a href="#Solution-One-Brute-Force" class="headerlink" title="Solution One: Brute Force"></a>Solution One: Brute Force</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1155 ms, faster than 5.01% of Java online submissions for Find the Celebrity.<br>Memory Usage: 51.5 MB, less than 19.19% of Java online submissions for Find the Celebrity.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The knows API is defined in the parent class Relation.</span></span><br><span class="line"><span class="comment">      boolean knows(int a, int b); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Relation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; knowMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; knownMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; candidates = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            knowMap.put(i, <span class="number">0</span>);</span><br><span class="line">            knownMap.put(i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != j &amp;&amp; knows(i, j)) &#123;</span><br><span class="line">                    knowMap.put(i, knowMap.get(i) + <span class="number">1</span>);</span><br><span class="line">                    knownMap.put(j, knownMap.get(j) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (knowMap.get(i) == <span class="number">0</span> &amp;&amp; knownMap.get(i) == n - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Logical-Deduction"><a href="#Solution-Two-Logical-Deduction" class="headerlink" title="Solution Two: Logical Deduction"></a>Solution Two: Logical Deduction</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Relation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfPeople;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCelebrity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        numberOfPeople = n;</span><br><span class="line">        <span class="keyword">int</span> celebrityCandidate = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (knows(celebrityCandidate, i)) &#123;</span><br><span class="line">                celebrityCandidate = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isCelebrity(celebrityCandidate)) &#123;</span><br><span class="line">            <span class="keyword">return</span> celebrityCandidate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCelebrity</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; numberOfPeople; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>; <span class="comment">// Don't ask if they know themselves.</span></span><br><span class="line">            <span class="keyword">if</span> (knows(i, j) || !knows(j, i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 278 - First Bad Version</title>
    <url>/2020/07/08/leetcode-278/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
<p>Example:</p>
<p>Given n = 5, and version = 4 is the first bad version.</p>
<p>call isBadVersion(3) -&gt; false<br>call isBadVersion(5) -&gt; true<br>call isBadVersion(4) -&gt; true</p>
<p>Then 4 is the first bad version. </p>
<h2 id="Solution-One-Binary-Search"><a href="#Solution-One-Binary-Search" class="headerlink" title="Solution One: Binary Search"></a>Solution One: Binary Search</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 35 ms, faster than 5.16% of Java online submissions for First Bad Version.<br>Memory Usage: 38.1 MB, less than 7.67% of Java online submissions for First Bad Version.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>, end = n;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) end = mid;</span><br><span class="line">            <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 279 - Perfect Squares</title>
    <url>/2020/07/08/leetcode-279/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, …) which sum to n.</p>
<p>Example 1:</p>
<p>Input: n = 12<br>Output: 3<br>Explanation: 12 = 4 + 4 + 4.<br>Example 2:</p>
<p>Input: n = 13<br>Output: 2<br>Explanation: 13 = 4 + 9.</p>
<h2 id="Solution-One-DFS-Memorization"><a href="#Solution-One-DFS-Memorization" class="headerlink" title="Solution One: DFS + Memorization"></a>Solution One: DFS + Memorization</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 142 ms, faster than 21.86% of Java online submissions for Perfect Squares.<br>Memory Usage: 41.5 MB, less than 15.97% of Java online submissions for Perfect Squares.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(NK).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] memo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build array</span></span><br><span class="line">        <span class="keyword">int</span> totalNum = (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[totalNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totalNum; i++) &#123;</span><br><span class="line">            nums[i - <span class="number">1</span>] = i * i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(nums, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// scan nums from right to left</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[n] &gt;= <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &lt; nums[i]) <span class="keyword">break</span>;</span><br><span class="line">                count = Math.min(count, dfs(nums, n - nums[i]) + <span class="number">1</span>);        </span><br><span class="line">        &#125;</span><br><span class="line">        memo[n] = count;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Dynamic-Programming"><a href="#Solution-Two-Dynamic-Programming" class="headerlink" title="Solution Two: Dynamic Programming"></a>Solution Two: Dynamic Programming</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 53 ms, faster than 42.37% of Java online submissions for Perfect Squares.<br>Memory Usage: 40.9 MB, less than 18.25% of Java online submissions for Perfect Squares.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N), Time Complexity: O(NK).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build array</span></span><br><span class="line">        <span class="keyword">int</span> totalNum = (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[totalNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totalNum; i++) &#123;</span><br><span class="line">            nums[i - <span class="number">1</span>] = i * i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// DP</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, n);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; i) <span class="keyword">break</span>;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - num] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Three-Greedy"><a href="#Solution-Three-Greedy" class="headerlink" title="Solution Three: Greedy"></a>Solution Three: Greedy</h2><h3 id="Result-2"><a href="#Result-2" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 22 ms, faster than 87.53% of Java online submissions for Perfect Squares.<br>Memory Usage: 42.3 MB, less than 15.30% of Java online submissions for Perfect Squares.</p>
<h3 id="Analysis-2"><a href="#Analysis-2" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="https://leetcode.com/problems/perfect-squares/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/perfect-squares/solution/</a></p>
<h3 id="Java-code-2"><a href="#Java-code-2" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build set</span></span><br><span class="line">        set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> totalNum = (<span class="keyword">int</span>)Math.sqrt(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totalNum; i++) &#123;</span><br><span class="line">            set.add(i * i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Greedy</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDivisible(n, i)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDivisible</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) <span class="keyword">return</span> set.contains(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isDivisible(n - num, count - <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Greedy</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Dynamic Programming</tag>
        <tag>Memorization</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 284 - Peeking Iterator</title>
    <url>/2020/07/09/leetcode-284/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation – it essentially peek() at the element that will be returned by the next call to next().</p>
<p>Example:</p>
<p>Assume that the iterator is initialized to the beginning of the list: [1,2,3].</p>
<p>Call next() gets you 1, the first element in the list.<br>Now you call peek() and it returns 2, the next element. Calling next() after that still return 2.<br>You call next() the final time and it returns 3, the last element.<br>Calling hasNext() after that should return false.<br>Follow up: How would you extend your design to be generic and work with all types, not just integer?</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 11 ms, faster than 5.92% of Java online submissions for Peeking Iterator.<br>Memory Usage: 40.4 MB, less than 5.06% of Java online submissions for Peeking Iterator.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(1).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java Iterator interface reference:</span></span><br><span class="line"><span class="comment">// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer next;</span><br><span class="line">    <span class="keyword">private</span> Iterator&lt;Integer&gt; originalIterator;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PeekingIterator</span><span class="params">(Iterator&lt;Integer&gt; iterator)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// initialize any member here.</span></span><br><span class="line">        originalIterator = iterator;</span><br><span class="line">        <span class="keyword">if</span> (originalIterator.hasNext()) next = originalIterator.next();</span><br><span class="line">        <span class="keyword">else</span> next = <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">	<span class="comment">// Override them if needed.</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (!hasNext()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Integer cur = next;</span><br><span class="line">        next = originalIterator.hasNext() ? originalIterator.next() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 280 - Wiggle Sort</title>
    <url>/2020/07/09/leetcode-280/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an unsorted array nums, reorder it in-place such that nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]….</p>
<p>Example:</p>
<p>Input: nums = [3,5,2,1,6,4]<br>Output: One possible answer is [3,5,1,6,2,4]</p>
<h2 id="Solution-One-Selection-Sort"><a href="#Solution-One-Selection-Sort" class="headerlink" title="Solution One: Selection Sort"></a>Solution One: Selection Sort</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 324 ms, faster than 8.25% of Java online submissions for Wiggle Sort.<br>Memory Usage: 46.4 MB, less than 14.28% of Java online submissions for Wiggle Sort.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n^2).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = nums[i], index = i;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// find min</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                        index = j;</span><br><span class="line">                        val = nums[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// find max</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                        index = j;</span><br><span class="line">                        val = nums[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// swap</span></span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">            nums[i] = nums[index];</span><br><span class="line">            nums[index] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Solution-Two-One-pass-swap"><a href="#Solution-Two-One-pass-swap" class="headerlink" title="Solution Two: One pass swap"></a>Solution Two: One pass swap</h2><!-- more -->

<h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 52.72% of Java online submissions for Wiggle Sort.<br>Memory Usage: 47 MB, less than 5.13% of Java online submissions for Wiggle Sort.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wiggleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> less = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (less) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, i, i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, i, i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            less = !less;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Google</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 285 -  Inorder Successor in BST</title>
    <url>/2020/07/10/leetcode-285/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</p>
<p>The successor of a node p is the node with the smallest key greater than p.val.</p>
<h2 id="Solution-One-Iterative-Inorder-Traversal"><a href="#Solution-One-Iterative-Inorder-Traversal" class="headerlink" title="Solution One: Iterative Inorder Traversal"></a>Solution One: Iterative Inorder Traversal</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 5 ms, faster than 12.60% of Java online submissions for Inorder Successor in BST.<br>Memory Usage: 46.4 MB, less than 11.08% of Java online submissions for Inorder Successor in BST.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(Hp).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// the successor is somewhere lower in the right subtree</span></span><br><span class="line">        <span class="comment">// successor: one step right and then left till you can</span></span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">          p = p.right;</span><br><span class="line">          <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) p = p.left;</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> foundP = <span class="keyword">false</span>;</span><br><span class="line">        ArrayDeque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (foundP) <span class="keyword">return</span> node;</span><br><span class="line">            <span class="keyword">if</span> (node.val == p.val) foundP = <span class="keyword">true</span>;</span><br><span class="line">            root = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Stack</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 286 - Walls and Gates</title>
    <url>/2020/07/10/leetcode-286/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are given a m x n 2D grid initialized with these three possible values.</p>
<p>-1 - A wall or an obstacle.<br>0 - A gate.<br>INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.<br>Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.</p>
<p>Example: </p>
<p>Given the 2D grid:</p>
<p>INF  -1  0  INF<br>INF INF INF  -1<br>INF  -1 INF  -1<br>  0  -1 INF INF<br>After running your function, the 2D grid should be:</p>
<p>  3  -1   0   1<br>  2   2   1  -1<br>  1  -1   2  -1<br>  0  -1   3   4</p>
<h2 id="Solution-One-DFS"><a href="#Solution-One-DFS" class="headerlink" title="Solution One: DFS"></a>Solution One: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 245 ms, faster than 21.38% of Java online submissions.<br>Memory Usage: 40.3 MB, less than 100.00% of Java online submissions.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(mn), Time Complexity: O(mn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wallsAndGates</span><span class="params">(<span class="keyword">int</span>[][] rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rooms == <span class="keyword">null</span> || rooms.length == <span class="number">0</span> || rooms[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        m = rooms.length;</span><br><span class="line">        n = rooms[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rooms[i][j] == <span class="number">0</span>) dfs(rooms, i, j, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] rooms, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;= n || rooms[i][j] &lt; d)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        rooms[i][j] = d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">            dfs(rooms, i + direction[<span class="number">0</span>], j + direction[<span class="number">1</span>], d + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-BFS"><a href="#Solution-Two-BFS" class="headerlink" title="Solution Two: BFS"></a>Solution Two: BFS</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 287 - Find the Duplicate Number</title>
    <url>/2020/07/10/leetcode-287/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Example 1:</p>
<p>Input: [1,3,4,2,2]<br>Output: 2<br>Example 2:</p>
<p>Input: [3,1,3,4,2]<br>Output: 3<br>Note:</p>
<p>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p>
<h2 id="Solution-One-One-Pass"><a href="#Solution-One-One-Pass" class="headerlink" title="Solution One: One Pass"></a>Solution One: One Pass</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 65.49% of Java online submissions for Find the Duplicate Number.<br>Memory Usage: 41.7 MB, less than 12.38% of Java online submissions for Find the Duplicate Number.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[cur] &lt; <span class="number">0</span>) <span class="keyword">return</span> cur;</span><br><span class="line">            nums[cur] = -nums[cur];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 288 - Unique Word Abbreviation</title>
    <url>/2020/07/10/leetcode-288/</url>
    <content><![CDATA[<p><strong>Description</strong><br>An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:</p>
<p>a) it                      –&gt; it    (no abbreviation)</p>
<pre><code>1
↓</code></pre><p>b) d|o|g                   –&gt; d1g</p>
<pre><code>         1    1  1
1---5----0----5--8
↓   ↓    ↓    ↓  ↓    </code></pre><p>c) i|nternationalizatio|n  –&gt; i18n</p>
<pre><code>         1
1---5----0
↓   ↓    ↓</code></pre><p>d) l|ocalizatio|n          –&gt; l10n</p>
<p>Additionally for any string s of size less than or equal to 2 their abbreviation is the same string s.<br>Find whether its abbreviation is unique in the dictionary. A word’s abbreviation is called unique if any of the following conditions is met:</p>
<p>There is no word in dictionary such that their abbreviation is equal to the abbreviation of word.<br>Else, for all words in dictionary such that their abbreviation is equal to the abbreviation of word those words are equal to word.</p>
<p>Example 1:</p>
<p>Input<br>[“ValidWordAbbr”,”isUnique”,”isUnique”,”isUnique”,”isUnique”]<br>[[[“deer”,”door”,”cake”,”card”]],[“dear”],[“cart”],[“cane”],[“make”]]<br>Output<br>[null,false,true,false,true]</p>
<p>Explanation<br>ValidWordAbbr validWordAbbr = new ValidWordAbbr([“deer”, “door”, “cake”, “card”]);<br>validWordAbbr.isUnique(“dear”); // return False<br>validWordAbbr.isUnique(“cart”); // return True<br>validWordAbbr.isUnique(“cane”); // return False<br>validWordAbbr.isUnique(“make”); // return True</p>
<p>Constraints:</p>
<p>Each word will only consist of lowercase English characters.</p>
<h2 id="Solution-One-Two-HashMap"><a href="#Solution-One-Two-HashMap" class="headerlink" title="Solution One: Two HashMap"></a>Solution One: Two HashMap</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 161 ms, faster than 11.28% of Java online submissions for Unique Word Abbreviation.<br>Memory Usage: 79.2 MB, less than 5.23% of Java online submissions for Unique Word Abbreviation.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(1).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidWordAbbr</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;word, abbr&gt;</span></span><br><span class="line">    Map&lt;String, String&gt; wordMap = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">    <span class="comment">// &lt;abbr, word&gt;</span></span><br><span class="line">    Map&lt;String, Set&lt;String&gt;&gt; abbrMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidWordAbbr</span><span class="params">(String[] dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : dictionary) &#123;</span><br><span class="line">            String abbr = getAbbr(word);</span><br><span class="line">            wordMap.put(word, abbr);</span><br><span class="line">            </span><br><span class="line">            Set&lt;String&gt; set = abbrMap.getOrDefault(abbr, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            set.add(word);</span><br><span class="line">            abbrMap.put(abbr, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (wordMap.containsKey(word)) &#123;</span><br><span class="line">            <span class="keyword">return</span> abbrMap.get(wordMap.get(word)).size() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String abbr = getAbbr(word);</span><br><span class="line">        <span class="keyword">return</span> !abbrMap.containsKey(abbr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getAbbr</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word.length() &lt;= <span class="number">2</span>) <span class="keyword">return</span> word;</span><br><span class="line">        <span class="keyword">int</span> len = word.length();</span><br><span class="line">        <span class="keyword">return</span> word.charAt(<span class="number">0</span>) + String.valueOf(len - <span class="number">2</span>) </span><br><span class="line">            + word.charAt(len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ValidWordAbbr object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ValidWordAbbr obj = new ValidWordAbbr(dictionary);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.isUnique(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Save some space</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidWordAbbr</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Boolean&gt; abbrDict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; dict;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ValidWordAbbr</span><span class="params">(String[] dictionary)</span> </span>&#123;</span><br><span class="line">        dict = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(dictionary));</span><br><span class="line">        <span class="keyword">for</span> (String s : dict) &#123;</span><br><span class="line">            String abbr = toAbbr(s);</span><br><span class="line">            abbrDict.put(abbr, !abbrDict.containsKey(abbr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        String abbr = toAbbr(word);</span><br><span class="line">        Boolean hasAbbr = abbrDict.get(abbr);</span><br><span class="line">        <span class="keyword">return</span> hasAbbr == <span class="keyword">null</span> || (hasAbbr &amp;&amp; dict.contains(word));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">toAbbr</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.charAt(<span class="number">0</span>) + Integer.toString(n - <span class="number">2</span>) + s.charAt(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>String</tag>
        <tag>Premium</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 296 - Best Meeting Point</title>
    <url>/2020/07/12/leetcode-296/</url>
    <content><![CDATA[<p><strong>Description</strong><br>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.</p>
<p>Example:</p>
<p>Input: </p>
<p>1 - 0 - 0 - 0 - 1<br>|   |   |   |   |<br>0 - 0 - 0 - 0 - 0<br>|   |   |   |   |<br>0 - 0 - 1 - 0 - 0</p>
<p>Output: 6 </p>
<p>Explanation: Given three people living at (0,0), (0,4), and (2,2):<br>             The point (0,2) is an ideal meeting point, as the total travel distance<br>             of 2+2+2=6 is minimal. So return 6.</p>
<h2 id="Solution-One-Sorting"><a href="#Solution-One-Sorting" class="headerlink" title="Solution One: Sorting"></a>Solution One: Sorting</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 14 ms, faster than 19.92% of Java online submissions for Best Meeting Point.<br>Memory Usage: 41.6 MB, less than 9.49% of Java online submissions for Best Meeting Point.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(mn), Time Complexity: O(mnlogmn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rows = grid.length, cols = grid[<span class="number">0</span>].length;</span><br><span class="line">        List&lt;Integer&gt; rowList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; colList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    rowList.add(i);</span><br><span class="line">                    colList.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(rowList);</span><br><span class="line">        Collections.sort(colList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find row index and col index</span></span><br><span class="line">        <span class="keyword">int</span> size = rowList.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> px = rowList.get(size / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> py = colList.get(size / <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// calculate distances</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            ans += Math.abs(rowList.get(i) - px) </span><br><span class="line">                + Math.abs(colList.get(i) - py);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Collect-Coordinates-in-Sorted-Order"><a href="#Solution-Two-Collect-Coordinates-in-Sorted-Order" class="headerlink" title="Solution Two: Collect Coordinates in Sorted Order"></a>Solution Two: Collect Coordinates in Sorted Order</h2><h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(n^2).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; rows = collectRows(grid);</span><br><span class="line">    List&lt;Integer&gt; cols = collectCols(grid);</span><br><span class="line">    <span class="keyword">int</span> row = rows.get(rows.size() / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> col = cols.get(cols.size() / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> minDistance1D(rows, row) + minDistance1D(cols, col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">minDistance1D</span><span class="params">(List&lt;Integer&gt; points, <span class="keyword">int</span> origin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> point : points) &#123;</span><br><span class="line">        distance += Math.abs(point - origin);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">collectRows</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; grid.length; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; grid[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[row][col] == <span class="number">1</span>) &#123;</span><br><span class="line">                rows.add(row);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rows;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">collectCols</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; cols = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; grid[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; grid.length; row++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[row][col] == <span class="number">1</span>) &#123;</span><br><span class="line">                cols.add(col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cols;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Premium</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 294 - Flip Game II</title>
    <url>/2020/07/11/leetcode-294/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip two consecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p>
<p>Write a function to determine if the starting player can guarantee a win.</p>
<p>Example:</p>
<p>Input: s = “++++”<br>Output: true<br>Explanation: The starting player can guarantee a win by flipping the middle “++” to become “+–+”.<br>Follow up:<br>Derive your algorithm’s runtime complexity.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 25 ms, faster than 51.86% of Java online submissions for Flip Game II.<br>Memory Usage: 37.3 MB, less than 92.94% of Java online submissions for Flip Game II.</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] arr;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWin</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        arr = s.toCharArray();</span><br><span class="line">        len = arr.length;</span><br><span class="line">        <span class="keyword">return</span> canwin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canwin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;len-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="string">'+'</span> &amp;&amp; arr[i+<span class="number">1</span>] == <span class="string">'+'</span>)&#123;</span><br><span class="line">                arr[i] = <span class="string">'-'</span>; arr[i+<span class="number">1</span>] = <span class="string">'-'</span>;</span><br><span class="line">                <span class="keyword">boolean</span> wins = !canwin();</span><br><span class="line">                arr[i] = <span class="string">'+'</span>; arr[i+<span class="number">1</span>] = <span class="string">'+'</span>;</span><br><span class="line">                <span class="keyword">if</span>(wins) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 298 - Binary Tree Longest Consecutive Sequence</title>
    <url>/2020/07/11/leetcode-298/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a binary tree, find the length of the longest consecutive sequence path.</p>
<p>The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).</p>
<p>Example 1:</p>
<p>Input:</p>
<p>   1<br>    <br>     3<br>    / <br>   2   4<br>        <br>         5</p>
<p>Output: 3</p>
<p>Explanation: Longest consecutive sequence path is 3-4-5, so return 3.<br>Example 2:</p>
<p>Input:</p>
<p>   2<br>    <br>     3<br>    /<br>   2<br>  /<br> 1</p>
<p>Output: 2 </p>
<p>Explanation: Longest consecutive sequence path is 2-3, not 3-2-1, so return 2.</p>
<h2 id="Solution-One-Bottom-up-DFS"><a href="#Solution-One-Bottom-up-DFS" class="headerlink" title="Solution One: Bottom up DFS"></a>Solution One: Bottom up DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 91.75% of Java online submissions for Binary Tree Longest Consecutive Sequence.<br>Memory Usage: 41.1 MB, less than 33.83% of Java online submissions for Binary Tree Longest Consecutive Sequence.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return longest len from root</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightLen = dfs(root.right);</span><br><span class="line">        <span class="keyword">int</span> leftLen = dfs(root.left);</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span> &amp;&amp; root.right.val == root.val + <span class="number">1</span>)</span><br><span class="line">            curLen = Math.max(curLen, <span class="number">1</span> + rightLen);</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.val == root.val + <span class="number">1</span>)</span><br><span class="line">            curLen = Math.max(curLen, <span class="number">1</span> + leftLen);</span><br><span class="line">        ans = Math.max(ans, curLen);</span><br><span class="line">        <span class="keyword">return</span> curLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Top-Down-DFS"><a href="#Solution-Two-Top-Down-DFS" class="headerlink" title="Solution Two: Top Down DFS"></a>Solution Two: Top Down DFS</h2><!-- more -->

<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(H), Time Complexity: O(N).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    dfs(root, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode p, TreeNode parent, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    length = (parent != <span class="keyword">null</span> &amp;&amp; p.val == parent.val + <span class="number">1</span>) ? length + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    maxLength = Math.max(maxLength, length);</span><br><span class="line">    dfs(p.left, p, length);</span><br><span class="line">    dfs(p.right, p, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 299 - Bulls and Cows</title>
    <url>/2020/07/11/leetcode-299/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are playing the following Bulls and Cows game with your friend: You write down a number and ask your friend to guess what the number is. Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called “bulls”) and how many digits match the secret number but locate in the wrong position (called “cows”). Your friend will use successive guesses and hints to eventually derive the secret number.</p>
<p>Write a function to return a hint according to the secret number and friend’s guess, use A to indicate the bulls and B to indicate the cows. </p>
<p>Please note that both secret number and friend’s guess may contain duplicate digits.</p>
<p>Example 1:</p>
<p>Input: secret = “1807”, guess = “7810”</p>
<p>Output: “1A3B”</p>
<p>Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.<br>Example 2:</p>
<p>Input: secret = “1123”, guess = “0111”</p>
<p>Output: “1A1B”</p>
<p>Explanation: The 1st 1 in friend’s guess is a bull, the 2nd or 3rd 1 is a cow.<br>Note: You may assume that the secret number and your friend’s guess only contain digits, and their lengths are always equal.</p>
<h2 id="Solution-One-Two-pass"><a href="#Solution-One-Two-pass" class="headerlink" title="Solution One: Two pass"></a>Solution One: Two pass</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 13 ms, faster than 18.15% of Java online submissions for Bulls and Cows.<br>Memory Usage: 40 MB, less than 25.16% of Java online submissions for Bulls and Cows.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] record1 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">char</span>[] record2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = secret.length();</span><br><span class="line">        <span class="keyword">int</span> bulls = <span class="number">0</span>, cows = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> c1 = secret.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> c2 = guess.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c1 == c2) bulls++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                record1[c1 - <span class="string">'0'</span>]++;</span><br><span class="line">                record2[c2 - <span class="string">'0'</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// scan for cows</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            cows += Math.min(record1[i], record2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(bulls) + <span class="string">"A"</span></span><br><span class="line">            + String.valueOf(cows) + <span class="string">"B"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-One-Pass"><a href="#Solution-Two-One-Pass" class="headerlink" title="Solution Two: One Pass"></a>Solution Two: One Pass</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">The idea is to iterate over the numbers in secret and in guess and count all bulls right away. For cows maintain an array that stores count of the number appearances in secret and in guess. Increment cows when either number from secret was already seen in guest or vice versa.</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bulls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;secret.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = Character.getNumericValue(secret.charAt(i));</span><br><span class="line">        <span class="keyword">int</span> g = Character.getNumericValue(guess.charAt(i));</span><br><span class="line">        <span class="keyword">if</span> (s == g) bulls++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[s] &lt; <span class="number">0</span>) cows++;</span><br><span class="line">            <span class="keyword">if</span> (numbers[g] &gt; <span class="number">0</span>) cows++;</span><br><span class="line">            numbers[s] ++;</span><br><span class="line">            numbers[g] --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bulls + <span class="string">"A"</span> + cows + <span class="string">"B"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A slightly more concise version:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHint</span><span class="params">(String secret, String guess)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bulls = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] numbers = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;secret.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (secret.charAt(i) == guess.charAt(i)) bulls++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[secret.charAt(i)-<span class="string">'0'</span>]++ &lt; <span class="number">0</span>) cows++;</span><br><span class="line">            <span class="keyword">if</span> (numbers[guess.charAt(i)-<span class="string">'0'</span>]-- &gt; <span class="number">0</span>) cows++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bulls + <span class="string">"A"</span> + cows + <span class="string">"B"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 329 - Longest Increasing Path in a Matrix</title>
    <url>/2020/07/08/leetcode-329/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an integer matrix, find the length of the longest increasing path.</p>
<p>From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).</p>
<p>Example 1:</p>
<p>Input: nums =<br>[<br>  [9,9,4],<br>  [6,6,8],<br>  [2,1,1]<br>]<br>Output: 4<br>Explanation: The longest increasing path is [1, 2, 6, 9].<br>Example 2:</p>
<p>Input: nums =<br>[<br>  [3,4,5],<br>  [3,2,6],<br>  [2,2,1]<br>]<br>Output: 4<br>Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.</p>
<h2 id="Solution-One-DFS-Memoization"><a href="#Solution-One-DFS-Memoization" class="headerlink" title="Solution One: DFS + Memoization"></a>Solution One: DFS + Memoization</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 23 ms, faster than 15.66% of Java online submissions for Longest Increasing Path in a Matrix.<br>Memory Usage: 52.2 MB, less than 13.43% of Java online submissions for Longest Increasing Path in a Matrix.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(mn), Time Complexity: O(mn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">int</span> rows, cols, ans;</span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        rows = matrix.length;</span><br><span class="line">        cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                ans = Math.max(ans, dfs(matrix, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">            <span class="keyword">int</span> ii = direction[<span class="number">0</span>] + i;</span><br><span class="line">            <span class="keyword">int</span> jj = direction[<span class="number">1</span>] + j;</span><br><span class="line">            <span class="keyword">if</span> (ii &gt;= <span class="number">0</span> &amp;&amp; jj &gt;= <span class="number">0</span> &amp;&amp; ii &lt; rows &amp;&amp; jj &lt; cols &amp;&amp; matrix[i][j] &gt; matrix[ii][jj])</span><br><span class="line">                memo[i][j] = Math.max(memo[i][j], <span class="number">1</span> + dfs(matrix, ii, jj));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Apple</tag>
        <tag>Memorization</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 442 - Find All Duplicates in an Array</title>
    <url>/2020/07/10/leetcode-442/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements that appear twice in this array.</p>
<p>Could you do it without extra space and in O(n) runtime?</p>
<p>Example:</p>
<p>Input:<br>[4,3,2,7,8,2,3,1]</p>
<p>Output:<br>[2,3]</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 9 ms, faster than 41.36% of Java online submissions for Find All Duplicates in an Array.<br>Memory Usage: 63.1 MB, less than 11.29% of Java online submissions for Find All Duplicates in an Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (nums[cur - <span class="number">1</span>] &lt; <span class="number">0</span>) ans.add(cur);</span><br><span class="line">            <span class="keyword">else</span> nums[cur - <span class="number">1</span>] = -nums[cur - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Leetcode-448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#Leetcode-448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="Leetcode 448 - Find All Numbers Disappeared in an Array"></a>Leetcode 448 - Find All Numbers Disappeared in an Array</h1><p><strong>Description</strong><br>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p>Example:</p>
<p>Input:<br>[4,3,2,7,8,2,3,1]</p>
<p>Output:<br>[5,6]</p>
<h2 id="Solution-One-1"><a href="#Solution-One-1" class="headerlink" title="Solution One"></a>Solution One</h2><h3 id="Result-1"><a href="#Result-1" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 11 ms, faster than 32.94% of Java online submissions for Find All Numbers Disappeared in an Array.<br>Memory Usage: 63.7 MB, less than 7.16% of Java online submissions for Find All Numbers Disappeared in an Array.</p>
<h3 id="Analysis-1"><a href="#Analysis-1" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(n).</p>
<h3 id="Java-code-1"><a href="#Java-code-1" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDisappearedNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Math.abs(nums[i]);</span><br><span class="line">            nums[cur - <span class="number">1</span>] = -Math.abs(nums[cur - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) ans.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 480 -  Sliding Window Median</title>
    <url>/2020/07/07/leetcode-480/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>Examples:<br>[2,3,4] , the median is 3</p>
<p>[2,3], the median is (2 + 3) / 2 = 2.5</p>
<p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.</p>
<p>For example,<br>Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.</p>
<p>Window position                Median</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       1<br> 1 [3  -1  -3] 5  3  6  7       -1<br> 1  3 [-1  -3  5] 3  6  7       -1<br> 1  3  -1 [-3  5  3] 6  7       3<br> 1  3  -1  -3 [5  3  6] 7       5<br> 1  3  -1  -3  5 [3  6  7]      6<br>Therefore, return the median sliding window as [1,-1,-1,3,5,6].</p>
<p>Note:<br>You may assume k is always valid, ie: k is always smaller than input array’s size for non-empty array.<br>Answers within 10^-5 of the actual value will be accepted as correct.</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 96 ms, faster than 39.36% of Java online submissions for Sliding Window Median.<br>Memory Usage: 42.6 MB, less than 18.65% of Java online submissions for Sliding Window Median.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(nlogk).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; leftQ = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1, Integer i2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i2.compareTo(i1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; rightQ = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span>[] ans = <span class="keyword">new</span> <span class="keyword">double</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// add to priorityQueue</span></span><br><span class="line">            <span class="keyword">if</span> (leftQ.isEmpty() || nums[i] &lt;= leftQ.peek()) </span><br><span class="line">                leftQ.add(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> rightQ.add(nums[i]);</span><br><span class="line">            <span class="comment">// adjust num</span></span><br><span class="line">            adjustPQ(leftQ, rightQ);</span><br><span class="line">            <span class="comment">// System.out.println("1: " + leftQ + ", 2: " + rightQ);</span></span><br><span class="line">            <span class="comment">// check median</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> start = i - k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">0</span>) ans[start] = (<span class="keyword">double</span>)leftQ.peek() / <span class="number">2f</span> + (<span class="keyword">double</span>)rightQ.peek() / <span class="number">2f</span>;</span><br><span class="line">                <span class="keyword">else</span> ans[start] = (<span class="keyword">double</span>)leftQ.peek();</span><br><span class="line">                <span class="comment">// slide window</span></span><br><span class="line">                <span class="keyword">if</span> (nums[start] &lt;= leftQ.peek()) leftQ.remove(nums[start]);</span><br><span class="line">                <span class="keyword">else</span> rightQ.remove(nums[start]);</span><br><span class="line">                adjustPQ(leftQ, rightQ);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">adjustPQ</span><span class="params">(PriorityQueue&lt;Integer&gt; leftQ, PriorityQueue&lt;Integer&gt; rightQ)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (rightQ.size() &gt; leftQ.size()) leftQ.add(rightQ.poll());</span><br><span class="line">        <span class="keyword">while</span> (leftQ.size() - rightQ.size() &gt; <span class="number">1</span>) rightQ.add(leftQ.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Sliding Window</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 540 - Single Element in a Sorted Array</title>
    <url>/2020/07/04/leetcode-540/</url>
    <content><![CDATA[<p><strong>Description</strong><br>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.</p>
<p>Follow up: Your solution should run in O(log n) time and O(1) space.</p>
<p>Example 1:</p>
<p>Input: nums = [1,1,2,3,3,4,4,8,8]<br>Output: 2<br>Example 2:</p>
<p>Input: nums = [3,3,7,7,10,11,11]<br>Output: 10</p>
<p>Constraints:</p>
<p>1 &lt;= nums.length &lt;= 10^5<br>0 &lt;= nums[i] &lt;= 10^5</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 0 ms, faster than 100.00% of Java online submissions for Single Element in a Sorted Array.<br>Memory Usage: 43 MB, less than 5.02% of Java online submissions for Single Element in a Sorted Array.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || mid == nums.length - <span class="number">1</span> || </span><br><span class="line">                (nums[mid] != nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] != nums[mid + <span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>) end = mid - <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] == nums[mid + 1]</span></span><br><span class="line">                <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">0</span>) start = mid + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Binary Search</tag>
        <tag>Bit Operations</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 729 - My Calendar I</title>
    <url>/2020/07/06/leetcode-729/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.</p>
<p>Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end.</p>
<p>A double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)</p>
<p>For each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.</p>
<p>Your class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)<br>Example 1:</p>
<p>MyCalendar();<br>MyCalendar.book(10, 20); // returns true<br>MyCalendar.book(15, 25); // returns false<br>MyCalendar.book(20, 30); // returns true<br>Explanation:<br>The first event can be booked.  The second can’t because time 15 is already booked by another event.<br>The third event can be booked, as the first event takes every time less than 20, but not including 20.</p>
<p>Note:</p>
<p>The number of calls to MyCalendar.book per test case will be at most 1000.<br>In calls to MyCalendar.book(start, end), start and end are integers in the range [0, 10^9].</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 52 ms, faster than 29.67% of Java online submissions for My Calendar I.<br>Memory Usage: 52.2 MB, less than 10.71% of Java online submissions for My Calendar I.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// My Solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; freeMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCalendar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        freeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        freeMap.put(<span class="number">0</span>, (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, <span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Integer slotStart = freeMap.floorKey(start);</span><br><span class="line">        <span class="keyword">if</span> (slotStart == <span class="keyword">null</span> || freeMap.get(slotStart) &lt; end) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Integer slotEnd = freeMap.get(slotStart);</span><br><span class="line">        freeMap.remove(start);</span><br><span class="line">        <span class="keyword">if</span> (slotStart &lt; start) freeMap.put(slotStart, start);</span><br><span class="line">        <span class="keyword">if</span> (slotEnd &gt; end) freeMap.put(end, slotEnd);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCalendar object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCalendar obj = new MyCalendar();</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.book(start,end);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Array</tag>
        <tag>Frequent</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 886 - Possible Bipartition</title>
    <url>/2020/07/09/leetcode-886/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a set of N people (numbered 1, 2, …, N), we would like to split everyone into two groups of any size.</p>
<p>Each person may dislike some other people, and they should not go into the same group. </p>
<p>Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group.</p>
<p>Return true if and only if it is possible to split everyone into two groups in this way.</p>
<p>Example 1:</p>
<p>Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]<br>Output: true<br>Explanation: group1 [1,4], group2 [2,3]<br>Example 2:</p>
<p>Input: N = 3, dislikes = [[1,2],[1,3],[2,3]]<br>Output: false<br>Example 3:</p>
<p>Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]<br>Output: false</p>
<p>Constraints:</p>
<p>1 &lt;= N &lt;= 2000<br>0 &lt;= dislikes.length &lt;= 10000<br>dislikes[i].length == 2<br>1 &lt;= dislikes[i][j] &lt;= N<br>dislikes[i][0] &lt; dislikes[i][1]<br>There does not exist i != j for which dislikes[i] == dislikes[j].</p>
<h2 id="Solution-One-DFS"><a href="#Solution-One-DFS" class="headerlink" title="Solution One: DFS"></a>Solution One: DFS</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 55 ms, faster than 17.06% of Java online submissions for Possible Bipartition.<br>Memory Usage: 47.9 MB, less than 48.52% of Java online submissions for Possible Bipartition.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(N + E), Time Complexity: O(N + E).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Set&lt;Integer&gt;&gt; graph;</span><br><span class="line">    Map&lt;Integer, Integer&gt; colorMap;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span>[][] dislikes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// build graph</span></span><br><span class="line">        graph = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        colorMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] dislike : dislikes) &#123;</span><br><span class="line">            Set&lt;Integer&gt; set = graph.getOrDefault(dislike[<span class="number">0</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            set.add(dislike[<span class="number">1</span>]);</span><br><span class="line">            graph.put(dislike[<span class="number">0</span>], set);</span><br><span class="line">            set = graph.getOrDefault(dislike[<span class="number">1</span>], <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">            set.add(dislike[<span class="number">0</span>]);</span><br><span class="line">            graph.put(dislike[<span class="number">1</span>], set);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// place node in array</span></span><br><span class="line">        Object[] arr = graph.keySet().toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length ; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = (<span class="keyword">int</span>)arr[i];</span><br><span class="line">            <span class="keyword">if</span> (colorMap.containsKey(n)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!place(n, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        colorMap.put(n, color);</span><br><span class="line">        <span class="comment">// add next one</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(n)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (colorMap.containsKey(next)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorMap.get(next) == color) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            graph.get(next).remove(n);</span><br><span class="line">            <span class="keyword">if</span>(!place(next, <span class="number">1</span> - color)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS</tag>
        <tag>Java</tag>
        <tag>Frequent</tag>
        <tag>Graph</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 231 - Power of Two</title>
    <url>/2020/07/05/leetcode-231/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given an integer, write a function to determine if it is a power of two.</p>
<p>Example 1:</p>
<p>Input: 1<br>Output: true<br>Explanation: 20 = 1<br>Example 2:</p>
<p>Input: 16<br>Output: true<br>Explanation: 24 = 16<br>Example 3:</p>
<p>Input: 218<br>Output: false</p>
<h2 id="Solution-One"><a href="#Solution-One" class="headerlink" title="Solution One"></a>Solution One</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 2 ms, faster than 37.23% of Java online submissions for Power of Two.<br>Memory Usage: 38.5 MB, less than 10.59% of Java online submissions for Power of Two.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(1), Time Complexity: O(logn).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; isPowerOfTwo(n / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Solution-Two-Bitwise"><a href="#Solution-Two-Bitwise" class="headerlink" title="Solution Two: Bitwise"></a>Solution Two: Bitwise</h2>]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Bit Operations</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 241 - Different Ways to Add Parentheses</title>
    <url>/2020/07/05/leetcode-241/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.</p>
<p>Example 1:</p>
<p>Input: “2-1-1”<br>Output: [0, 2]<br>Explanation:<br>((2-1)-1) = 0<br>(2-(1-1)) = 2<br>Example 2:</p>
<p>Input: “2<em>3-4*5”<br>Output: [-34, -14, -10, -10, 10]<br>Explanation:<br>(2</em>(3-(4<em>5))) = -34<br>((2<em>3)-(4</em>5)) = -14<br>((2</em>(3-4))<em>5) = -10<br>(2</em>((3-4)<em>5)) = -10<br>(((2</em>3)-4)*5) = 10</p>
<h2 id="Solution-One-Recursive-with-memo"><a href="#Solution-One-Recursive-with-memo" class="headerlink" title="Solution One: Recursive with memo"></a>Solution One: Recursive with memo</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 1 ms, faster than 98.83% of Java online submissions for Different Ways to Add Parentheses.<br>Memory Usage: 38 MB, less than 81.39% of Java online submissions for Different Ways to Add Parentheses.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p><a href="http://people.math.sc.edu/howard/Classes/554b/catalan.pdf" target="_blank" rel="noopener">http://people.math.sc.edu/howard/Classes/554b/catalan.pdf</a></p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; memoMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memoMap.containsKey(input)) <span class="keyword">return</span> memoMap.get(input);</span><br><span class="line">        List&lt;Integer&gt; ret = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input.charAt(i) == <span class="string">'-'</span> ||</span><br><span class="line">                input.charAt(i) == <span class="string">'*'</span> ||</span><br><span class="line">                input.charAt(i) == <span class="string">'+'</span> ) &#123;</span><br><span class="line">                String part1 = input.substring(<span class="number">0</span>, i);</span><br><span class="line">                String part2 = input.substring(i+<span class="number">1</span>);</span><br><span class="line">                List&lt;Integer&gt; part1Ret = diffWaysToCompute(part1);</span><br><span class="line">                List&lt;Integer&gt; part2Ret = diffWaysToCompute(part2);</span><br><span class="line">                <span class="keyword">for</span> (Integer p1 :   part1Ret) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Integer p2 :   part2Ret) &#123;</span><br><span class="line">                        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">switch</span> (input.charAt(i)) &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'+'</span>: c = p1+p2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'-'</span>: c = p1-p2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">'*'</span>: c = p1*p2;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ret.add(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.add(Integer.valueOf(input));</span><br><span class="line">        &#125;</span><br><span class="line">        memoMap.put(input, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Frequent</tag>
        <tag>Calculator</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 895 - Maximum Frequency Stack</title>
    <url>/2020/07/04/leetcode-895/</url>
    <content><![CDATA[<p><strong>Description</strong><br>Implement FreqStack, a class which simulates the operation of a stack-like data structure.</p>
<p>FreqStack has two functions:</p>
<p>push(int x), which pushes an integer x onto the stack.<br>pop(), which removes and returns the most frequent element in the stack.<br>If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.</p>
<p>Example 1:</p>
<p>Input:<br>[“FreqStack”,”push”,”push”,”push”,”push”,”push”,”push”,”pop”,”pop”,”pop”,”pop”],<br>[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]<br>Output: [null,null,null,null,null,null,null,5,7,5,4]<br>Explanation:<br>After making six .push operations, the stack is [5,7,5,7,4,5] from bottom to top.  Then:</p>
<p>pop() -&gt; returns 5, as 5 is the most frequent.<br>The stack becomes [5,7,5,7,4].</p>
<p>pop() -&gt; returns 7, as 5 and 7 is the most frequent, but 7 is closest to the top.<br>The stack becomes [5,7,5,4].</p>
<p>pop() -&gt; returns 5.<br>The stack becomes [5,7,4].</p>
<p>pop() -&gt; returns 4.<br>The stack becomes [5,7].</p>
<p>Note:</p>
<p>Calls to FreqStack.push(int x) will be such that 0 &lt;= x &lt;= 10^9.<br>It is guaranteed that FreqStack.pop() won’t be called if the stack has zero elements.<br>The total number of FreqStack.push calls will not exceed 10000 in a single test case.<br>The total number of FreqStack.pop calls will not exceed 10000 in a single test case.<br>The total number of FreqStack.push and FreqStack.pop calls will not exceed 150000 across all test cases.</p>
<h2 id="Solution-One-Stack-of-Stack"><a href="#Solution-One-Stack-of-Stack" class="headerlink" title="Solution One: Stack of Stack"></a>Solution One: Stack of Stack</h2><a id="more"></a>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>Runtime: 71 ms, faster than 14.22% of Java online submissions for Maximum Frequency Stack.<br>Memory Usage: 48.9 MB, less than 60.74% of Java online submissions for Maximum Frequency Stack.</p>
<h3 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h3><p>Space Complexity: O(n), Time Complexity: O(1).</p>
<h3 id="Java-code"><a href="#Java-code" class="headerlink" title="Java code"></a>Java code</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreqStack</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Map&lt;Integer, Integer&gt; freqMap;</span><br><span class="line">    Map&lt;Integer, ArrayDeque&lt;Integer&gt;&gt; stackMap;</span><br><span class="line">    <span class="keyword">int</span> maxFreq;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FreqStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        freqMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        stackMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        maxFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> freq = freqMap.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        freqMap.put(x, freq);</span><br><span class="line">        maxFreq = Math.max(maxFreq, freq);</span><br><span class="line">        stackMap.computeIfAbsent(freq, z-&gt; <span class="keyword">new</span> ArrayDeque&lt;&gt;()).push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = stackMap.get(maxFreq).pop();</span><br><span class="line">        freqMap.put(x, freqMap.get(x) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (stackMap.get(maxFreq).size() == <span class="number">0</span>)</span><br><span class="line">            maxFreq--;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>work</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Java</tag>
        <tag>Pending</tag>
        <tag>Hard</tag>
        <tag>Frequent</tag>
        <tag>Stack</tag>
        <tag>Apple</tag>
      </tags>
  </entry>
</search>
